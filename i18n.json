[
  {
    "id": null,
    "src": null,
    "dst": null,
    "votes": 0
  },
  {
    "id": null,
    "src": null,
    "dst": null,
    "votes": 0
  },
  {
    "id": null,
    "src": null,
    "dst": null,
    "votes": 0
  },
  {
    "id": null,
    "src": null,
    "dst": null,
    "votes": 0
  },
  {
    "id": null,
    "src": null,
    "dst": null,
    "votes": 0
  },
  {
    "id": null,
    "src": null,
    "dst": null,
    "votes": 0
  },
  {
    "id": null,
    "src": null,
    "dst": null,
    "votes": 0
  },
  {
    "id": null,
    "src": "(*text in chapter #0*)",
    "dst": "(*#0的字*)",
    "votes": 0
  },
  {
    "id": null,
    "src": "(*text in chapter #0*)",
    "dst": "(*#0的字*)",
    "votes": 0
  },
  {
    "id": null,
    "src": "(*NONE*)",
    "dst": "",
    "votes": 0
  },
  {
    "id": null,
    "src": "(*NONE*)",
    "dst": "",
    "votes": 0
  },
  {
    "id": null,
    "src": "(*NONE*)",
    "dst": "(*没*)",
    "votes": 0
  },
  {
    "id": null,
    "src": "(*text in chapter #0*)",
    "dst": "(*TEXT in chapter #0*)",
    "votes": 0
  },
  {
    "id": null,
    "src": "(* E_Skip *)",
    "dst": "(* E_Skip *)",
    "votes": 0
  },
  {
    "id": null,
    "src": "(* E_Ass *)",
    "dst": "(* E_Ass *)",
    "votes": 0
  },
  {
    "id": null,
    "src": "(* ################################################################# *)",
    "dst": "(* ################################################################# *)",
    "votes": 0
  },
  {
    "id": null,
    "src": null,
    "dst": null,
    "votes": 0
  },
  {
    "id": null,
    "src": null,
    "dst": null,
    "votes": 0
  },
  {
    "id": null,
    "src": null,
    "dst": null,
    "votes": 0
  },
  {
    "id": null,
    "src": null,
    "dst": null,
    "votes": 0
  },
  {
    "id": null,
    "src": null,
    "dst": null,
    "votes": 0
  },
  {
    "id": null,
    "src": null,
    "dst": null,
    "votes": 0
  },
  {
    "id": null,
    "src": null,
    "dst": null,
    "votes": 0
  },
  {
    "id": null,
    "src": "(*text in chapter #0*)",
    "dst": "(*#0的字*)",
    "votes": 0
  },
  {
    "id": null,
    "src": "(*text in chapter #0*)",
    "dst": "(*#0的字*)",
    "votes": 0
  },
  {
    "id": null,
    "src": "(*NONE*)",
    "dst": "",
    "votes": 0
  },
  {
    "id": null,
    "src": "(*NONE*)",
    "dst": "",
    "votes": 0
  },
  {
    "id": null,
    "src": "(*NONE*)",
    "dst": "(*没*)",
    "votes": 0
  },
  {
    "id": null,
    "src": "(*text in chapter #0*)",
    "dst": "(*TEXT in chapter #0*)",
    "votes": 0
  },
  {
    "id": null,
    "src": "(* E_Skip *)",
    "dst": "(* E_Skip *)",
    "votes": 0
  },
  {
    "id": null,
    "src": "(* E_Ass *)",
    "dst": "(* E_Ass *)",
    "votes": 0
  },
  {
    "id": null,
    "src": "(* ################################################################# *)",
    "dst": "(* ################################################################# *)",
    "votes": 0
  },
  {
    "id": null,
    "src": "(* ################################################################# *)",
    "dst": "(* ################################################################# *)",
    "votes": 0
  },
  {
    "id": null,
    "src": "(* ################################################################# *)",
    "dst": "(* ################################################################# *)",
    "votes": 0
  },
  {
    "id": 1,
    "src": "(** FULL: The [auto] tactic frees us from this drudgery by _searching_ for a\n    sequence of applications that will prove the goal *)",
    "dst": "(** FULL: The [auto] tactic frees us from this drudgery by _搜索_ for a\n    sequence of applications that will prove the goal *)",
    "votes": 0
  },
  {
    "id": 2,
    "src": "(** TERSE: [auto] considers the hypotheses in the current context\n    together with a _hint database_ of other lemmas and constructors.\n    Some common facts about equality and logical operators are\n    installed by default. *)",
    "dst": "(** TERSE: [auto] considers the hypotheses in the current context\n    together with a _线索数据库_ of other lemmas and constructors.\n    Some common facts about equality and logical operators are\n    installed by default. *)",
    "votes": 0
  },
  {
    "id": 3,
    "src": "(** FULL: When searching for potential proofs of the current goal,\n    [auto] considers the hypotheses in the current context together\n    with a _hint database_ of other lemmas and constructors.  Some\n    common lemmas about equality and logical operators are installed\n    in this hint database by default. *)",
    "dst": "(** FULL: When searching for potential proofs of the current goal,\n    [auto] considers the hypotheses in the current context together\n    with a _线索数据库_ of other lemmas and constructors.  Some\n    common lemmas about equality and logical operators are installed\n    in this hint database by default. *)",
    "votes": 0
  },
  {
    "id": 4,
    "src": "(** TERSE: Managing the hint database...\n\n      - [Hint Resolve T.]\n\n          Add theorem or constructor [T] to the global DB\n\n      - [Hint Constructors c.]\n\n          Add _all_ constructors of [c] to the global DB\n\n      - [Hint Unfold d.]\n\n          Automatically expand defined symbol [d] during [auto]\n*)",
    "dst": "(** TERSE: Managing the hint database...\n\n      - [Hint Resolve T.]\n\n          Add theorem or constructor [T] to the global DB\n\n      - [Hint Constructors c.]\n\n          Add _全部_ constructors of [c] to the global DB\n\n      - [Hint Unfold d.]\n\n          Automatically expand defined symbol [d] during [auto]\n*)",
    "votes": 0
  },
  {
    "id": 5,
    "src": "(** * Auto: More Automation *)",
    "dst": "(** * Auto: 更多自动化 *)",
    "votes": 0
  },
  {
    "id": 6,
    "src": "(** FULL: The [auto] tactic frees us from this drudgery by _searching_ for a\n    sequence of applications that will prove the goal *)",
    "dst": "(** FULL: The [auto] tactic frees us from this drudgery by _'搜索'_ for a\n    sequence of applications that will prove the goal *)",
    "votes": 0
  },
  {
    "id": 7,
    "src": "(** TERSE: [auto] considers the hypotheses in the current context\n    together with a _hint database_ of other lemmas and constructors.\n    Some common facts about equality and logical operators are\n    installed by default. *)",
    "dst": "(** TERSE: [auto] considers the hypotheses in the current context\n    together with a _'线索数据库'_ of other lemmas and constructors.\n    Some common facts about equality and logical operators are\n    installed by default. *)",
    "votes": 0
  },
  {
    "id": 8,
    "src": "(** FULL: When searching for potential proofs of the current goal,\n    [auto] considers the hypotheses in the current context together\n    with a _hint database_ of other lemmas and constructors.  Some\n    common lemmas about equality and logical operators are installed\n    in this hint database by default. *)",
    "dst": "(** FULL: When searching for potential proofs of the current goal,\n    [auto] considers the hypotheses in the current context together\n    with a _'线索数据库'_ of other lemmas and constructors.  Some\n    common lemmas about equality and logical operators are installed\n    in this hint database by default. *)",
    "votes": 0
  },
  {
    "id": 9,
    "src": "(** TERSE: Managing the hint database...\n\n      - [Hint Resolve T.]\n\n          Add theorem or constructor [T] to the global DB\n\n      - [Hint Constructors c.]\n\n          Add _all_ constructors of [c] to the global DB\n\n      - [Hint Unfold d.]\n\n          Automatically expand defined symbol [d] during [auto]\n*)",
    "dst": "(** TERSE: Managing the hint database...\n\n      - [Hint Resolve T.]\n\n          Add theorem or constructor [T] to the global DB\n\n      - [Hint Constructors c.]\n\n          Add _'全部'_ constructors of [c] to the global DB\n\n      - [Hint Unfold d.]\n\n          Automatically expand defined symbol [d] during [auto]\n*)",
    "votes": 0
  },
  {
    "id": 10,
    "src": "(** ** Proof Assistants *)",
    "dst": "(** ** 证明助理 *)",
    "votes": 0
  },
  {
    "id": 11,
    "src": "(** The flow of ideas between logic and computer science has not been\n    unidirectional: CS has also made important contributions to logic.\n    One of these has been the development of software tools for\n    helping construct proofs of logical propositions.  These tools\n    fall into two broad categories:\n\n       - _Automated theorem provers_ provide \"push-button\" operation:\n         you give them a proposition and they return either _true_ or\n         _false_ (or, sometimes, _don't know: ran out of time_).\n         Although their capabilities are still limited to specific\n         domains, they have matured tremendously in recent years and\n         are used now in a multitude of settings.  Examples of such\n         tools include SAT solvers, SMT solvers, and model checkers.\n\n       - _Proof assistants_ are hybrid tools that automate the more\n         routine aspects of building proofs while depending on human\n         guidance for more difficult aspects.  Widely used proof\n         assistants include Isabelle, Agda, Twelf, ACL2, PVS, and Coq,\n         among many others.\n\n    This course is based around Coq, a proof assistant that has been\n    under development since 1983 and that in recent years has\n    attracted a large community of users in both research and\n    industry.  Coq provides a rich environment for interactive\n    development of machine-checked formal reasoning.  The kernel of\n    the Coq system is a simple proof-checker, which guarantees that\n    only correct deduction steps are ever performed.  On top of this\n    kernel, the Coq environment provides high-level facilities for\n    proof development, including a large library of common definitions\n    and lemmas, powerful tactics for constructing complex proofs\n    semi-automatically, and a special-purpose programming language for\n    defining new proof-automation tactics for specific situations.\n\n    Coq has been a critical enabler for a huge variety of work across\n    computer science and mathematics:\n\n    - As a _platform for modeling programming languages_, it has\n      become a standard tool for researchers who need to describe and\n      reason about complex language definitions.  It has been used,\n      for example, to check the security of the JavaCard platform,\n      obtaining the highest level of common criteria certification,\n      and for formal specifications of the x86 and LLVM instruction\n      sets and programming languages such as C.\n\n    - As an _environment for developing formally certified software\n      and hardware_, Coq has been used, for example, to build\n      CompCert, a fully-verified optimizing compiler for C, and\n      CertiKos, a fully verified hypervisor, for proving the\n      correctness of subtle algorithms involving floating point\n      numbers, and as the basis for CertiCrypt, an environment for\n      reasoning about the security of cryptographic algorithms.  It is\n      also being used to build verified implementations of the\n      open-source RISC-V processor.\n\n    - As a _realistic environment for functional programming with\n      dependent types_, it has inspired numerous innovations.  For\n      example, the Ynot system embeds \"relational Hoare reasoning\" (an\n      extension of the _Hoare Logic_ we will see later in this course)\n      in Coq.\n\n    - As a _proof assistant for higher-order logic_, it has been used\n      to validate a number of important results in mathematics.  For\n      example, its ability to include complex computations inside\n      proofs made it possible to develop the first formally verified\n      proof of the 4-color theorem.  This proof had previously been\n      controversial among mathematicians because part of it included\n      checking a large number of configurations using a program. In\n      the Coq formalization, everything is checked, including the\n      correctness of the computational part.  More recently, an even\n      more massive effort led to a Coq formalization of the\n      Feit-Thompson Theorem -- the first major step in the\n      classification of finite simple groups.\n\n   By the way, in case you're wondering about the name, here's what\n   the official Coq web site at INRIA (the French national research\n   lab where Coq has mostly been developed) says about it: \"Some\n   French computer scientists have a tradition of naming their\n   software as animal species: Caml, Elan, Foc or Phox are examples of\n   this tacit convention. In French, 'coq' means rooster, and it\n   sounds like the initials of the Calculus of Constructions (CoC) on\n   which it is based.\"  The rooster is also the national symbol of\n   France, and C-o-q are the first three letters of the name of\n   Thierry Coquand, one of Coq's early developers. *)",
    "dst": "(** 逻辑学与计算机科学之间的思想交流并不是单方面的：\n    计算机科学也对逻辑学做出了重要的贡献，\n    其中之一就是发展了可帮助构造命题/证明的软件工具。\n    这些工具分为两类：\n       - _'自动化定理证明器'_提供了一键式操作：它们接受一个命题，\n         然后返回_'真'_或_'假'_（或有时为_'未知：超时'_���。\n         尽管它们的能力仅限于特定种类的推理中，但在近几年却大幅成熟并应用于多种场合，\n         自动化定理证明器的例子包括 SAT 求解器，SMT 求解器以及模型检查器（Model Checker）。\n       - _'证明助理'_是一种混合式工具，它能将构建证明中比较常规的部分自动化，\n         而更困难的部分则依赖于人类解决。常用的证明助理包括\n         Isabelle、Agda、Twelf、ACL2、PVS 以及 Coq，还有很多其它的。\n    本课程围绕 Coq 展开。它是一个自 1983 年以来主要在法国开发的证明助理，\n    近年来吸引了大量来自研究机构和业界的社区用户。\n    Coq 为机器验证的形式化论证的交互式开发提供了丰富的环境。Coq 系统的内核是一个简单的证明验证器，\n    它保证只会进行正确的推论步骤。在此内核之上，Coq 环境提供了高级的证明开发设施，\n    包括一个包含各种定义和引理的庞大的库，用于半自动化构造证明的强大策略，\n    以及一个专门为特殊情况定义新的自动证明策略的专用编程语言。\n    Coq 已成为各种跨计算机科学和数学研究的关键推动者：\n    - 作为一个_'编程语言的建模平台'_，\n      Coq 成为了研究员对复杂语言定义进行描述和论证的一个标准工具。\n      例如，它被用来检查 JavaCard 平台的安全性，得到了最高等级的通用准则验证，\n      它还被用在 x86 和 LLVM 指令集以及 C 之类的编程语言的形式化规范中。\n    - 作为一个_'形式化验证软件的开发环境'_，Coq 被用来构建：\n      CompCert，一个完全验证过的 C 优化编译器；\n      CertiKos，一个完全验证过的，用于证明浮点数相关精妙算法的正确性；\n      Coq 也是 CertiCrypt，一个用于论证密码学算法安全性的环境的基础。\n      它也被用来构建开源 RISC-V 处理器的已验证实现。\n    - 作为一个_'带依赖类型的函数式编程的现实环境'_，Coq 激发了大量的创新。\n      例如 Ynot 系统嵌入了「关系式霍尔推理」（一个_'霍尔逻辑'_的扩展，我们会在后面看到它）。\n    - 作为一个_'高阶逻辑的证明助理'_，Coq 被用于证实数学中一些重要的结果。\n      例如 Coq 可在证明中包含复杂计算的能力，使其开发出第一个形式化验证的四色定理证明。\n      此前数学家们对该证明颇有争议，因为其中一部分用程序对大量组态进行了检查。\n      在 Coq 的形式化中，所有东西都被检查了，自然包括计算方面的正确性。\n      近年来，Feit-Thompson 定理在更大的努力下用 Coq 形式化了，\n      这���对有限单群进行分类的第一大步。\n   顺便一提，如果你对 Coq 这个名字感到好奇，INRIA (法国国家研究实验室，Coq\n   主要在这里开发）上的 Coq 官方网站给出了解释：\n   「一些法国计算机科学家有用动物命名软件的传统：像 Caml、Elan、Foc、Phox\n   都心照不宣地遵循这种默契。在法国，「Coq」是雄鸡，发音也像\n   Calculus of Constructions 的首字母缩写（CoC），后者是 Coq 的基础。」\n   高卢雄鸡是法国的象征。C-o-q 还是 Thierry Coquand 名字的前三个字母，\n   他是 Coq 的早期开发者之一。 *)",
    "votes": 0
  },
  {
    "id": 12,
    "src": "(** ** Functional Programming *)",
    "dst": "(** ** 函数式编程 *)",
    "votes": 0
  },
  {
    "id": 13,
    "src": "(** The term _functional programming_ refers both to a collection of\n    programming idioms that can be used in almost any programming\n    language and to a family of programming languages designed to\n    emphasize these idioms, including Haskell, OCaml, Standard ML,\n    F##, Scala, Scheme, Racket, Common Lisp, Clojure, Erlang, and Coq.\n\n    Functional programming has been developed over many decades --\n    indeed, its roots go back to Church's lambda-calculus, which was\n    invented in the 1930s, well before the first computers (at least\n    the first electronic ones)!  But since the early '90s it has\n    enjoyed a surge of interest among industrial engineers and\n    language designers, playing a key role in high-value systems at\n    companies like Jane St. Capital, Microsoft, Facebook, and\n    Ericsson.\n\n    The most basic tenet of functional programming is that, as much as\n    possible, computation should be _pure_, in the sense that the only\n    effect of execution should be to produce a result: it should be\n    free from _side effects_ such as I/O, assignments to mutable\n    variables, redirecting pointers, etc.  For example, whereas an\n    _imperative_ sorting function might take a list of numbers and\n    rearrange its pointers to put the list in order, a pure sorting\n    function would take the original list and return a _new_ list\n    containing the same numbers in sorted order.\n\n    A significant benefit of this style of programming is that it\n    makes programs easier to understand and reason about.  If every\n    operation on a data structure yields a new data structure, leaving\n    the old one intact, then there is no need to worry about how that\n    structure is being shared and whether a change by one part of the\n    program might break an invariant that another part of the program\n    relies on.  These considerations are particularly critical in\n    concurrent systems, where every piece of mutable state that is\n    shared between threads is a potential source of pernicious bugs.\n    Indeed, a large part of the recent interest in functional\n    programming in industry is due to its simpler behavior in the\n    presence of concurrency.\n\n    Another reason for the current excitement about functional\n    programming is related to the first: functional programs are often\n    much easier to parallelize than their imperative counterparts.  If\n    running a computation has no effect other than producing a result,\n    then it does not matter _where_ it is run.  Similarly, if a data\n    structure is never modified destructively, then it can be copied\n    freely, across cores or across the network.  Indeed, the\n    \"Map-Reduce\" idiom, which lies at the heart of massively\n    distributed query processors like Hadoop and is used by Google to\n    index the entire web is a classic example of functional\n    programming.\n\n    For purposes of this course, functional programming has yet\n    another significant attraction: it serves as a bridge between\n    logic and computer science.  Indeed, Coq itself can be viewed as a\n    combination of a small but extremely expressive functional\n    programming language plus a set of tools for stating and proving\n    logical assertions.  Moreover, when we come to look more closely,\n    we find that these two sides of Coq are actually aspects of the\n    very same underlying machinery -- i.e., _proofs are programs_.  *)",
    "dst": "(** _'函数式编程'_既代表几乎可以在任何编程语言中使用的一系列惯用法，也代表着一族\n    以这些习惯用法为侧重点设计的编程语言，包括 Haskell、OCaml、Standard ML、F##、\n    Scala、Scheme、Racket、Common Lisp、Erlang 还有 Coq。\n    函数式编程已经有数十年历史了--实际上，它甚至可以追溯到 1930\n    年代 Church 发明的 λ-演算，那时候还没有计算机呢！自 90 年代初以来，\n    函数式编程激起了业内软件工程师和语言设计者浓厚的兴趣，它还在\n    Jane St. Capital、Microsoft、Facebook 和 Ericsson\n    等公司的高价值系统中发挥着关键的作用。\n    函数式编程最根本的原则是，计算应当尽可能地_'纯粹'_，也就是说，\n    执行代码的唯一效果应当是只产生一个结果：计算应当没有_'副作用'_，\n    即与输入/输出、可变量的赋值、指针重定向等等脱离。\n    例如，一个命令式的排序函数会接受一个数字列表，通过重组指针使列表得以排序；\n    而一个纯粹的排序函数则会取一个列表，返回一个含有同样数字，但是已排序的新列表。\n    这种编程风格最明显的好处之一，就是它能让程序变得更容易理解和论证。\n    如果对某个数据结构的所有操作都会返回新的数据结构，而旧有的结构没有变动，\n    那么我们便无需担心它的共享方式，因为程序中一部分的改变并不会破坏另一部分的属性。\n    在并发程序中，线程间共享的每一个可变状态都是致命 Bug 的潜在来源，\n    因此这方面的考虑尤为关键。事实上，业界最近对函数式编程的兴趣大部分来源于���，\n    即它在并发中表现出的简单行为。\n    人们对函数式编程感到兴奋的另一原因与前文所述的原因相关：\n    函数式程序通常比命令式程序更容易并行化。\n    如果一个计算除了产生结果之外没有其它的作用，那么它在_'何时'_执行便不再重要。\n    同样，如果一个数据结构不会被破坏性地修改，那么它可以跨核心或网络地被随意复制。\n    其实，「映射-归纳」（Map-Reduce）的惯用法就是函数式编程的经典例子，\n    它在大规模分布式查询处理器（如 Hadoop）中处于核心地位，并被 Google\n    用来索引整个互联网。\n    对于本课程而言，函数式编程还有另一个重要的吸引力：\n    它在逻辑与计算机科学之间架起了一座桥梁。事实上，Coq\n    本身即可视作一个小巧却有着极强表达能力的函数式编程语言，\n    以及一组用于陈述和证明逻辑断言的工具的结合体。进而言之，\n    当我们更加深入地审视它时，会发现 Coq 的这两方面其实基于几乎相同的底层机制\n    -- _'命题即类型，程序即证明'_，可谓殊途同归。 *)",
    "votes": 0
  },
  {
    "id": 14,
    "src": "(** ** Program Verification *)",
    "dst": "(** ** 程序验证 *)",
    "votes": 0
  },
  {
    "id": 15,
    "src": "(** Approximately the first third of _Software Foundations_ is devoted\n    to developing the conceptual framework of logic and functional\n    programming and gaining enough fluency with Coq to use it for\n    modeling and reasoning about nontrivial artifacts.  In the middle\n    third, we turn our attention to two broad topics of critical\n    importance in building reliable software (and hardware):\n    techniques for proving specific properties of particular\n    _programs_ and for proving general properties of whole programming\n    _languages_.\n\n    For both of these, the first thing we need is a way of\n    representing programs as mathematical objects, so we can talk\n    about them precisely, plus ways of describing their behavior in\n    terms of mathematical functions or relations.  Our main tools for\n    these tasks are _abstract syntax_ and _operational semantics_, a\n    method of specifying programming languages by writing abstract\n    interpreters.  At the beginning, we work with operational\n    semantics in the so-called \"big-step\" style, which leads to simple\n    and readable definitions when it is applicable.  Later on, we\n    switch to a lower-level \"small-step\" style, which helps make some\n    useful distinctions (e.g., between different sorts of\n    nonterminating program behaviors) and which is applicable to a\n    broader range of language features, including concurrency.\n\n    The first programming language we consider in detail is _Imp_, a\n    tiny toy language capturing the core features of conventional\n    imperative programming: variables, assignment, conditionals, and\n    loops.\n\n    We study two different ways of reasoning about the properties of\n    Imp programs.  First, we consider what it means to say that two\n    Imp programs are _equivalent_ in the intuitive sense that they\n    exhibit the same behavior when started in any initial memory\n    state.  This notion of equivalence then becomes a criterion for\n    judging the correctness of _metaprograms_ -- programs that\n    manipulate other programs, such as compilers and optimizers.  We\n    build a simple optimizer for Imp and prove that it is correct.\n(* LATER: Do we also build a little compiler someplace?  If not, we\n   should! :-) *)\n\n    Second, we develop a methodology for proving that a given Imp\n    program satisfies some formal specifications of its behavior.  We\n    introduce the notion of _Hoare triples_ -- Imp programs annotated\n    with pre- and post-conditions describing what they expect to be\n    true about the memory in which they are started and what they\n    promise to make true about the memory in which they terminate --\n    and the reasoning principles of _Hoare Logic_, a domain-specific\n    logic specialized for convenient compositional reasoning about\n    imperative programs, with concepts like \"loop invariant\" built in.\n\n    This part of the course is intended to give readers a taste of the\n    key ideas and mathematical tools used in a wide variety of\n    real-world software and hardware verification tasks. *)",
    "dst": "(** 本书的前三分之一用于发展逻辑学以及函数式编程的概念框架，提升用\n    Coq 对非平凡构造进行建模和论证的熟练度。此后，我们会逐渐将重点转移到\n    对构建可靠软件（和硬件）的事业而言至关重要的两个主题上：\n    用于证明特定_'程序_具体属性的技巧，以及用于证明整个编程_语言'_共通属性的技术。\n    对于这两个主题来说，我们首先要找出一种用将程序表示为数学对象的方法，\n    以此来对二者进行精确的描述，以及用函数或关系表示它们的行为。\n    对此而言，我们的工具是抽象语法（Abstract Syntax）和操作语义（Operational\n    Semantics），一种通过编写抽象解释器来指定程序行为的方法。\n    首先，我们尽量用「大跨步」的方式来产生更加简单可读的操作语义；\n    之后，我们会转换到更加详细的「小碎步」风格，这样能有效地区分不同种类的「非最终」\n    程序的行为，这种方式适用于更加广泛的语言特性，包括并发。\n    我们要仔细考虑的第一个编程语言是 _'Imp'_，一个小巧的玩具编程语言，\n    它包含了传统命令式编程的核心特性：变量、赋值、条件和循环。\n    我们会学习两种不同的方法来对 Imp 程序的属性进行论证。\n    首先，若两个 Imp 程序在任何初始内存状态下启动都有相同的行为，\n    那么我们便认为二者是_'等价的'_。这种等价的概念便成为了判定元程序\n    （操控其它程序的程序，比如编译器和优化器）正确性的标准。\n    我们会为 Imp 构建一个简单的优化器并证明其正确性。\n(* LATER: Do we also build a little compiler someplace?  If not, we\n   should! :-) *)\n    之后，我们会发展出一套方法论，用于证明特定 Imp 程序的行为是否满足其形式化规范。\n    我们会介绍_'霍尔三元组'_（Hoare triples）的概念：带有前置和后置条件的 Imp\n    程序描述了在它启动时，存中的什么应���为真；在它终止后，它保证内存中的什么为真。\n    也会介绍_'霍尔逻辑'_（Hoare Logic）的推理原则：一种内建了循环不变式（loop-invariant）\n    等概念的「领域专用逻辑」，以便对命令式程序进行组合推理。\n    本课程的这一部分意在让读者尝试各种现实中软件和硬件的证明工作，\n    以此来获得所需要的关键思想和数学工具。*)",
    "votes": 0
  },
  {
    "id": 16,
    "src": "(** ** Type Systems *)",
    "dst": "(** ** 类型系统 *)",
    "votes": 0
  },
  {
    "id": 17,
    "src": "(** Our final major topic, covering approximately the last third of\n    the course, is _type systems_, which are powerful tools for\n    establishing properties of _all_ programs in a given language.\n(* SOONER: Write some more about what type systems are and how they\n   work. *)\n\n    Type systems are the best established and most popular example of\n    a highly successful class of formal verification techniques known\n    as _lightweight formal methods_.  These are reasoning techniques\n    of modest power -- modest enough that automatic checkers can be\n    built into compilers, linkers, or program analyzers and thus be\n    applied even by programmers unfamiliar with the underlying\n    theories.  Other examples of lightweight formal methods include\n    hardware and software model checkers, contract checkers, and\n    run-time monitoring techniques.\n\n    This also completes a full circle with the beginning of the book:\n    the language whose properties we study in this part, the _simply\n    typed lambda-calculus_, is essentially a simplified model of the\n    core of Coq itself!\n(* SOONER: The key technical challenges in this part involve\n    understanding the fundamental mechanisms of _variable binding_ and\n    _substitution_. *)\n(* SOONER: Say more about this! *)\n*)",
    "dst": "(** 我们的最后一个主题为_'类型系统'_，它覆盖了课程最后的三分之一。\n    它是一组强大的工具，用于构建给定语言中_'所有'_程序的属性。\n(* SOONER: Write some more about what type systems are and how they\n   work. *)\n    类型系统是最久经考验、最流行也是最成功的一类形式化验证技术的例子，\n    它被称作_'轻量级形式化方法'_（lightweight formal methods）。\n    它们是低调而强大的论证技术，以至于自动检查器可以内建在在编译器、\n    连接器或程序分析器中，而程序员无需熟悉底层理论便可应用。\n    其它轻量级形式化方法的例子包括硬件和软件的模型检查器、契约检查器，\n    以及运行时属性监视技术，它用来检测一个系统中某些组件的行为是否遵循规范）。\n    该主题使得本课程终归圆满：我们在这一部分研究的语言，即_'简单类型化 λ-演算'_，\n    它本质上就是 Coq 核心自身的一个简化模型！\n(* SOONER: The key technical challenges in this part involve\n    understanding the fundamental mechanisms of _variable binding_ and\n    _substitution_. *)\n(* SOONER: Say more about this! *)\n*)",
    "votes": 0
  },
  {
    "id": 18,
    "src": "(* ###################################################################### *)",
    "dst": "(* ###################################################################### *)",
    "votes": 0
  },
  {
    "id": 19,
    "src": "(** ** Further Reading *)",
    "dst": "(** ** 扩展阅读 *)",
    "votes": 0
  },
  {
    "id": 20,
    "src": "(** This text is intended to be self contained, but readers looking\n    for a deeper treatment of particular topics will find some\n    suggestions for further reading in the \\CHAP{Postscript}\n    chapter. *)",
    "dst": "(** 此书旨在自成一体，不过想要对特定主题进行深入研究的读者，可以在 \\CHAP{Postscript}\n    一章中找到建议的扩展阅读。 *)",
    "votes": 0
  },
  {
    "id": 21,
    "src": "(** * Practicalities *)",
    "dst": "(** * 实用指南 *)",
    "votes": 0
  },
  {
    "id": 22,
    "src": "(** ** Chapter Dependencies *)",
    "dst": "(** ** 章节依赖 *)",
    "votes": 0
  },
  {
    "id": 23,
    "src": "(** A diagram of the dependencies between chapters and some \n    paths through the material can be found in the file #<a href=\"deps.html\"><span class=\"inlineref\">#[deps.html]#</span></a>#. *)",
    "dst": "(** 章节之间的依赖关系以及一些建议的路径图可以在文件\n    #<a href=\"deps.html\"><span class=\"inlineref\">#[deps.html]#</span></a># 中找到。 *)",
    "votes": 0
  },
  {
    "id": 24,
    "src": "(** ** System Requirements *)",
    "dst": "(** ** 系统需求 *)",
    "votes": 0
  },
  {
    "id": 25,
    "src": "(** Coq runs on Windows, Linux, and OS X.  You will need:\n\n       - A current installation of Coq, available from the Coq home\n         page.  Everything should work with version 8.4 (or 8.5).\n\n       - An IDE for interacting with Coq.  Currently, there are two\n         choices:\n\n           - Proof General is an Emacs-based IDE.  It tends to be\n             preferred by users who are already comfortable with\n             Emacs.  It requires a separate installation (google\n             \"Proof General\").\n\n             Adventurous users of Coq within Emacs may also want to\n             check out extensions such as [company-coq] and\n             [control-lock].\n\n           - CoqIDE is a simpler stand-alone IDE.  It is distributed\n             with Coq, so it should be available once you have Coq\n             installed.  It can also be compiled from scratch, but on\n             some platforms this may involve installing additional\n             packages for GUI libraries and such. *)",
    "dst": "(** Coq 可以在 Windows、Linux 和 OS X 上运行。你需要：\n       - 一个最近的 Coq 安装，可以从 Coq 主页获得。所有内容都能在 8.4（或 8.5）上运行。\n       - 一个能跟 Coq 交互的 IDE。目前为止有两个选项：\n           - Proof General 是一个基于 Emacs 的 IDE，Emacs 用户应该更喜欢这个。\n             它需要另外安装（Google 搜索「Proof General」）。\n             爱作死的 Emacs 党也可以试试 [company-coq] 和 [control-lock]\n             之类的扩展。\n           - CoqIDE 是一个更简单的独立 IDE。它随 Coq 一起发布，所以若你已经安装了\n             Coq，它应该「刚好能用」。它也可以通过对应的依赖从头编译安装，\n             不过在某些平台上还需要额外安装 GUI 库之类的东西。 *)\n(** LATER: Some other things we might choose to mention at some point:\n      - control-lock.el\n      - company-coq mode\n*)",
    "votes": 0
  },
  {
    "id": 26,
    "src": "(** Coq runs on Windows, Linux, and OS X.  You will need:\n\n       - A current installation of Coq, available from the Coq home\n         page.  Everything should work with version 8.4 (or 8.5).\n\n       - An IDE for interacting with Coq.  Currently, there are two\n         choices:\n\n           - Proof General is an Emacs-based IDE.  It tends to be\n             preferred by users who are already comfortable with\n             Emacs.  It requires a separate installation (google\n             \"Proof General\").\n\n             Adventurous users of Coq within Emacs may also want to\n             check out extensions such as [company-coq] and\n             [control-lock].\n\n           - CoqIDE is a simpler stand-alone IDE.  It is distributed\n             with Coq, so it should be available once you have Coq\n             installed.  It can also be compiled from scratch, but on\n             some platforms this may involve installing additional\n             packages for GUI libraries and such. *)",
    "dst": "(** Coq 可以在 Windows、Linux 和 OS X 上运行。你需要：\n- 一个最近的 Coq 安装，可以从 Coq 主页获得。所有内容都能在 8.4（或 8.5）上运行。\n- 一个能跟 Coq 交互的 IDE。目前为止有两个选项：\n- Proof General 是一个基于 Emacs 的 IDE，Emacs 用户应该更喜欢这个。\n它需要另外安装（Google 搜索「Proof General」）。\n爱作死的 Emacs 党也可以试试 [company-coq] 和 [control-lock]\n之类的扩展。\n- CoqIDE 是一个更简单的独立 IDE。它随 Coq 一起发布，所以若你已经安装了\nCoq，它应该「刚好能用」。它也可以通过对应的依赖从头编译安装，\n不过在某些平台上还需要额外安装 GUI 库之类的东西。 *)",
    "votes": 0
  },
  {
    "id": 27,
    "src": "(** ** Exercises *)",
    "dst": "(** ** 练习 *)",
    "votes": 0
  },
  {
    "id": 28,
    "src": "(** Each chapter includes numerous exercises.  Each is marked with a\n    \"star rating,\" which can be interpreted as follows:\n\n       - One star: easy exercises that underscore points in the text\n         and that, for most readers, should take only a minute or two.\n         Get in the habit of working these as you reach them.\n\n       - Two stars: straightforward exercises (five or ten minutes).\n\n       - Three stars: exercises requiring a bit of thought (ten\n         minutes to half an hour).\n\n       - Four and five stars: more difficult exercises (half an hour\n         and up).\n\n    Also, some exercises are marked \"advanced,\" and some are marked\n    \"optional.\"  Doing just the non-optional, non-advanced exercises\n    should provide good coverage of the core material.  Optional\n    exercises provide a bit of extra practice with key concepts and\n    introduce secondary themes that may be of interest to some\n    readers.  Advanced exercises are for readers who want an extra\n    challenge and a deeper cut at the material.\n\n   #<font color=\"red\"># _Please do not post solutions to the exercises in a public places_: #</font>#\n    Software Foundations is widely used both for self-study and for\n    university courses.  Having solutions easily available makes it\n    much less useful for courses, which typically have graded homework\n    assignments.  We especially request that readers not post\n    solutions to the exercises anyplace where they can be found by\n    search engines.\n*)",
    "dst": "(** 每一章都包含大量的习题。每一个习题都有一个「星级」标记，其意义是：\n       - 一星：很简单的，强调课程重点的习题。对于大部分读者，一两分钟应该足够了。\n         养成看到一个就做一个的习惯。\n       - 二星：直截了当的习题（5 或 10 分钟）。\n       - 三星：需要一点思考的习题（10 分钟到半小时）。\n       - 四或五星：更困难的习题（半小时以上）。\n    此外，有些习题被标注为「高阶」，有些习题被标注为「可选」。\n    只做非高阶和非可选的习题已经能达到对核心概念的不错的覆盖率。\n    可选习题会提供一点对关键概念的额外练习，以及一些可能会引起读者兴趣的附加主题。\n    高阶练习留给想要更多挑战（以及对概念更深的理解）的读者。\n    #<font color=\"red\"># _'请勿将习题解答发布在公共位置'_：Software Foundation #</font>#\n    已被广泛地用作自学教程以及大学课程。如果习题答案很容易获得，\n    那么这本书的效用将大打折扣，对于会为作业打评分的大学课程来说尤其如此。\n    作者特别请求读者，切勿将习题答案放在任何能够被搜索引擎找到的地方。*)",
    "votes": 0
  },
  {
    "id": 29,
    "src": "(** ** Downloading the Coq Files *)",
    "dst": "(** ** 下载 Coq 文件 *)",
    "votes": 0
  },
  {
    "id": 30,
    "src": "(** A tar file containing the full sources for the \"release version\"\n    of this book (as a collection of Coq scripts and HTML files) is\n    available here:\n<<\n        {http://www.cis.upenn.edu/~bcpierce/sf}\n>>\n    (If you are using the book as part of a class, your professor may\n    give you access to a locally modified version of the files, which\n    you should use instead of the release version.) *)",
    "dst": "(** 一个包含本书「发布版」的所有源代码的 tar 包\n    （包含一组 Coq 脚本和 HTML 文件）可在此获得：\n<<\n        {http://www.cis.upenn.edu/~bcpierce/sf}\n>>\n    本书的中文版可在此获得：\n<<\n        {https://github.com/MarisaKirisame/SFCT}\n>>\n    （如果你是在一门课程中使用本书的，那么你的教授可能让你访问本地的修改版，\n    此时你应当使用它们而非发布版。）*)",
    "votes": 0
  },
  {
    "id": 31,
    "src": "(** * Note for Instructors *)",
    "dst": "(** * 对授课员的标准 *)",
    "votes": 0
  },
  {
    "id": 32,
    "src": "(** If you plan to use these materials in your own course, you will\n    undoubtedly find things you'd like to change, improve, or add.\n    Your contributions are welcome!\n\n    In order to keep the legalities simple and to have a single\n    point of responsibility in case the need should ever arise to\n    adjust the license terms, sublicense, etc., we ask all\n    contributors (i.e., everyone with access to the developers'\n    repository) to assign copyright in their contributions to the\n    appropriate \"author of record,\" as follows:\n\n      - I hereby assign copyright in my past and future contributions\n        to the Software Foundations project to the Author of Record of\n        each volume or component, to be licensed under the same terms\n        as the rest of Software Foundations.  I understand that, at\n        present, the Authors of Record are as follows: For Volumes 1\n        and 2, known until 2016 as \"Software Foundations\" and from\n        2016 as (respectively) \"Logical Foundations\" and \"Programming\n        Foundations,\" the Author of Record is Benjamin Pierce.  For\n        Volume 3, \"Verified Functional Algorithms\", the Author of\n        Record is Andrew W. Appel. For components outside of\n        designated Volumes (e.g., typesetting and grading tools and\n        other software infrastructure), the Author of Record is\n        Benjamin Pierce.\n\n    To get started, please send an email to Benjamin Pierce, describing\n    yourself and how you plan to use the materials and including \n       (1) the above copyright transfer text and \n       (2) the result of doing \"htpasswd -s -n NAME\"\n    where NAME is your preferred user name. \n\n    We'll set you up with access to the subversion repository and \n    developers' mailing lists.  In the repository you'll find a \n    file [INSTRUCTORS] with further instructions. *)",
    "dst": "(** 如果你有意用这些课件授课，那肯定会发现希望改进或增加的东西。我们欢迎你的贡献！\n    为保证法律上的简单性和单一责任制，任何情况下都不应出现许可条款的的调整，\n    授权的转移等等，我们要求所有贡献者（即，任何可访问开发者仓库的人）根据\n    「作者记录」为他们的贡献赋予版权信息如下：\n      - I hereby assign copyright in my past and future contributions\n        to the Software Foundations project to the Author of Record of\n        each volume or component, to be licensed under the same terms\n        as the rest of Software Foundations.  I understand that, at\n        present, the Authors of Record are as follows: For Volumes 1\n        and 2, known until 2016 as \"Software Foundations\" and from\n        2016 as (respectively) \"Logical Foundations\" and \"Programming\n        Foundations,\" the Author of Record is Benjamin Pierce.  For\n        Volume 3, \"Verified Functional Algorithms\", the Author of\n        Record is Andrew W. Appel. For components outside of\n        designated Volumes (e.g., typesetting and grading tools and\n        other software infrastructure), the Author of Record is\n        Benjamin Pierce.\n    请您向 Benjamin Pierce 发一封电子邮件，描述一下你自己，\n    以及你打算如何使用这些课件，内容包括\n       (1) 以上版权转让协议，以及\n       (2) 执行 \"htpasswd -s -n NAME\" 后产生的结果，\n    其中 NAME 是你喜欢的用户名。\n    我们为你设置 subversion 仓库和开发者邮件列表的访问权限。\n    在仓库中你会找到一个包含更多指引的 [INSTRUCTORS] 文件。*)",
    "votes": 0
  },
  {
    "id": 33,
    "src": "(** * Translations *)",
    "dst": "(** * 翻译版 *)",
    "votes": 0
  },
  {
    "id": 34,
    "src": "(** Thanks to the efforts of a team of volunteer translators,\n    _Software Foundations_ can be enjoyed in Japanese at\n    #<a href=\"http://proofcafe.org/sf\">#[http://proofcafe.org/sf]#</a>#.  A Chinese translation is underway. *)",
    "dst": "(** 感谢翻译志愿者团队的努力，_'Software Foundations'_\n    有了可以阅读的日文版\n    #<a href=\"http://proofcafe.org/sf\">#[http://proofcafe.org/sf]#</a>#。\n    中文版还在填坑= =||\n*)",
    "votes": 0
  },
  {
    "id": 35,
    "src": "(** * Welcome *)",
    "dst": "(** * 简介 *)",
    "votes": 0
  },
  {
    "id": 36,
    "src": "(** * Welcome *)",
    "dst": "(** * 导论 *)",
    "votes": 0
  },
  {
    "id": 37,
    "src": "(** * Overview *)",
    "dst": "(** * 导论 *)",
    "votes": 0
  },
  {
    "id": 38,
    "src": "(** * Welcome *)",
    "dst": "(** * 简介 *)",
    "votes": 0
  },
  {
    "id": 39,
    "src": "(** * Basics: Functional Programming in Coq *)",
    "dst": "(** * 基础知识: Coq 中的函数式编程 *)",
    "votes": 0
  },
  {
    "id": 40,
    "src": "(* REMINDER:\n\n          #####################################################\n          ###  PLEASE DO NOT DISTRIBUTE SOLUTIONS PUBLICLY  ###\n          #####################################################\n\n   (See the [Preface] for why.)\n\n*)",
    "dst": "(* REMINDER:\n          ##############################\n          ###  请勿公开发布习题解答  ###\n          ##############################\n   （原因见 [Preface]。）\n*)",
    "votes": 0
  },
  {
    "id": 41,
    "src": "(** * Introduction *)",
    "dst": "(** * 简介 *)",
    "votes": 0
  },
  {
    "id": 42,
    "src": "(** The functional programming style is founded on simple, everyday\n    mathematical intuition: If a procedure or method has no side\n    effects, then (ignoring efficiency) all we need to understand\n    about it is how it maps inputs to outputs -- that is, we can think\n    of it as just a concrete method for computing a mathematical\n    function.  This is one sense of the word \"functional\" in\n    \"functional programming.\"  The direct connection between programs\n    and simple mathematical objects supports both formal correctness\n    proofs and sound informal reasoning about program behavior.\n\n    The other sense in which functional programming is \"functional\" is\n    that it emphasizes the use of functions (or methods) as\n    _first-class_ values -- i.e., values that can be passed as\n    arguments to other functions, returned as results, included in\n    data structures, etc.  The recognition that functions can be\n    treated as data gives rise to a host of useful and powerful\n    programming idioms.\n\n    Other common features of functional languages include _algebraic\n    data types_ and _pattern matching_, which make it easy to\n    construct and manipulate rich data structures, and sophisticated\n    _polymorphic type systems_ supporting abstraction and code reuse.\n    Coq offers all of these features.\n\n    The first half of this chapter introduces the most essential\n    elements of Coq's functional programming language, called\n    _Gallina_.  The second half introduces some basic _tactics_ that\n    can be used to prove properties of Coq programs. *)",
    "dst": "(** 函数式编程风格让编程更接近简单的、日常的数学：若一个过程或方法没有副作用，\n    那么在忽略效率的情况下，我们需要理解的一切便只剩下如何将输入对应到输出了\n    —— 或者说，我们只需将它视作一个计算数学函数的具体方法即可。这也是\n    「函数式编程」中「函数式」一词的含义之一。程序与简单数学对象之间的这种联系，\n    同时支撑了对程序行为进行形式化证明的正确性以及非形式化论证的健全性。\n    函数式编程中「函数式」一词的另一个含义是它强调把函数（或方法）作为_第一等_\n    的值 —— 换言之，这类值可以作为参数传递给其它函数，可以作为结果返回，\n    也可以包含在���据结构中等等。这种将函数视作数据来接受的方式，\n    使很多有用而强大的惯用法成为可能。\n    其它一些常见的函数式语言特性包括_代数数据类型（Algebraic Data Type）_，\n    能让构造和处理丰富数据结构更加简单的_模式匹配（Pattern Matching）_，\n    以及用来支持抽象和代码复用的复杂的_多态类型系统（Polymorphic Type System）_。\n    Coq 提供所有的这些特性。\n    本章的前半部分介绍了 Coq 的函数式编程语言 _Gallina_ 中最基本的元素，\n    后半部分则介绍了可被用于证明 Coq 程序的简单属性的一些基本_策略（Tactic）_。 *)",
    "votes": 0
  },
  {
    "id": 43,
    "src": "(** * Enumerated Types *)",
    "dst": "(** * 可枚举类型 *)",
    "votes": 0
  },
  {
    "id": 44,
    "src": "(** TERSE: In Coq, we can build practically everything from first\n    principles... *)",
    "dst": "(** TERSE: 在 Coq 中，我们其实可以从基本原则构建出一切... *)",
    "votes": 0
  },
  {
    "id": 45,
    "src": "(** FULL: One notable aspect of Coq is that its set of built-in\n    features is _extremely_ small.  For example, instead of providing\n    the usual palette of atomic data types (booleans, integers,\n    strings, etc.), Coq offers a powerful mechanism for defining new\n    data types from scratch, with all these familiar types as\n    instances.\n\n    Naturally, the Coq distribution comes preloaded with an extensive\n    standard library providing definitions of booleans, numbers, and\n    many common data structures like lists and hash tables.  But there\n    is nothing magic or primitive about these library definitions.  To\n    illustrate this, we will explicitly recapitulate all the\n    definitions we need in this course, rather than just getting them\n    implicitly from the library. *)",
    "dst": "(** FULL: Coq 一个不寻常的地方就是它内置了_极小_的特性集合。比如，Coq 并未提供\n    通常的原子数据类型（如布尔值、整数、字符串等等），而是提供了一种极为强大的，\n    可从头定义新数据类型的机制 —— 强大到所有常见的类型都是它定义产生出的实例。\n    当然，Coq 发行版同时也提供了一个内容丰富的标准库，其中定义了布尔值、数值，\n    以及如列表、散列表等很多通用的数据结构。不过这些库中的定义并没有\n    任何神秘的或原语中独有的地方：它们都是普普通通的用户代码。为了说明这一点，\n    我们并未隐式地使用库中的数据类型，而是在整个教程中显式地重新定义了它们。*)",
    "votes": 0
  },
  {
    "id": 46,
    "src": "(** ** Days of the Week *)",
    "dst": "(** ** 一周里的每一天 *)",
    "votes": 0
  },
  {
    "id": 47,
    "src": "(** TERSE: A datatype definition: *)",
    "dst": "(** TERSE: 一个数据类型： *)",
    "votes": 0
  },
  {
    "id": 48,
    "src": "(** FULL: To see how this definition mechanism works, let's start with\n    a very simple example.  The following declaration tells Coq that\n    we are defining a new set of data values -- a _type_. *)",
    "dst": "(** FULL: 让我们从一个非常简单的例子开始，看看这种定义机制是如何工作的。\n    下面的声明告诉 Coq 我们在定义一个新的数据值的集合，即一个_类型_。 *)",
    "votes": 0
  },
  {
    "id": 49,
    "src": "(** FULL: One thing to note is that the argument and return types of\n    this function are explicitly declared.  Like most functional\n    programming languages, Coq can often figure out these types for\n    itself when they are not given explicitly -- i.e., it can do _type\n    inference_ -- but we'll generally include them to make reading\n    easier. *)",
    "dst": "(** FULL: 该类型名为 [day], 其成员包括 [monday]、[tuesday] 等等。第二行及之后的定义可读作\n    「[monday] 是一个 [day]」，「[tuesday] 是一个 [day]」，依次类推。\n    在定义了 [day] 之后, 我们就可以写一些操作 day 的函数了。 *)",
    "votes": 0
  },
  {
    "id": 50,
    "src": "(** FULL: The type is called [day], and its members are [monday],\n    [tuesday], etc.  The second and following lines of the definition\n    can be read \"[monday] is a [day], [tuesday] is a [day], etc.\"\n\n    Having defined [day], we can write functions that operate on\n    days. *)",
    "dst": "(** FULL: 该类型名为 [day], 其成员包括 [monday]、[tuesday] 等等。第二行及之后的定义可读作\n    「[monday] 是一个 [day]」，「[tuesday] 是一个 [day]」，依次类推。\n    在定义了 [day] 之后, 我们就可以写一些操作 day 的函数了。 *)",
    "votes": 0
  },
  {
    "id": 51,
    "src": "(** TERSE: A function on days: *)",
    "dst": "(** TERSE: 一个在星期上定义的函数 *)",
    "votes": 0
  },
  {
    "id": 52,
    "src": "(** FULL: One thing to note is that the argument and return types of\n    this function are explicitly declared.  Like most functional\n    programming languages, Coq can often figure out these types for\n    itself when they are not given explicitly -- i.e., it can do _type\n    inference_ -- but we'll generally include them to make reading\n    easier. *)",
    "dst": "(** FULL: 注意，这里显式声明了函数的参数和返回类型。像大多数函数式编程语言一样，\n    如果没有显式指定类型，Coq 自己通常会通过_类型推断_得出。\n    不过我们会在这里声明它们，以使其更加易读。 *)",
    "votes": 0
  },
  {
    "id": 53,
    "src": "(** TERSE: Simplification: *)",
    "dst": "(** TERSE: 化简： *)",
    "votes": 0
  },
  {
    "id": 54,
    "src": "(** FULL: Having defined a function, we should check that it works on\n    some examples.  There are actually three different ways to do this\n    in Coq.  First, we can use the command [Compute] to evaluate a\n    compound expression involving [next_weekday]. *)",
    "dst": "(** FULL: 定义了函数之后，我们用一些例子来检验它。实际上，在 Coq 中可以用三种\n    不同的方式进行检验。\n    第一，我们可以用命令 [Compute] 来计算一个包含 [next_weekday] 的合成表达式。 *)",
    "votes": 0
  },
  {
    "id": 55,
    "src": "(* ==> monday : day *)",
    "dst": "(* ==> monday : day *)",
    "votes": 0
  },
  {
    "id": 56,
    "src": "(* ==> tuesday : day *)",
    "dst": "(* ==> tuesday : day *)",
    "votes": 0
  },
  {
    "id": 57,
    "src": "(** FULL: (We show Coq's responses in comments, but, if you have a\n    computer handy, this would be an excellent moment to fire up the\n    Coq interpreter under your favorite IDE -- either CoqIde or Proof\n    General -- and try this for yourself.  Load this file, [Basics.v],\n    from the book's Coq sources, find the above example, submit it to\n    Coq, and observe the result.)\n(* LATER: Some readers may need more detailed instructions.  Should\n   they go here?  Probably not.  In the preface?  In an appendix? *)\n\n    Second, we can record what we _expect_ the result to be in the\n    form of a Coq example: *)",
    "dst": "(** FULL: （我们在注释中显示了 Coq 返回的结果。如果你手头就有电脑，不妨自己用 Coq\n    解释器试一试：选一个你喜欢的 IDE（CoqIde 或 Proof General 都可以），然后\n    从本书附带的 Coq 源码中载入 [Basics.v] 文件，找到上述例子，提交到 Coq，\n    然后查看结果。）\n(* LATER: Some readers may need more detailed instructions.  Should\n   they go here?  Probably not.  In the preface?  In an appendix? *)\n    第二，我们可以用 Coq 例子的形式来记录期望的结果： *)",
    "votes": 0
  },
  {
    "id": 58,
    "src": "(** TERSE: A \"unit test\" for our function -- i.e., a mathematical\n    claim about its behavior: *)",
    "dst": "(** TERSE: 一个我们函数的「单元测试」，即一个关于其行为的数学断言： *)",
    "votes": 0
  },
  {
    "id": 59,
    "src": "(** FULL: This declaration does two things: it makes an\n    assertion (that the second weekday after [saturday] is [tuesday]),\n    and it gives the assertion a name that can be used to refer to it\n    later.  Having made the assertion, we can also ask Coq to verify\n    it, like this: *)",
    "dst": "(** FULL: 该声明做了两件事：一是它作出了一个断言（即 [saturday] 之后的第二个工作日是\n    [tuesday]）；二是它为该断言起名以便之后引用它。定义好断言后，我们还能要求\n    Coq 来验证它，就像这样： *)",
    "votes": 0
  },
  {
    "id": 60,
    "src": "(** TERSE: A proof script giving evidence for the claim: *)",
    "dst": "(** TERSE: 一个对此断言给出证据的证明脚本： *)",
    "votes": 0
  },
  {
    "id": 61,
    "src": "(** FULL: The details are not important for now (we'll come back to\n    them in a bit), but essentially this can be read as \"The assertion\n    we've just made can be proved by observing that both sides of the\n    equality evaluate to the same thing, after some simplification.\"\n\n    Third, we can ask Coq to _extract_, from our [Definition], a\n    program in some other, more conventional, programming\n    language (OCaml, Scheme, or Haskell) with a high-performance\n    compiler.  This facility is very interesting, since it gives us a\n    way to go from proved-correct algorithms written in Gallina to\n    efficient machine code.  (Of course, we are trusting the\n    correctness of the OCaml/Haskell/Scheme compiler, and of Coq's\n    extraction facility itself, but this is still a big step forward\n    from the way most software is developed today.) Indeed, this is\n    one of the main uses for which Coq was developed.  We'll come back\n    to this topic in later chapters. *)",
    "dst": "(** FULL: 一���细节问题我们暂且不谈（之后还会讲到），不过这段代码基本上可以读作\n    「经过一番化简后，若等式两边的求值结果相同，该断言即可得证。」\n    第三，我们可以让 Coq 从 [Definition] 中_提取_出一个用更常规的编程语言\n    （如 OCaml、Scheme、Haskell）编写的程序，它们有着高性能的编译器。\n    这种能力非常有用，我们可以通过它将 Gallina 编写的，\n    _证明正确_的算法转译成高效的机器码。（当然，我们得相信 OCaml/Haskell/Scheme\n    的编译器，以及 Coq 提取工具自身的正确性，不过这仍然是从当今开发的大部分软件\n    迈出的一大步。）实际上，这就是 Coq 被开发出来后最主要的使用方式之一。\n    在之后的章节中我们会回到这一主题上来。 *)",
    "votes": 0
  },
  {
    "id": 62,
    "src": "(** ** Homework Submission Guidelines *)",
    "dst": "(** ** 家庭作业提交指南 *)",
    "votes": 0
  },
  {
    "id": 63,
    "src": "(** If you are using Software Foundations in a course, your instructor\n    may use automatic scripts to help grade your homework assignments.\n    In order for these scripts to work correctly (so that you get full\n    credit for your work!), please be careful to follow these rules:\n      - The grading scripts work by extracting marked regions of the\n        .v files that you submit.  It is therefore important that you\n        do not alter the \"markup\" that delimits exercises: the\n        Exercise header, the name of the exercise, the \"empty square\n        bracket\" marker at the end, etc.  Please leave this markup\n        exactly as you find it.\n      - Do not delete exercises.  If you skip an exercise (e.g.,\n        because it is marked Optional, or because you can't solve it),\n        it is OK to leave a partial proof in your .v file, but in this\n        case please make sure it ends with [Admitted] (not, for\n        example [Abort]). *)",
    "dst": "(** 若你在课堂中使用 Software Foundations，你的教师可能会用自动化脚本来为你的作业评分。\n    为了让这些脚本能正常工作（这样你才能拿到全部学分！），请认真遵循以下规则：\n      - 评分脚本通过提取你提交的 .v 文件中标记的区域来工作。因此不改变练习的\n        「分隔标记」十分重要：练习的标题、名称、末尾的「空方括号」标记等等。\n        请保持这些标记不变。\n      - 不要删除练习。如果你要跳过一个练习（例如它标记为可选或你如法解决它），\n        可以在 .v 文件中留下部分的证明，这没关系，不过此时请确认它以 [Admitted]\n        结尾（而不是 [Abort] 之类的东西）。 *)",
    "votes": 0
  },
  {
    "id": 64,
    "src": "(** ** Booleans *)",
    "dst": "(** ** 布尔值 *)",
    "votes": 0
  },
  {
    "id": 65,
    "src": "(** FULL: In a similar way, we can define the standard type [bool] of\n    booleans, with members [true] and [false]. *)",
    "dst": "(** FULL: 用类似的方式，我们可以为布尔值定义标准类型 [bool]，它包括\n    [true] 和 [false] 两个成员。 *)",
    "votes": 0
  },
  {
    "id": 66,
    "src": "(** TERSE: Another familiar datatype: *)",
    "dst": "(** TERSE: 另一个熟悉的数据类型： *)",
    "votes": 0
  },
  {
    "id": 67,
    "src": "(** TERSE: Booleans are also provided in Coq's standard library, but\n    in this course we'll define everything from scratch, just to see\n    how it's done. *)",
    "dst": "(** TERSE: Coq 的标准库中提供了布尔类型，不过在本课程中我们会从头定义一切，\n    只是为了看看它如何做到。 *)",
    "votes": 0
  },
  {
    "id": 68,
    "src": "(** FULL: Although we are rolling our own booleans here for the sake\n    of building up everything from scratch, Coq does, of course,\n    provide a default implementation of the booleans, together with a\n    multitude of useful functions and lemmas.  (Take a look at\n    [Coq.Init.Datatypes] in the Coq library documentation if you're\n    interested.)  Whenever possible, we'll name our own definitions\n    and theorems so that they exactly coincide with the ones in the\n    standard library.\n\n    Functions over booleans can be defined in the same way as\n    above: *)",
    "dst": "(** FULL: 当然，Coq 的标准库中提供了布尔类型的默认实现以及大量有用的函数和定理。\n    （有兴趣的话可参见 Coq 库文档中的 [Coq.Init.Datatypes]。）\n    不过我们为了从头开始，定义了自己的布尔类型。\n    我们会尽量将自己的定义和定理的名字与标准库中的保持完全一致。\n    布尔值的函数可以用同样的方式来定义： *)",
    "votes": 0
  },
  {
    "id": 69,
    "src": "(** FULL: The last two of these illustrate Coq's syntax for\n    multi-argument function definitions.  The corresponding\n    multi-argument application syntax is illustrated by the following\n    \"unit tests,\" which constitute a complete specification -- a truth\n    table -- for the [orb] function: *)",
    "dst": "(** FULL: 其中后面两个演示了多参数函数定义的语法。\n    以下四个「单元测试」则演示了多参数应用的语法，\n    它们构成了 [orb] 函数的完整规范，即真值表： *)",
    "votes": 0
  },
  {
    "id": 70,
    "src": "(** TERSE: Note the syntax for defining multi-argument\n    functions ([andb] and [orb]).  *)",
    "dst": "(** TERSE: 请注意定义多参函数的语法（[andb] 和 [orb]）。  *)",
    "votes": 0
  },
  {
    "id": 71,
    "src": "(** FULL: We can also introduce some familiar syntax for the boolean\n    operations we have just defined. The [Infix] command defines a new\n    symbolic notation for an existing definition. *)",
    "dst": "(** FULL: 我们也可以为刚定义的布尔运算引入更熟悉的语法。\n    [Infix] 命令能为既有的定义来定义出新的中缀记法。 *)",
    "votes": 0
  },
  {
    "id": 72,
    "src": "(** FULL: _A note on notation_: In [.v] files, we use square brackets\n    to delimit fragments of Coq code within comments; this convention,\n    also used by the [coqdoc] documentation tool, keeps them visually\n    separate from the surrounding text.  In the html version of the\n    files, these pieces of text appear in a [different font].\n\n    The command [Admitted] can be used as a placeholder for an\n    incomplete proof.  We'll use it in exercises, to indicate the\n    parts that we're leaving for you -- i.e., your job is to replace\n    [Admitted]s with real proofs. *)",
    "dst": "(** FULL: _关于记法的说明_ ：在 [.v] 文件中，我们用方括号来界定注释中的 Coq 代码片段；\n    这种约定也在 [coqdoc] 文档工具中使用，它能让代码与周围的文本从视觉上区分开来。\n    在 HTML 版的文件中，这部分文本会以 [不同的字体] 显示。\n    特殊的短语 [Admitted] 和 [admit] 被用作不完整定义或证明的占位符，\n    我们会���后续的例子中用它。通常，你的练习作业就是将 [Admitted] 和 [admit]\n    替换为具体的定义和证明。 *)",
    "votes": 0
  },
  {
    "id": 73,
    "src": "(** Remove \"[Admitted.]\" and complete the definition of the following\n    function; then make sure that the [Example] assertions below can\n    each be verified by Coq.  (Remove \"[Admitted.]\" and fill in each\n    proof, following the model of the [orb] tests above.) The function\n    should return [true] if either or both of its inputs are\n    [false]. *)",
    "dst": "(** 移除 [admit] 并补完以下函数的定义，然后确保下列每一个 [Example]\n    中的断言都能被 Coq 验证通过。（仿照前面 [orb] 测试的模式，移除每一个\n    [Admitted.] 并补充证明。）此函数应在两个输入之一或二者均为 [false]\n    时返回 [true] 。 *)",
    "votes": 0
  },
  {
    "id": 74,
    "src": "(* ADMITDEF *)",
    "dst": "(* ADMITDEF *)",
    "votes": 0
  },
  {
    "id": 75,
    "src": "(* /ADMITDEF *)",
    "dst": "(* /ADMITDEF *)",
    "votes": 0
  },
  {
    "id": 76,
    "src": "(** TERSE: All but a few of the exercises are omitted from the \"terse\"\n    version of the notes that we'll be looking at in lectures.  The\n    full version that is distributed as your homework assignment has\n    many exercises, including some optional ones for extra practice,\n    plus a lot of additional explanatory text. *)",
    "dst": "(** TERSE: 除了几个练习外，其它所有练习都从我们在课上看到的笔记的「简述」版中省去了。\n    分发给你作为作业的完整版有更多练习，包括一些可选练习作为扩展实践，\n    加上一些附加的解释性文本。 *)",
    "votes": 0
  },
  {
    "id": 77,
    "src": "(** Do the same for the [andb3] function below. This function should\n    return [true] when all of its inputs are [true], and [false]\n    otherwise. *)",
    "dst": "(** 与此前相同，完成下面的 [andb3] 函数。\n    此函数应在其所有输入均为 [true] 时返回 [true]，否则返回 [false]。 *)",
    "votes": 0
  },
  {
    "id": 78,
    "src": "(** ** Function Types *)",
    "dst": "(** ** 函数类型 *)",
    "votes": 0
  },
  {
    "id": 79,
    "src": "(** Every expression in Coq has a type, describing what sort of\n    thing it computes. The [Check] command asks Coq to print the type\n    of an expression. *)",
    "dst": "(** Coq 中的每个表达式都有类型，它描述了该表达式所计算的东西的类别。\n    [Check] 命令让 Coq 显示一个表达式的类型。 *)",
    "votes": 0
  },
  {
    "id": 80,
    "src": "(** Functions like [negb] itself are also data values, just like\n    [true] and [false].  Their types are called _function types_, and\n    they are written with arrows. *)",
    "dst": "(** 像 [negb] 这样的函数其本身也是数据值，就像 [true] 和 [false] 一样。\n    它们的类型被称为 _函数类型_ ，用带箭头的类型表示。 *)",
    "votes": 0
  },
  {
    "id": 81,
    "src": "(** FULL: The type of [negb], written [bool -> bool] and pronounced\n    \"[bool] arrow [bool],\" can be read, \"Given an input of type\n    [bool], this function produces an output of type [bool].\"\n    Similarly, the type of [andb], written [bool -> bool -> bool], can\n    be read, \"Given two inputs, both of type [bool], this function\n    produces an output of type [bool].\" *)",
    "dst": "(** FULL: [negb] 的类型写作 [bool -> bool]，读做「[bool] 箭头 [bool]」，\n    可以理解为「给定一个 [bool] 类型的输入，该函数产生一个 [bool] 类型的输出。\n    同样，[andb] 的类型写作 [bool -> bool -> bool]，可以理解为\n    「给定两个输入，都是 [bool] 类型，该函数产生一个 [bool] 类型的输出。」 *)",
    "votes": 0
  },
  {
    "id": 82,
    "src": "(** ** Modules *)",
    "dst": "(** ** 模块 *)",
    "votes": 0
  },
  {
    "id": 83,
    "src": "(** FULL: Coq provides a _module system_, to aid in organizing large\n    developments.  In this course we won't need most of its features,\n    but one is useful: If we enclose a collection of declarations\n    between [Module X] and [End X] markers, then, in the remainder of\n    the file after the [End], these definitions are referred to by\n    names like [X.foo] instead of just [foo].  We will use this\n    feature to introduce the definition of the type [nat] in an inner\n    module so that it does not interfere with the one from the\n    standard library (which we want to use in the rest because it\n    comes with a tiny bit of convenient special notation).  *)",
    "dst": "(** FULL: Coq 提供了_模块系统_来帮助组织大规模的开发。在本课程中，\n    我们不怎么会用到这方面的特性，不过其中有一样非常有用：\n    如果我们将一组定义放在 [Module X] 和 [End X] 标记之间，那么在文件中的\n    [End] 之后，我们就可以通过像 [X.foo] 这���的名字来引用，而不必直接用\n    [foo] 了。在这里，我们通过此特性在一个内部模块中引入了 [nat] 类型的定义，\n    这样就不会覆盖标准库中的同名定义了，毕竟它用了点儿特别的记法技巧。 *)",
    "votes": 0
  },
  {
    "id": 84,
    "src": "(** TERSE: This [Module] declaration puts the definition of\n    [nat] in its own namespace, so that it doesn't conflict with the\n    one in the standard library. *)",
    "dst": "(** TERSE: 此 [Module] 声明会将 [nat] 的定义放到它自己的命名空间中，\n    这样不会与标准库中的同名定义冲突。 *)",
    "votes": 0
  },
  {
    "id": 85,
    "src": "(** ** Numbers *)",
    "dst": "(** ** 数 *)",
    "votes": 0
  },
  {
    "id": 86,
    "src": "(** FULL: The types we have defined so far are examples of \"enumerated\n    types\": their definitions explicitly enumerate a finite set of\n    elements.  A more interesting way of defining a type is to give a\n    collection of _inductive rules_ describing its elements.  For\n    example, we can define (a unary representation of) the natural\n    numbers as follows: *)",
    "dst": "(** FULL: 至此，我们所定义的所有类型都是「可枚举类型」：\n    这些定义都是显式地列举出一个有限集合中的元素。定义类型的一种更有趣的方式是\n    通过一组「归纳性规则」来描述其元素。比如，我们可以对自然数作如下定义：*)",
    "votes": 0
  },
  {
    "id": 87,
    "src": "(** TERSE: A proper inductive type -- natural numbers (in unary\n    notation): *)",
    "dst": "(** TERSE: 一个优雅归纳类型 -- 自然数（一进制表示法）： *)",
    "votes": 0
  },
  {
    "id": 88,
    "src": "(** TERSE: [Inductive] declarations create inductively defined sets,\n    which consist of all possible combinations of the constructors. *)",
    "dst": "(** TERSE: [Inductive] 声明创建了归纳定义的集合，它由构造器所有可能的组合构成。 *)",
    "votes": 0
  },
  {
    "id": 89,
    "src": "(** FULL: The clauses of this definition can be read:\n      - [O] is a natural number (note that this is the letter \"[O],\"\n        not the numeral \"[0]\").\n      - [S] is a \"constructor\" that takes a natural number and yields\n        another one -- that is, if [n] is a natural number, then [S n]\n        is too. *)",
    "dst": "(** FULL: 此定义中的句子可以看做：\n      - [O] 是一个自然数（注意这里是字母「[O]」，不是数字「[0]」）。\n      - [S] 是一个构造器，取一个自然数并生成另一个 —— 也就是说，\n        如果 [n] 是一个自然数，那么 [S n] 也是。 *)",
    "votes": 0
  },
  {
    "id": 90,
    "src": "(** Let's look at this in a little more detail.\n\n    Every inductively defined set ([day], [nat], [bool], etc.) is\n    actually a set of _expressions_ built from _constructors_\n    like [O], [S], [true], [false], [monday], etc.  The definition of\n    [nat] says how expressions in the set [nat] can be built:\n\n    - [O] and [S] are constructors;\n    - the expression [O] belongs to the set [nat];\n    - if [n] is an expression belonging to the set [nat], then [S n]\n      is also an expression belonging to the set [nat]; and\n    - expressions formed in these two ways are the only ones belonging\n      to the set [nat]. *)",
    "dst": "(** 让我们来更仔细地看一下这个定义。\n    所有可归纳式定义的集合（[day]、[nat]、[bool] 等）实际上都是_表达式_的集合。\n    [nat] 的定义说明了集合 [nat] 中的表达式是如何构造的。\n    - 表达式 [O] 属于集合 [nat]；\n    - 如果 [n] 是属于集合 [nat] 的表达式，\n      那么 [S n] 也是属于集��� [nat] 的表达式；并且\n    - 只有这两种方式形成的表达式才属于集合 [nat]。 *)",
    "votes": 0
  },
  {
    "id": 91,
    "src": "(** FULL: The same rules apply for our definitions of [day] and\n    [bool]. (The annotations we used for their constructors are\n    analogous to the one for the [O] constructor, indicating that they\n    don't take any arguments.)\n\n    The above conditions are the precise force of the [Inductive]\n    declaration.  They imply that the expression [O], the expression\n    [S O], the expression [S (S O)], the expression [S (S (S O))], and\n    so on all belong to the set [nat], while other expressions built\n    from data constructors, like [true], [andb true false], [S (S\n    false)], and [O (O (O S))] do not.\n\n    A critical point here is that what we've done so far is just to\n    define a _representation_ of numbers: a way of writing them down.\n    The names [O] and [S] are arbitrary, and at this point they have\n    no special meaning -- they are just two different marks that we\n    can use to write down numbers (together with a rule that says any\n    [nat] will be written as some string of [S] marks followed by an\n    [O]).  If we like, we can write essentially the same definition\n    this way: *)",
    "dst": "(** FULL: 同样的规则也适用于 [day] 和 [bool] 的定义。（对于它们的构造器我们使用的标记\n    形式类似于 [O] 构造器，表示这些构造器都不接收任何参数。）\n    以上三个条件是形成 [Inductive] 声明的主要推动力。它们隐含了表达式 [O]、\n    [S O]、[S (S O)]、[ S (S (S O))] 等等都属于集合 [nat]，而像\n    [true]、[andb true false]、[S (S false)] 以及 [O (O (O S))]\n    之类的表达式则不属于 [nat]。\n    关键的一点在于，我们目前只是定义了一种数字的_表示_方式：一种写下它们的方式。\n    名称 [O] 和 [S] 是任意的，在这点上它们没有特殊的意义，\n    它们只是我们能用来写下数字的两个不同的记号（以及一个规则说明了任何 [nat]\n    都能写成一串 [S] 后跟一个 [O]）如果我们喜欢，我们完全可以将同样的定义写成： *)",
    "votes": 0
  },
  {
    "id": 92,
    "src": "(** TERSE: Critical point: this just defines a _representation_ of\n    numbers -- a unary notation for writing them down.\n       - The names [O] and [S] are arbitrary.\n       - They are just two different \"marks\", with no intrinsic\n         meaning.\n\n    We could just as well represent numbers with different marks: *)",
    "dst": "(** TERSE: 关键点：它只是定义了数的一种_表示法_ -- 一种写下它们的一进制记法。\n       - 名字 [O] 和 [S] 是任意的。\n       - 他们只是两个不同的「记号」，本身没有任何含义。\n    我们当然也可以用不同的记号表示数： *)",
    "votes": 0
  },
  {
    "id": 93,
    "src": "(** The _interpretation_ of these marks comes from how we use them to\n    compute. *)",
    "dst": "(** 这些记号的 _解释_ 完全取决于我们如何用它来进行计算。 *)",
    "votes": 0
  },
  {
    "id": 94,
    "src": "(** FULL: We can do this by writing functions that pattern match on\n    representations of natural numbers just as we did above with\n    booleans and days -- for example, here is the predecessor\n    function: *)",
    "dst": "(** FULL: 我们可以编写简单的函数对如上所述的自然数进行模式匹配 —— 比如，前趋函数：*)",
    "votes": 0
  },
  {
    "id": 95,
    "src": "(** FULL: The second branch can be read: \"if [n] has the form [S n']\n    for some [n'], then return [n'].\"  *)",
    "dst": "(** FULL: 第二个分支可以看做：「如果 [n] 对于某个 [n'] 有 [S n'] 的形式，\n    那么返回 [n']。」 *)",
    "votes": 0
  },
  {
    "id": 96,
    "src": "(* FULL *)",
    "dst": "(* FULL *)",
    "votes": 0
  },
  {
    "id": 97,
    "src": "(* /FULL *)",
    "dst": "(* /FULL *)",
    "votes": 0
  },
  {
    "id": 98,
    "src": "(** FULL: Because natural numbers are such a pervasive form of data,\n    Coq provides a tiny bit of built-in magic for parsing and printing\n    them: ordinary arabic numerals can be used as an alternative to\n    the \"unary\" notation defined by the constructors [S] and [O].  Coq\n    prints numbers in arabic form by default: *)",
    "dst": "(** FULL: 由于自然数这种数据形式无处不在，因此 Coq 在解析和输出它们时用了点内建的小魔术：\n    普通的阿拉伯数字可看做 [S] 和 [O] 构造器定义的「一进制」自然数的另一种记法，\n    Coq 默认也会将自然数输出为阿拉伯数字的形式。 *)",
    "votes": 0
  },
  {
    "id": 99,
    "src": "(** TERSE: Standard arabic numerals can be used in input\n    as a shorthand for sequences of applications of [S] to [O],\n    and Coq uses the same shorthand on output: *)",
    "dst": "(** TERSE: 标准的阿拉伯数字可以作为一系列 [S] 对 [O] 的应用的简写形式输入，\n    Coq 也使用同样的简写输出： *)",
    "votes": 0
  },
  {
    "id": 100,
    "src": "(* ===> 4 : nat *)",
    "dst": "(* ===> 4 : nat *)",
    "votes": 0
  },
  {
    "id": 101,
    "src": "(* ===> 2 : nat *)",
    "dst": "(* ===> 2 : nat *)",
    "votes": 0
  },
  {
    "id": 102,
    "src": "(** The constructor [S] has the type [nat -> nat], just like the\n    functions [minustwo] and [pred]: *)",
    "dst": "(** 构造器 [S] 具有类型 [nat -> nat]，与函数 [minustwo] 和 [pred] 相同： *)",
    "votes": 0
  },
  {
    "id": 103,
    "src": "(** These are all things that can be applied to a number to yield a\n    number.  However, there is a fundamental difference between the\n    first one and the other two: functions like [pred] and [minustwo]\n    come with _computation rules_ -- e.g., the definition of [pred]\n    says that [pred 2] can be simplified to [1] -- while the\n    definition of [S] has no such behavior attached.  Although it is\n    like a function in the sense that it can be applied to an\n    argument, it does not _do_ anything at all!  It is just a way of\n    writing down numbers.  (Think about standard arabic numerals: the\n    numeral [1] is not a computation; it's a piece of data.  When we\n    write [111] to mean the number one hundred and eleven, we are\n    using [1], three times, to write down a concrete representation of\n    a number.)\n\n    For most function definitions over numbers, just pattern matching\n    is not enough: we also need recursion.  For example, to check that\n    a number [n] is even, we may need to recursively check whether\n    [n-2] is even.  To write such functions, we use the keyword\n    [Fixpoint]. *)",
    "dst": "(** 以上这些都是作用于一个数上产生另一个数的，不过它们之间有个重要区别：\n    像 [pred] 和 [minustwo] 这样的函数带有 _计算规则_ —— 也就是说，\n    [pred] 的定义表明 [pred 2] 可被化简为 [1] —— 然而 [S] 的定义却没有\n    附带这种计算行为。尽管它感觉像是个可以作用在一个参数上的函数，\n    但却完全没有 _执行_ 任何计算！它只是一种写下数字的方式。\n    （考虑标准的阿拉伯数字：数字 [1] 并不是一个计算，它只是一段数据。当我们写下\n    [111] 来代表数字一百一十一时，我们把 [1] 写了三次来具体表示一个数。）\n    对于在数上定义的大部分函数来说，只有模式匹配是不够的：我们还需要递归。\n    比如，想要判断一个数 [n] 是否为偶数，我们需要递归地判断 [n-2] 是否为偶数。\n    为了写出这样的函数，我们可以使用关键字 [Fixpoint]。 *)",
    "votes": 0
  },
  {
    "id": 104,
    "src": "(** TERSE: Recursive functions are defined using [Fixpoint]. *)",
    "dst": "(** TERSE: 递归函数使用 [Fixpoint] 定义. *)",
    "votes": 0
  },
  {
    "id": 105,
    "src": "(** We can define [oddb] by a similar [Fixpoint] declaration, but here\n    is a simpler definition: *)",
    "dst": "(** 我们可以使用类似的 [Fixpoint] 声明来定义 [odd] 函数，不过还有个更简单的\n    定义能让我们做起来更容易：*)",
    "votes": 0
  },
  {
    "id": 106,
    "src": "(** FULL: (You will notice if you step through these proofs that\n    [simpl] actually has no effect on the goal -- all of the work is\n    done by [reflexivity].  We'll see more about why that is shortly.)\n\n    Naturally, we can also define multi-argument functions by\n    recursion.  *)",
    "dst": "(** FULL: （如果你逐步检查完这些证明，就会发现 [simpl] 其实没有效果 —— 所有工作都被\n    [reflexivity] 完成了。我们不久就会更多地了解到为什么会这样。)\n    当然，我们也可以用递归定义多参函数。 *)",
    "votes": 0
  },
  {
    "id": 107,
    "src": "(** TERSE: A multi-argument recursive function. *)",
    "dst": "(** TERSE: 一个多参递归函数 *)",
    "votes": 0
  },
  {
    "id": 108,
    "src": "(** FULL: Adding three to two now gives us five, as we'd expect. *)",
    "dst": "(** FULL: 三加二得五，正如所料。 *)",
    "votes": 0
  },
  {
    "id": 109,
    "src": "(** FULL: The simplification that Coq performs to reach this conclusion can\n    be visualized as follows: *)",
    "dst": "(** FULL: 为得出此结论，Coq 所执行的化简步骤如下所示：*)",
    "votes": 0
  },
  {
    "id": 110,
    "src": "(*  [plus (S (S (S O))) (S (S O))]\n==> [S (plus (S (S O)) (S (S O)))]\n      by the second clause of the [match]\n==> [S (S (plus (S O) (S (S O))))]\n      by the second clause of the [match]\n==> [S (S (S (plus O (S (S O)))))]\n      by the second clause of the [match]\n==> [S (S (S (S (S O))))]\n      by the first clause of the [match]\n*)",
    "dst": "(*  [plus (S (S (S O))) (S (S O))]\n==> [S (plus (S (S O)) (S (S O)))] 根据第二个 [match] 子句\n==> [S (S (plus (S O) (S (S O))))] 根据第二个 [match] 子句\n==> [S (S (S (plus O (S (S O)))))] 根据第二个 [match] 子句\n==> [S (S (S (S (S O))))]          根据第一个 [match] 子句\n*)",
    "votes": 0
  },
  {
    "id": 111,
    "src": "(** FULL: As a notational convenience, if two or more arguments have\n    the same type, they can be written together.  In the following\n    definition, [(n m : nat)] means just the same as if we had written\n    [(n : nat) (m : nat)]. *)",
    "dst": "(** FULL: 为了书写方便，如果两个或更多参数具有相同的类型，那么它们可以写在一起。\n    在下面的定义中，[(n m : nat)] 的意思与 [(n : nat) (m : nat)] 相同。 *)",
    "votes": 0
  },
  {
    "id": 112,
    "src": "(** FULL: You can match two expressions at once by putting a comma\n    between them: *)",
    "dst": "(** FULL: 你可以在两个表达式之间添加逗号来同时匹配它们：*)",
    "votes": 0
  },
  {
    "id": 113,
    "src": "(** TERSE: Pattern-matching two values at the same time: *)",
    "dst": "(** TERSE: 同时对两个值进行模式匹配： *)",
    "votes": 0
  },
  {
    "id": 114,
    "src": "(** The _ in the first line is a _wildcard pattern_.  Writing _ in a\n    pattern is the same as writing some variable that doesn't get used\n    on the right-hand side.  This avoids the need to invent a variable\n    name. *)",
    "dst": "(** 第一行里的 _ 是一个 _通配符_。在模式匹配中使用 _ 就如同写一个变量但在\n    匹配的右侧不使用它。这样可以避免声明无用的变量名。 *)",
    "votes": 0
  },
  {
    "id": 115,
    "src": "(** Recall the standard mathematical factorial function:\n<<\n       factorial(0)  =  1\n       factorial(n)  =  n * factorial(n-1)     (if n>0)\n>>\n    Translate this into Coq. *)",
    "dst": "(** 回想一下标准的阶乘函数：\n<<\n    factorial(0)  =  1\n    factorial(n)  =  n * factorial(n-1)     (if n>0)\n>>\n    把它翻译成 Coq 语言。 *)",
    "votes": 0
  },
  {
    "id": 116,
    "src": "(* ADMITTED *)",
    "dst": "(* ADMITTED *)",
    "votes": 0
  },
  {
    "id": 117,
    "src": "(* /ADMITTED *)",
    "dst": "(* /ADMITTED *)",
    "votes": 0
  },
  {
    "id": 118,
    "src": "(** We can make numerical expressions a little easier to read and\n    write by introducing _notations_ for addition, multiplication, and\n    subtraction. *)",
    "dst": "(** 我们可以通过引入加法、乘法和减法的 _记法_ 来让数字表达式更易读一些。 *)",
    "votes": 0
  },
  {
    "id": 119,
    "src": "(** FULL: (The [level], [associativity], and [nat_scope] annotations\n    control how these notations are treated by Coq's parser.  The\n    details are not important for our purposes, but interested readers\n    can refer to the optional \"More on Notation\" section at the end of\n    this chapter.)\n\n    Note that these do not change the definitions we've already made:\n    they are simply instructions to the Coq parser to accept [x + y]\n    in place of [plus x y] and, conversely, to the Coq pretty-printer\n    to display [plus x y] as [x + y]. *)",
    "dst": "(** FULL: （[level]、[associativity] 和 [nat_scope] 标记控制了 Coq 语法分析器如何处理\n    上述记法。细节无关紧要，有兴趣的读者可以参考本章末尾「进阶资料」部分中\n    「关于记法的更多内容」一节。）\n    注意，它们并不会改变我们之前的定义：只是让 Coq 语法分析器接受用 [x + y]\n    来代替 [plus x y]， 并在 Coq 美化输出时反过来将 [plus x y] 显���为 [x + y]。 *)",
    "votes": 0
  },
  {
    "id": 120,
    "src": "(** When we say that Coq comes with almost nothing built-in, we really\n    mean it: even equality testing for numbers is a user-defined\n    operation!  We now define a function [beq_nat], which tests\n    [nat]ural numbers for [eq]uality, yielding a [b]oolean.  Note the\n    use of nested [match]es (we could also have used a simultaneous\n    match, as we did in [minus].) *)",
    "dst": "(** 我们说 Coq 不包含任何内置定义时，实际上是指：\n    Coq 甚至连数值的相等性测试都是用户定义的操作！我们定义了 [beq_nat]\n    函数来测试自然数 [nat] 的相等性 [eq]，产生一个布尔值 [b]。\n    注意嵌套匹配 [match] 的使用（我们也可以使用同时匹配，与在 [minus]\n    中的做法一样）。 *)",
    "votes": 0
  },
  {
    "id": 121,
    "src": "(** The [leb] function tests whether its first argument is less than or\n  equal to its second argument, yielding a boolean. *)",
    "dst": "(** [leb] 测试其第一个参数是否小于或等于第二个参数，并返回一个布尔值。 *)",
    "votes": 0
  },
  {
    "id": 122,
    "src": "(** The [blt_nat] function tests [nat]ural numbers for [l]ess-[t]han,\n    yielding a [b]oolean.  Instead of making up a new [Fixpoint] for\n    this one, define it in terms of a previously defined function. *)",
    "dst": "(** [blt_nat] 函数测试自然数 [nat] 的小于性 [lt]，并产生一个布尔值 [b]。\n    这次不必完全重新定义一个 [Fixpoint]，可以利用前面已经定义的函数来定义。 *)",
    "votes": 0
  },
  {
    "id": 123,
    "src": "(** * Proof by Simplification *)",
    "dst": "(** * 基于化简的证明 *)",
    "votes": 0
  },
  {
    "id": 124,
    "src": "(** FULL: Now that we've defined a few datatypes and functions, let's\n    turn to stating and proving properties of their behavior.\n    Actually, we've already started doing this: each [Example] in the\n    previous sections makes a precise claim about the behavior of some\n    function on some particular inputs.  The proofs of these claims\n    were always the same: use [simpl] to simplify both sides of the\n    equation, then use [reflexivity] to check that both sides contain\n    identical values.\n\n    The same sort of \"proof by simplification\" can be used to prove\n    more interesting properties as well.  For example, the fact that\n    [0] is a \"neutral element\" for [+] on the left can be proved just\n    by observing that [0 + n] reduces to [n] no matter what [n] is, a\n    fact that can be read directly off the definition of [plus].*)",
    "dst": "(** FULL: 至此，我们已经定义了一些数据类型和函数。让我们把问题转到如何表述和证明\n    它们行为的特性上。���实我们已经开始这样做了：前几节中的每个 [Example]\n    都对几个函数在某些特定输入上的行为做出了准确的断言。对这些断言的证明都一样：\n    使用 [simpl] 来化简等式两边，然后用 [reflexivity] 来检查两边是否具有相同的值。\n    这类「基于化简的证明」还可以用来证明更多有趣的属性。例如，对于「[0]\n    出现在左边时是加法 [+] 的「幺元」」这一事实，我们只需读一遍 [plus] 的定义，\n    即可通过观察「对于 [0 + n]，无论 [n] 值为多少都可化简为 [n]」而得到证明。 *)",
    "votes": 0
  },
  {
    "id": 125,
    "src": "(** TERSE: A general property of natural numbers: *)",
    "dst": "(** TERSE: 一个自然数的一般性质： *)",
    "votes": 0
  },
  {
    "id": 126,
    "src": "(** FULL: (You may notice that the above statement looks different in\n    the [.v] file in your IDE than it does in the HTML rendition in\n    your browser, if you are viewing both. In [.v] files, we write the\n    [forall] universal quantifier using the reserved identifier\n    \"forall.\"  When the [.v] files are converted to HTML, this gets\n    transformed into an upside-down-A symbol.)\n\n    This is a good place to mention that [reflexivity] is a bit\n    more powerful than we have admitted. In the examples we have seen,\n    the calls to [simpl] were actually not needed, because\n    [reflexivity] can perform some simplification automatically when\n    checking that two sides are equal; [simpl] was just added so that\n    we could see the intermediate state -- after simplification but\n    before finishing the proof.  Here is a shorter proof of the\n    theorem: *)",
    "dst": "(** FULL: （如果你同时浏览 [.v] 文件和 HTML 文件，那么大概会注意到以上语句在你的 IDE\n    里和���浏览器渲染的 HTML 里不大一样，我们用保留标识符「forall」来表示全称量词\n    [forall]。当 [.v] 文件转换为 HTML 后，它会变成一个倒立的「A」。）\n    现在是时候提一下 [reflexivity] 了，它其实比我们所认为的更加强大。\n    在前面的例子中，其实并不需要调用 [simpl] ，因为 [reflexivity]\n    在检查等式两边是否相等时会自动做一些化简；加上 [simpl] 只是为了看到化简之后，\n    证明结束之前的中间状态。下面是对同一定理更短的证明：*)",
    "votes": 0
  },
  {
    "id": 127,
    "src": "(** TERSE: The [simpl] tactic is actually redundant, as [reflexivity]\n    already does some simplification for us: *)",
    "dst": "(** TERSE: [simpl] 策略其实是多余的，[reflexivity] 已经为我们做了一些化简： *)",
    "votes": 0
  },
  {
    "id": 128,
    "src": "(** FULL: Moreover, it will be useful later to know that [reflexivity]\n    does somewhat _more_ simplification than [simpl] does -- for\n    example, it tries \"unfolding\" defined terms, replacing them with\n    their right-hand sides.  The reason for this difference is that,\n    if reflexivity succeeds, the whole goal is finished and we don't\n    need to look at whatever expanded expressions [reflexivity] has\n    created by all this simplification and unfolding; by contrast,\n    [simpl] is used in situations where we may have to read and\n    understand the new goal that it creates, so we would not want it\n    blindly expanding definitions and leaving the goal in a messy\n    state.\n\n    The form of the theorem we just stated and its proof are almost\n    exactly the same as the simpler examples we saw earlier; there are\n    just a few differences.\n\n    First, we've used the keyword [Theorem] instead of [Example].\n    This difference is purely a matter of style; the keywords\n    [Example] and [Theorem] (and a few others, including [Lemma],\n    [Fact], and [Remark]) mean exactly the same thing to Coq.\n\n    Second, we've added the quantifier [forall n:nat], so that our\n    theorem talks about _all_ natural numbers [n].  Informally, to\n    prove theorems of this form, we generally start by saying \"Suppose\n    [n] is some number...\"  Formally, this is achieved in the proof by\n    [intros n], which moves [n] from the quantifier in the goal to a\n    _context_ of current assumptions.\n\n    The keywords [intros], [simpl], and [reflexivity] are examples of\n    _tactics_.  A tactic is a command that is used between [Proof] and\n    [Qed] to guide the process of checking some claim we are making.\n    We will see several more tactics in the rest of this chapter and\n    yet more in future chapters.\n\n    Other similar theorems can be proved with the same pattern. *)",
    "dst": "(** FULL: 此外，[reflexivity] 在某些方面做了比 [simpl] _更多_的化简 ——\n    比如它会尝试「展开」已定义的项，将它们替换为该定义右侧的值，\n    了解这一点会对以后很有帮助。产生这种差别的原因是，当自反性成立时，\n    整个证明目标就完成了，我们不必再关心 [reflexivity] 化简和展开了什么；\n    而当我们必须去观察和理解新产生的证明目标时，我们并不希望它盲目地展开定义���\n    将证明目标留在混乱的声明中。这种情况下就要用到 [simpl] 了。\n    我们刚刚声明的定理形式及其证明与前面的例子的基本相同，它们只有一点差别。\n    首先，我们使用了关键字 [Theorem] 而非 [Example]。这种差别纯粹是风格问题；\n    在 Coq 中，关键字 [Example] 和 [Theorem]（以及其它一些，包括 [Lemma]、[Fact]\n    和 [Remark]）都表示完全一样的东西。\n    其次，我们增加了量词 [forall n:nat]，因此我们的定理讨论了_所有的_自然数 [n]。\n    为了证明这种形式的定理，我们需要_假定_存在一个任意自然数 [n]，\n    以此为依据进行推理。在证明中，这是用 [intros n] 来实现的，\n    它将量词从证明目标移动到当前假设的「上下文」中。达到的效果就是，\n    我们说「OK，假设 [n] 是任意一个自然数」，然后我们开始证明。\n    关键字 [intros]、[simpl] 和 [reflexivity] 都是_策略_的例子。\n    策略是一条可以用在 [Proof]（证明）和 [Qed]（证毕）之间的命令，它告诉 Coq\n    如何去检查我们所做的一些断言的正确性。在本章剩余的部分及以后的课程中\n    我们会见到更多的策略。\n    其它类似的定理可以用相同的模式进行证明。 *)",
    "votes": 0
  },
  {
    "id": 129,
    "src": "(** FULL: The [_l] suffix in the names of these theorems is\n    pronounced \"on the left.\" *)",
    "dst": "(** FULL: 上述定理名称的后缀 [_l] 读作「在左边」。 *)",
    "votes": 0
  },
  {
    "id": 130,
    "src": "(** FULL: It is worth stepping through these proofs to observe how the\n    context and the goal change.  You may want to add calls to [simpl]\n    before [reflexivity] to see the simplifications that Coq performs\n    on the terms before checking that they are equal.\n\n    Although simplification is powerful enough to prove some fairly\n    general facts, there are many statements that cannot be handled by\n    simplification alone.  For instance, we cannot use it to prove\n    that [0] is also a neutral element for [+] _on the right_. *)",
    "dst": "(** FULL: 跟进这些证明的每个步骤，观察上下文及证明目标的变化是非常值得的。\n    你可能要在 [reflexivity] 前面增加 [simpl] 的调用，以观察 Coq\n    在检查它们相等前做的一些化简。\n    尽管对于证明一些相当普遍的事实来说，化简已经非常强大了，\n    但还有很多陈述无法仅用化简来处理。比如，当 [0] 出现在 [+]\n    的_右侧_时，用化简就无法证明���是「幺元」。 *)",
    "votes": 0
  },
  {
    "id": 131,
    "src": "(** TERSE: Unfortunately, simplification doesn't always work. *)",
    "dst": "(** TERSE: 不幸的是，化简并不总是有效。 *)",
    "votes": 0
  },
  {
    "id": 132,
    "src": "(* Doesn't do anything! *)",
    "dst": "(* 不起作用！ *)",
    "votes": 0
  },
  {
    "id": 133,
    "src": "(** FULL: (Can you explain why this happens?  Step through both proofs\n    with Coq and notice how the goal and context change.)\n\n    When stuck in the middle of a proof, we can use the [Abort]\n    command to give up on it for the moment. *)",
    "dst": "(** FULL: （你能解释这为什么这样么？在 Coq 里跟踪两个证明的每一步骤，\n注意观察证明目标和上下文的变化。）",
    "votes": 0
  },
  {
    "id": 134,
    "src": "(** FULL: (Can you explain why this happens?  Step through both proofs\n    with Coq and notice how the goal and context change.)\n\n    When stuck in the middle of a proof, we can use the [Abort]\n    command to give up on it for the moment. *)",
    "dst": "(** FULL: （你能解释这为什么这样么？在 Coq 里跟踪两个证明的每一步骤，\n    注意观察证明目标和上下文的变化。）\n\n当在证明过程中卡住时，可以用 [Abort] 命令来暂时放弃证明。 *)",
    "votes": 0
  },
  {
    "id": 135,
    "src": "(** FULL: (Can you explain why this happens?  Step through both proofs\n    with Coq and notice how the goal and context change.)\n\n    When stuck in the middle of a proof, we can use the [Abort]\n    command to give up on it for the moment. *)",
    "dst": "(** FULL: 在下一章里，我们会引入_归纳_这种技术来证明这个目标。\n    现在，让我们来看一些更简单的策略。 *)",
    "votes": 0
  },
  {
    "id": 136,
    "src": "(** FULL: The next chapter will introduce _induction_, a powerful\n    technique that can be used for proving this goal.  For the moment,\n    though, let's look at a few more simple tactics. *)",
    "dst": "(** FULL: 在下一章里，我们会引入_归纳_这种技术来证明这个目标。\n    现在，让我们来看一些更简单的策略。 *)",
    "votes": 0
  },
  {
    "id": 137,
    "src": "(** FULL: (Can you explain why this happens?  Step through both proofs\n    with Coq and notice how the goal and context change.)\n\n    When stuck in the middle of a proof, we can use the [Abort]\n    command to give up on it for the moment. *)",
    "dst": "(** FULL: （你能解释这为什么这样么？在 Coq 里跟踪两个证明的每一步骤，\n    注意观察证明目标和上下文的变化。）\n\n当在证明过程中卡住时，可以用 [Abort] 命令来暂时放弃证明。 *)",
    "votes": 0
  },
  {
    "id": 138,
    "src": "(** TERSE: We will see how to deal with this in the next chapter. *)",
    "dst": "(** TERSE: 在下一章里，我们会看到如何解决这种情况. *)",
    "votes": 0
  },
  {
    "id": 139,
    "src": "(** * The [intros] Tactic *)",
    "dst": "(** * [intros] 策略 *)",
    "votes": 0
  },
  {
    "id": 140,
    "src": "(** FULL: Aside from unit tests, which apply functions to particular\n    arguments, most of the properties we will be interested in proving\n    about programs will begin with some quantifiers (e.g., \"for all\n    numbers [n], ...\") and/or hypothesis (\"assuming [m=n], ...\").  In\n    such situations, we will need to be able to reason by _assuming\n    the hypothesis_ -- i.e., we start by saying \"OK, suppose [n] is\n    some arbitrary number,\" or \"OK, suppose [m=n].\"\n\n    The [intros] tactic permits us to do this by moving one or more\n    quantifiers or hypotheses from the goal to a \"context\" of current\n    assumptions.\n *)",
    "dst": "(** FULL: 除了将函数应用于特定参数的单元测试外，我们感兴趣证明的程序的大部分属性\n    都以某些量词（例如「对于所有数字 [n]，...」）和/或前提（「设 [m=n]，...」）开始。\n    在这种情况下，我们会需要能够通过_假定前提_来进行推理，例如，我们以\n    「OK，假设 [n] ���任意自然数，或「OK，假设 [m=n]」开始。\n    [intros] 策略允许我们通过将一个或多个量词或前提从证明目标移动到当前假设的\n    「上下文」中来做到。\n *)",
    "votes": 0
  },
  {
    "id": 141,
    "src": "(** * Proof by Rewriting *)",
    "dst": "(** * 基于改写的证明 *)",
    "votes": 0
  },
  {
    "id": 142,
    "src": "(** TERSE: A slightly more interesting theorem: *)",
    "dst": "(** TERSE: 一个更有趣的定理： *)",
    "votes": 0
  },
  {
    "id": 143,
    "src": "(** FULL: This theorem is a bit more interesting than the others we've\n    seen: *)",
    "dst": "(** FULL: 下面这个定理比我们之前见过的更有趣： *)",
    "votes": 0
  },
  {
    "id": 144,
    "src": "(** TERSE: This theorem shows that [n = m] _implies_ that [n + n = m +\n    m], and we read the arrow symbol as \"implies.\"\n\n    For this proof, we use [intros] to move all of the hypotheses from\n    the goal to the context.\n\n    The [rewrite] tactic tells Coq to replace an expression in the\n    goal with one that we know is equal to it. *)",
    "dst": "(** TERSE: 此定理说明 [n = m] _蕴含_ [n + n = m + m]，我们把箭头读作「蕴含」。\n    对于此证明，我们使用 [intros] 将所有的前提从证明目标移到上下文中。\n    [rewrite] 策略告诉 Coq 将证明目标中的表达式替换为我们已知与其相等表达式。 *)",
    "votes": 0
  },
  {
    "id": 145,
    "src": "(** FULL: Instead of making a universal claim about all numbers [n] and [m],\n    it talks about a more specialized property that only holds when [n\n    = m].  The arrow symbol is pronounced \"implies.\"\n\n    As before, we need to be able to reason by assuming we are given such\n    numbers [n] and [m].  We also need to assume the hypothesis\n    [n = m]. The [intros] tactic will serve to move all three of these\n    from the goal into assumptions in the current context.\n\n    Since [n] and [m] are arbitrary numbers, we can't just use\n    simplification to prove this theorem.  Instead, we prove it by\n    observing that, if we are assuming [n = m], then we can replace\n    [n] with [m] in the goal statement and obtain an equality with the\n    same expression on both sides.  The tactic that tells Coq to\n    perform this replacement is called [rewrite]. *)",
    "dst": "(** FULL: 该定理并未对自然数 [n] 和 [m] 所有可能的值做全称论断，而是讨论了仅当\n    [n = m] 时这一更加���定情况。箭头符号读作「蕴含」。\n    与此前相同，我们需要在能够假定存在自然数 [n] 和 [m] 的基础上进行推理。\n    另外我们需要假定有前提 [n = m]。[intros] 策略用来将这三条前提从证明目标\n    移动到当前上下文的假设中。\n    由于 [n] 和 [m] 是任意自然数，我们无法用化简来证明此定理，不过可以通过\n    观察来证明它。如果我们假设了 [n = m]，那么就可以将证明目标中的\n    [n] 替换成 [m] 从而获得两边表达式相同的等式。用来告诉 Coq 执行这种替换的\n    策略叫做改写 [rewrite]。 *)",
    "votes": 0
  },
  {
    "id": 146,
    "src": "(* move both quantifiers into the context: *)",
    "dst": "(* 将两个量词移到上下文中 *)",
    "votes": 0
  },
  {
    "id": 147,
    "src": "(* move the hypothesis into the context: *)",
    "dst": "(* 将前提移到上下文中 *)",
    "votes": 0
  },
  {
    "id": 148,
    "src": "(* rewrite the goal using the hypothesis: *)",
    "dst": "(* 用前提改写目标 *)",
    "votes": 0
  },
  {
    "id": 149,
    "src": "(** TERSE: The uses of [intros] name the hypotheses as they are moved\n    to the context.  The [rewrite] needs to know which equality is being\n    used and in which direction to do the replacement. *)",
    "dst": "(** TERSE: [intros] 用于命名前提，因为它们被移到了上下文中。[rewrite]\n    需要知道使用了哪个等式，以及按照哪个方向来代换。 *)",
    "votes": 0
  },
  {
    "id": 150,
    "src": "(** FULL: The first line of the proof moves the universally quantified\n    variables [n] and [m] into the context.  The second moves the\n    hypothesis [n = m] into the context and gives it the name [H].\n    The third tells Coq to rewrite the current goal ([n + n = m + m])\n    by replacing the left side of the equality hypothesis [H] with the\n    right side.\n\n    (The arrow symbol in the [rewrite] has nothing to do with\n    implication: it tells Coq to apply the rewrite from left to right.\n    To rewrite from right to left, you can use [rewrite <-].  Try\n    making this change in the above proof and see what difference it\n    makes.) *)",
    "dst": "(** FULL: 证明的第一行将全称量词变量 [n] 和 [m] 移动到上下文中。第二行将前提\n    [n = m] 移动到上下文中，并将其（随意）命名为 [H]。第三行告诉 Coq\n    改写当前目标（[n + n = m + m]），把前提等式 [H] 的左边替换成右边。\n    ([rewrite] 里的箭头与蕴含无关：它指示 Coq ���左往右地应用改写。\n    若要从右往左改写，可以使用 [rewrite <-]。在上面的证明里试一试这种改变，\n    看看 Coq 的反应有何变化。) *)",
    "votes": 0
  },
  {
    "id": 151,
    "src": "(** Remove \"[Admitted.]\" and fill in the proof. *)",
    "dst": "(** 删除 \"[Admitted.]\" 并补充完整证明。 *)",
    "votes": 0
  },
  {
    "id": 152,
    "src": "(** FULL: The [Admitted] command tells Coq that we want to skip trying\n    to prove this theorem and just accept it as a given.  This can be\n    useful for developing longer proofs, since we can state subsidiary\n    lemmas that we believe will be useful for making some larger\n    argument, use [Admitted] to accept them on faith for the moment,\n    and continue working on the main argument until we are sure it\n    makes sense; then we can go back and fill in the proofs we\n    skipped.  Be careful, though: every time you say [Admitted] you\n    are leaving a door open for total nonsense to enter Coq's nice,\n    rigorous, formally checked world! *)",
    "dst": "(** FULL: [Admitted] 命令告诉 Coq 我们想要跳过此定理的证明而将其作为已知条件，\n    这在开发较长的证明时很有用。在进行一些较大的命题论证时，我们能够声明一些附加的事实。\n    既然我们认为这些事实是对论证有用的，就可以用 [Admitted] 先不加怀疑地接受这些事实，\n    然后继续思考大命题的论证。直到确认了该命题确实是有意义的，\n    再回过头去证明刚才跳过的证明。但是要小心：每次使用 [Admitted] 或者 [admit]，\n    你就为进入 Coq 这个完好、严密、形式化且封闭的世界开了一个毫无道理的后门。 *)",
    "votes": 0
  },
  {
    "id": 153,
    "src": "(** We can also use the [rewrite] tactic with a previously proved\n    theorem instead of a hypothesis from the context. If the statement\n    of the previously proved theorem involves quantified variables,\n    as in the example below, Coq tries to instantiate them\n    by matching with the current goal. *)",
    "dst": "(** 我们还可以使用 [rewrite] 策略来运用前期已证明过的定理，而不是上下文中的现有前提。\n    如果前期证明的定理的语句中包含量词变量，如前例所示，Coq 会通过匹配当前证明目标\n    来尝试实例化它们。 *)",
    "votes": 0
  },
  {
    "id": 154,
    "src": "(* PR: If a student doesn't understand that [rewrite] works with\n   quantified terms, they won't be able to solve exercise boolean_functions\n   below. It might make sense to replace variables n and m in the next\n   two theorems with p and q so that the matching is nontrivial, but\n   it may be moot if these are replaced by better examples. *)",
    "dst": "(* PR: 若学生不理解 [rewrite] 是如何用量词项工作的，那么它们就无法解出下面的练习\n   boolean_functions。用 p 和 q 替换下两个定理中的变量 n 和 m 可能更有助于理解，\n   这种匹配是非平凡的，但如果用更好的例子来代替的话可能会引起争论。 *)",
    "votes": 0
  },
  {
    "id": 155,
    "src": "(* One suggestion, but perhaps this use of rewrite is a bit much. *)",
    "dst": "(* 一个建议，不过这儿的 rewrite 可能有点多。 *)",
    "votes": 0
  },
  {
    "id": 156,
    "src": "(* (N.b. This proof can actually be completed without using [rewrite],\n   but please do use [rewrite] for the sake of the exercise.) *)",
    "dst": "(* （注意，此证明其实不用 [rewrite] 就能证明，不过请使用 [rewrite] 来做练习。 *)",
    "votes": 0
  },
  {
    "id": 157,
    "src": "(** * Proof by Case Analysis *)",
    "dst": "(** * 利用情况分析来证明 *)",
    "votes": 0
  },
  {
    "id": 158,
    "src": "(** FULL: Of course, not everything can be proved by simple\n    calculation and rewriting: In general, unknown, hypothetical\n    values (arbitrary numbers, booleans, lists, etc.) can block\n    simplification.  For example, if we try to prove the following\n    fact using the [simpl] tactic as above, we get stuck. *)",
    "dst": "(** FULL: 当然，并非一切都能通过简单的计算和改写来证明：通常，一些未知的，假定的值\n    （如任意数值、布尔值、列表等等）会阻碍化简。比如，我们如果像以前一样使用\n    [simpl] 策略尝试证明下面的事实，就会被卡住。 *)",
    "votes": 0
  },
  {
    "id": 159,
    "src": "(** TERSE: Sometimes simplification and rewriting are not enough... *)",
    "dst": "(** TERSE: 有时化简和改写还不够... *)",
    "votes": 0
  },
  {
    "id": 160,
    "src": "(* does nothing! *)",
    "dst": "(* 无能为力! *)",
    "votes": 0
  },
  {
    "id": 161,
    "src": "(** FULL: The reason for this is that the definitions of both\n    [beq_nat] and [+] begin by performing a [match] on their first\n    argument.  But here, the first argument to [+] is the unknown\n    number [n] and the argument to [beq_nat] is the compound\n    expression [n + 1]; neither can be simplified.\n\n    To make progress, we need to consider the possible forms of [n]\n    separately.  If [n] is [O], then we can calculate the final result\n    of [beq_nat (n + 1) 0] and check that it is, indeed, [false].  And\n    if [n = S n'] for some [n'], then, although we don't know exactly\n    what number [n + 1] yields, we can calculate that, at least, it\n    will begin with one [S], and this is enough to calculate that,\n    again, [beq_nat (n + 1) 0] will yield [false].\n\n    The tactic that tells Coq to consider, separately, the cases where\n    [n = O] and where [n = S n'] is called [destruct]. *)",
    "dst": "(** FULL: 原因在于 [beq_nat] 和 [+] 的定义都是对它们的第一个参数进行 [match] 匹配的。\n    但在这里，[+] 的第一个参数是未知数 [n]，而 [beq_nat] 的第一个参数是\n    复合表达式 [n + 1]，二者都不能被化简。\n    为了继续进行，我们需要分别考虑 [n] 所有可能的形式。如果 [n] 是 [0]，那么\n    我们可以计算 [beq_nat (n + 1) 0] 的最终结果并验证，即 [false]。\n    若对于某个 [n'] 有 [n = S n']，那么，尽管我们无法确切知道 [n + 1] 得到的数字，\n    但仍然可以进行计算，至少它应该以 [S] 打头。这对于计算已经足够了。同样，\n    [beq_nat (n + 1) 0] 会得到 [false]。\n    告诉 Coq 根据情况 [n = 0] 和 [n = S n'] 来分开考虑的策略，叫做 [destruct]。 *)",
    "votes": 0
  },
  {
    "id": 162,
    "src": "(** TERSE: We can use [destruct] to perform case analysis: *)",
    "dst": "(** TERSE: 我们可以用 [destruct] 来按情况分析： *)",
    "votes": 0
  },
  {
    "id": 163,
    "src": "(** TERSE: Note the \"bullets\" marking the proofs of the two subgoals. *)",
    "dst": "(** TERSE: 注意标在两个子目标前的「标号」。 *)",
    "votes": 0
  },
  {
    "id": 164,
    "src": "(** FULL: The [destruct] generates _two_ subgoals, which we must then\n    prove, separately, in order to get Coq to accept the theorem. The\n    annotation \"[as [| n']]\" is called an _intro pattern_.  It tells\n    Coq what variable names to introduce in each subgoal.  In general,\n    what goes between the square brackets is a _list of lists_ of\n    names, separated by [|].  In this case, the first component is\n    empty, since the [O] constructor is nullary (it doesn't have any\n    arguments).  The second component gives a single name, [n'], since\n    [S] is a unary constructor.\n\n    The [-] signs on the second and third lines are called _bullets_,\n    and they mark the parts of the proof that correspond to each\n    generated subgoal.  The proof script that comes after a bullet is\n    the entire proof for a subgoal.  In this example, each of the\n    subgoals is easily proved by a single use of [reflexivity], which\n    itself performs some simplification -- e.g., the first one\n    simplifies [beq_nat (S n' + 1) 0] to [false] by first rewriting\n    [(S n' + 1)] to [S (n' + 1)], then unfolding [beq_nat], and then\n    simplifying the [match].\n\n    Marking cases with bullets is entirely optional: if bullets are\n    not present, Coq simply asks you to prove each subgoal in\n    sequence, one at a time. But it is a good idea to use bullets.\n    For one thing, they make the structure of a proof apparent, making\n    it more readable. Also, bullets instruct Coq to ensure that a\n    subgoal is complete before trying to verify the next one,\n    preventing proofs for different subgoals from getting mixed\n    up. These issues become especially important in large\n    developments, where fragile proofs lead to long debugging\n    sessions.\n\n    There are no hard and fast rules for how proofs should be\n    formatted in Coq -- in particular, where lines should be broken\n    and how sections of the proof should be indented to indicate their\n    nested structure.  However, if the places where multiple subgoals\n    are generated are marked with explicit bullets at the beginning of\n    lines, then the proof will be readable almost no matter what\n    choices are made about other aspects of layout.\n\n    This is also a good place to mention one other piece of somewhat\n    obvious advice about line lengths.  Beginning Coq users sometimes\n    tend to the extremes, either writing each tactic on its own line\n    or writing entire proofs on one line.  Good style lies somewhere\n    in the middle.  One reasonable convention is to limit yourself to\n    80-character lines.\n\n    The [destruct] tactic can be used with any inductively defined\n    datatype.  For example, we use it next to prove that boolean\n    negation is involutive -- i.e., that negation is its own\n    inverse. *)",
    "dst": "(** FULL: [destruct] 会生成_两个_子目标，这两个目标我们需要分别进行证明，\n    然后才能让 Coq 接受此定理是已证明的。记法 \"[as [| n']]\" 叫做\n    _引入模式_，用来告诉 Coq 每个子目标中引入的变量名是什么。\n    通常，在方括号内是一组_名字列表的列表_，中间用 [|] 分隔。在本例中，\n    列表的第一个成员是空，因为 [0] 的构造器是零元的（不包含任何参数）。\n    第二个成员给出了一个名字 [n']，是因为 [S] 是一元构造器。\n    第二和第三行中的 [-] 符号叫做_标号_，标明了每个生成的子目标对应的证明部分。\n    （译注：此处的「标号」应理解为一个项目列表中每个_条目_前的小标记，如‣或•。）\n    标号后面的代码是一个子目标的完整证明。在本例中，每个子目标都简单地使用\n    [reflexivity] 完成了证明，通常 [reflexivity] 本身会执行一���化简操作。\n    比如，第一段证明将 [beq_nat (S n' + 1) 0] 化简成 [false]，是通过先将\n    [(S n' + 1)] 转写成 [S (n' + 1)]，接着展开 [beq_nat]，之后再化简 [match] 完成的。\n    用标号来标记区分情况完全是可选的：如果标号不存在，Coq 只会简单地要求你\n    依次证明每个子目标。尽管如此，使用标号仍然是一个好习惯。原因有二：\n    首先，它能让一个证明的结构更加清晰易读。其次，标号能指示 Coq\n    在开始验证下一个目标前确认上一个子目标已完成，防止不同子目标的证明\n    搅和在一起。这一点在大型开发中尤其重要，一些证明片段会导致很耗时的\n    排错过程。\n    在 Coq 中并没有既严格又便捷的规则来格式化证明 —— 尤其指应在哪里断行，\n    以及证明中的段落应如何缩进以显示其嵌套结构。然而，无论格式的其它方面如何布局，\n    只要在多个子目标生成的地方为每行开头标上标号，那么整个证明就会有很好的可读性。\n    这里也有必要提一下关于每行代码长度的建议。Coq 的初学者有时爱走极端，\n    要么一行只有一个策略语句，要么把整个证明都写在一行里。更好的风格则介于两者之间。\n    一个合理的习惯是给自己设定一个每行 80 字符的���制。更长的行会很难读，\n    也不便于显示或打印。很多编辑器都能帮你做到。\n    [destruct] 策略可用于任何归纳定义的数据类型。比如，我们接下来会用它来证明\n    布尔值的取反是对合的 —— 即，取反是自身的逆运算。 *)",
    "votes": 0
  },
  {
    "id": 165,
    "src": "(** TERSE: Another example (using booleans): *)",
    "dst": "(** TERSE: 另一个例子（使用布尔类型）： *)",
    "votes": 0
  },
  {
    "id": 166,
    "src": "(** FULL: Note that the [destruct] here has no [as] clause because\n    none of the subcases of the [destruct] need to bind any variables,\n    so there is no need to specify any names.  (We could also have\n    written [as [|]], or [as []].)  In fact, we can omit the [as]\n    clause from _any_ [destruct] and Coq will fill in variable names\n    automatically.  This is generally considered bad style, since Coq\n    often makes confusing choices of names when left to its own\n    devices.\n\n    It is sometimes useful to invoke [destruct] inside a subgoal,\n    generating yet more proof obligations. In this case, we use\n    different kinds of bullets to mark goals on different \"levels.\"\n    For example: *)",
    "dst": "(** FULL: 注意这里的 [destruct] 没有 [as] 子句，因为此处 [destruct]\n    生成的子情况均无需绑定任何变量，因此也就不必指定名字。（当然，我们也可以写上\n    [as [|]] 或者 [as []]。) 实际上，我们也可以省略_任何_ [destruct] 中��� [as] 子句，\n    Coq 会自动填上变量名。不过这通常是个坏习惯，因为如果任其自由决定的话，\n    Coq 经常会选择一些容易令人混淆的名字。\n    有时在一个子目标内调用 [destruct]，产生出更多的证明义务（Proof Obligation）\n    也非常有用。这时候，我们使用不同的标号来标记目标的不同「层级」，比如： *)",
    "votes": 0
  },
  {
    "id": 167,
    "src": "(** TERSE: We can have nested subgoals (and we use different \"bullets\"\n    to mark the inner ones): *)",
    "dst": "(** TERSE: 我们可以嵌套子目标（并且使用不同的「标号」标记内层）： *)",
    "votes": 0
  },
  {
    "id": 168,
    "src": "(** FULL: Each pair of calls to [reflexivity] corresponds to the\n    subgoals that were generated after the execution of the [destruct c]\n    line right above it. *)",
    "dst": "(** FULL: 每一对 [reflexivity] 调用对应于紧邻其上的 [destruct] 行执行后所生成的子目标。 *)",
    "votes": 0
  },
  {
    "id": 169,
    "src": "(** Besides [-] and [+], we can use [*] (asterisk) as a third kind of\n    bullet.  We can also enclose sub-proofs in curly braces, which is\n    useful in case we ever encounter a proof that generates more than\n    three levels of subgoals: *)",
    "dst": "(** 除了 [-] 和 [+]，Coq 证明还可以使用 [*] 作为第三种标号。我们也可以用花括号\n    将每个子证明目标括起来，这在遇到一个证明生成了超过三层的子目标时很有用： *)",
    "votes": 0
  },
  {
    "id": 170,
    "src": "(** FULL: Since curly braces mark both the beginning and the end of a\n    proof, they can be used for multiple subgoal levels, as this\n    example shows. Furthermore, curly braces allow us to reuse the\n    same bullet shapes at multiple levels in a proof: *)",
    "dst": "(** FULL: 由于花括号同时标识了证明的开始和结束，因此它们可以同时用在不同的子目标层级，\n    如上例所示。进一步地，花括号允许我们在一个证明中的多个层级下使用同一个标号： *)",
    "votes": 0
  },
  {
    "id": 171,
    "src": "(** FULL: Before closing the chapter, let's mention one final\n    convenience.  As you may have noticed, many proofs perform case\n    analysis on a variable right after introducing it:\n[[\n       intros x y. destruct y as [|y].\n]]\n    This pattern is so common that Coq provides a shorthand for it: we\n    can perform case analysis on a variable when introducing it by\n    using an intro pattern instead of a variable name. For instance,\n    here is a shorter proof of the [plus_1_neq_0] theorem above. *)",
    "dst": "(** FULL: 在本章结束之前，我们谈一下最后一个约定。或许你已经注意到了，\n    很多证明在引入变量之后会立即对它进行情况分析：\n[[\n       intros x y. destruct y as [|y].\n]]\n    这种模式很常见，Coq 为此提供了一种简写：当使用引入模式而非变量名来引入标量时，\n    我们可以直接对变量进行情况分析。例如，下面就是一个比前面更短的对 [plus_1_neq_0]\n    定理的证明。 *)",
    "votes": 0
  },
  {
    "id": 172,
    "src": "(** If there are no arguments to name, we can just write [[]]. *)",
    "dst": "(** 如果没有需要命名的参数我们只需写上 [[]] 即可。 *)",
    "votes": 0
  },
  {
    "id": 173,
    "src": "(** Prove the following claim, marking cases (and subcases) with\n    bullets when you use [destruct]. *)",
    "dst": "(** 证明以下论断, 当使用 [destruct] 时请用标号标出情况（及子情况）。 *)",
    "votes": 0
  },
  {
    "id": 174,
    "src": "(** ** More on Notation (Optional) *)",
    "dst": "(** * 关于记法的更多内容 (可选) *)",
    "votes": 0
  },
  {
    "id": 175,
    "src": "(** (In general, sections marked Optional are not needed to follow the\n    rest of the book, except possibly other Optional sections.  On a\n    first reading, you might want to skim these sections so that you\n    know what's there for future reference.)\n\n    Recall the notation definitions for infix plus and times: *)",
    "dst": "(** （通常，标记为可选的部分对于跟进本书其它部分的学习来说不是必须的，\n    除了那些也标记为可选的部分。在初次阅读时，你可以快速浏览这些部分，\n    以便在将来遇到时能够想起来这里讲了些什么。）\n    回忆一下中缀加法和乘法的记法定义：*)",
    "votes": 0
  },
  {
    "id": 176,
    "src": "(** For each notation symbol in Coq, we can specify its _precedence\n    level_ and its _associativity_.  The precedence level [n] is\n    specified by writing [at level n]; this helps Coq parse compound\n    expressions.  The associativity setting helps to disambiguate\n    expressions containing multiple occurrences of the same\n    symbol. For example, the parameters specified above for [+] and\n    [*] say that the expression [1+2*3*4] is shorthand for\n    [(1+((2*3)*4))]. Coq uses precedence levels from 0 to 100, and\n    _left_, _right_, or _no_ associativity.  We will see more examples\n    of this later, e.g., in the #<a href=\"Lists.html\">#[Lists]#</a>#\n    chapter.\n\n    Each notation symbol is also associated with a _notation scope_.\n    Coq tries to guess what scope is meant from context, so when it\n    sees [S(O*O)] it guesses [nat_scope], but when it sees the\n    cartesian product (tuple) type [bool*bool] (which we'll see in\n    later chapters) it guesses [type_scope].  Occasionally, it is\n    necessary to help it out with percent-notation by writing\n    [(x*y)%nat], and sometimes in what Coq prints it will use [%nat]\n    to indicate what scope a notation is in.\n\n    Notation scopes also apply to numeral notation ([3], [4], [5],\n    etc.), so you may sometimes see [0%nat], which means [O] (the\n    natural number [0] that we're using in this chapter), or [0%Z],\n    which means the Integer zero (which comes from a different part of\n    the standard library).\n\n    Pro tip: Coq's notation mechanism is not especially powerful.\n    Don't expect too much from it! *)",
    "dst": "(** 对于 Coq 中的每个记法符号，我们可以指定它的_优先级_和_结合性_。\n    优先级 [n] 用 [at level n] 来表示，这将有助于 Coq 分析复合表达式。\n    结合性的设置有助于消除有相同符号出现多次的表达式的歧义。比如，\n    上面这组对 [+] 和 [*] 的参数定义的表达式 [1+2*3*4] 是 [(1+((2*3)*4))] 的\n    简写。Coq 使用 0 到 100 的优先级等级，同时支持_左结合_、_右结合_和_不结合_\n    三种结合性。之后我们会看到更多与此相关的例子，比如在 [列表] 一章。\n    每个记法符号还与_记法范围（notation scope）_相关。Coq 会尝试根据上下文来猜测\n    你所指的范围，因此当你写出 [S(0*0)] 时，它猜测是 [nat_scope]；而当你\n    写出笛卡尔积（元组）类型 [bool*bool] 时，它猜测是 [type_scope]。\n    有时你可能不得不用百分号记法写出 [(x*y)%nat] 来帮助 Coq 确定范围，\n    另外，有时 Coq 对你的反馈中也包含 [%nat] 用来指示记法所在的范围。\n    记法范围同样适用与数字表示（[3]、[4]、[5] 等等），因此你有时候会看到\n    [0%nat]，表示 [0]（我们在本章中使用的自然数零 [0]），而 [0%Z] 表示整数零\n    （来自于标准库中的另一个部分）。\n    专业提示：Coq 的符号机制不是特别强大。别期望太多！ *)",
    "votes": 0
  },
  {
    "id": 177,
    "src": "(** ** Fixpoints and Structural Recursion (Optional) *)",
    "dst": "(** * 不动点 [Fixpoint] 以及结构化递归 (可选) *)",
    "votes": 0
  },
  {
    "id": 178,
    "src": "(** Here is a copy of the definition of addition: *)",
    "dst": "(** 以下是加法定义的一个副本： *)",
    "votes": 0
  },
  {
    "id": 179,
    "src": "(** When Coq checks this definition, it notes that [plus'] is\n    \"decreasing on 1st argument.\"  What this means is that we are\n    performing a _structural recursion_ over the argument [n] -- i.e.,\n    that we make recursive calls only on strictly smaller values of\n    [n].  This implies that all calls to [plus'] will eventually\n    terminate.  Coq demands that some argument of _every_ [Fixpoint]\n    definition is \"decreasing.\"\n\n    This requirement is a fundamental feature of Coq's design: In\n    particular, it guarantees that every function that can be defined\n    in Coq will terminate on all inputs.  However, because Coq's\n    \"decreasing analysis\" is not very sophisticated, it is sometimes\n    necessary to write functions in slightly unnatural ways. *)",
    "dst": "(** 当 Coq 查看此定义时，它会意识到 [plus'] 是「在其第一个参数上递减」。\n    这意味着我们在参数 [n] 上执行了_结构化递归_。换言之，我们仅对严格减小了的\n    [n] 值���行递归调用。这隐含说明了对 [plus'] 的调用最终会停止。Coq 要求每个\n    [Fixpoint] 定义中的某些参数必须是「递减的」。\n    这项要求是 Coq 设计的根本特性之一：尤其是，它保证了能在 Coq 中定义的\n    所有函数对于所有输入都能终止。然而，由于 Coq 的「递减分析」不是非常精致，\n    因此有时必须用一点不同寻常的方式来编写函数。 *)",
    "votes": 0
  },
  {
    "id": 180,
    "src": "(** To get a concrete sense of this, find a way to write a sensible\n    [Fixpoint] definition (of a simple function on numbers, say) that\n    _does_ terminate on all inputs, but that Coq will reject because\n    of this restriction. *)",
    "dst": "(** 为了能对此有更具体的认识，找出一种方式写出有效的 [Fixpoint] 定义\n    (比如有关数字的简单函数)，在各种的输入下应当_确实_能够终止，但是 Coq\n    却受限于此而拒绝接受。 *)",
    "votes": 0
  },
  {
    "id": 181,
    "src": "(* SOLUTION *)",
    "dst": "(* SOLUTION *)",
    "votes": 0
  },
  {
    "id": 182,
    "src": "(*\nFixpoint factorial_bad (n:nat) : nat :=\n  match beq_nat n 0 with\n  | true => 1\n  | false => n * (factorial_bad (n-1))\n  end.\n*)",
    "dst": "(*\nFixpoint factorial_bad (n:nat) : nat :=\n  match beq_nat n 0 with\n  | true => 1\n  | false => n * (factorial_bad (n-1))\n  end.\n*)",
    "votes": 0
  },
  {
    "id": 183,
    "src": "(* /SOLUTION *)",
    "dst": "(* /SOLUTION *)",
    "votes": 0
  },
  {
    "id": 184,
    "src": "(** [] *)",
    "dst": "(** [] *)",
    "votes": 0
  },
  {
    "id": 185,
    "src": "(** * More Exercises *)",
    "dst": "(** * 更多练习 *)",
    "votes": 0
  },
  {
    "id": 186,
    "src": "(** Use the tactics you have learned so far to prove the following\n    theorem about boolean functions. *)",
    "dst": "(** 用你已经学过的策略证明以下关于布尔函数的定理。 *)",
    "votes": 0
  },
  {
    "id": 187,
    "src": "(** Now state and prove a theorem [negation_fn_applied_twice] similar\n    to the previous one but where the second hypothesis says that the\n    function [f] has the property that [f x = negb x].*)",
    "dst": "(** 现在声明并证明定理 [negation_fn_applied_twice]，与上一个类似，但是\n    第二个前提是说函数 [f] 有 [f x = negb x] 的性质。 *)",
    "votes": 0
  },
  {
    "id": 188,
    "src": "(** Prove the following theorem.  (You may want to first prove a\n    subsidiary lemma or two. Alternatively, remember that you do\n    not have to introduce all hypotheses at the same time.) *)",
    "dst": "(** 证明下列定理。（你有可能需要先证明一到两个辅助引理。或者，你要记住\n    并非要同时引入所有前提。） *)",
    "votes": 0
  },
  {
    "id": 189,
    "src": "(* QUIETSOLUTION *)",
    "dst": "(* QUIETSOLUTION *)",
    "votes": 0
  },
  {
    "id": 190,
    "src": "(* /QUIETSOLUTION *)",
    "dst": "(* /QUIETSOLUTION *)",
    "votes": 0
  },
  {
    "id": 191,
    "src": "(** Consider a different, more efficient representation of natural\n    numbers using a binary rather than unary system.  That is, instead\n    of saying that each natural number is either zero or the successor\n    of a natural number, we can say that each binary number is either\n\n      - zero,\n      - twice a binary number, or\n      - one more than twice a binary number.\n\n    (a) First, write an inductive definition of the type [bin]\n        corresponding to this description of binary numbers.\n\n    (Hint: Recall that the definition of [nat] above,\n[[\n         Inductive nat : Type := | O : nat | S : nat -> nat.\n]]\n    says nothing about what [O] and [S] \"mean.\"  It just says \"[O] is\n    in the set called [nat], and if [n] is in the set then so is [S\n    n].\"  The interpretation of [O] as zero and [S] as successor/plus\n    one comes from the way that we _use_ [nat] values, by writing\n    functions to do things with them, proving things about them, and\n    so on.  Your definition of [bin] should be correspondingly simple;\n    it is the functions you will write next that will give it\n    mathematical meaning.)\n\n    (b) Next, write an increment function [incr] for binary numbers,\n        and a function [bin_to_nat] to convert binary numbers to unary\n        numbers.\n\n    (c) Write five unit tests [test_bin_incr1], [test_bin_incr2], etc.\n        for your increment and binary-to-unary functions.  (A \"unit\n        test\" in Coq is a specific [Example] that can be proved with\n        just [reflexivity], as we've done for several of our\n        definitions.)  Notice that incrementing a binary number and\n        then converting it to unary should yield the same result as\n        first converting it to unary and then incrementing. *)",
    "dst": "(** 设想一种不同的、更有效的表示自然数的方法，使用二进制，而不是一进制。\n    换言之，并非说每个自然数是零或者另一个自然数的后继，我们可以说每个\n    自然数：\n      - 要么是零，\n      - 要么是一个二进制数的两倍，\n      - 要么比一个二进制数的两倍还多一。\n    (a) 首先，写出对应上述二进制数类型 [bin] 的归纳定义。\n    (提示：回想一下 [nat] 的定义，\n[[\n         Inductive nat : Type :=\n           | O : nat\n           | S : nat -> nat.\n]]\n    它并没有说出 [O] 和 [S] 的「含义���。它只是说「[O] 是在被称之为 [nat] 的集合中，\n    而且，如果 [n] 在集合中那么 [S n] 也在集合中。」把 [O] 解释为零以及把 [S]\n    定义为后继或者加一运算，是因为我们按这种方式去「使用」了 [nat] 的值而已。\n    我们写出函数来计算它们，证明与之相关的东西，等等。你的 [bin] 的定义\n    应该相对简单，下一步你写出的函数才会给出它的数学含义。)\n    (b) 进一步地，为二进制数写出自增函数 [incr]，并且写出函数 [bin_to_nat]\n        来将二进制数转换成一进制数。\n    (c) 针对你写出的自增函数和二进制-一进制转换函数，写5个单元测试，\n        如 [test_bin_incr1], [test_bin_incr2], 等等。注意，将一个二进制数\n        先自增再转换为一进制数，应该与将其先转换成一进制后再自增获得的结果相同。\n*)",
    "votes": 0
  },
  {
    "id": 192,
    "src": "(* Local Variables: *)",
    "dst": "(* Local Variables: *)",
    "votes": 0
  },
  {
    "id": 193,
    "src": "(* fill-column: 70  *)",
    "dst": "(* fill-column: 70  *)",
    "votes": 0
  },
  {
    "id": 194,
    "src": "(* HIDE *)",
    "dst": "(* HIDE *)",
    "votes": 0
  },
  {
    "id": 195,
    "src": "(* /HIDE *)",
    "dst": "(* /HIDE *)",
    "votes": 0
  },
  {
    "id": 196,
    "src": "(* End:             *)",
    "dst": "(* End:             *)",
    "votes": 0
  },
  {
    "id": 197,
    "src": "(* EX3M (binary) *)",
    "dst": "(* EX3M (binary) *)",
    "votes": 0
  },
  {
    "id": 198,
    "src": "(* GRADE_THEOREM 2: andb_eq_orb *)",
    "dst": "(* GRADE_THEOREM 2: andb_eq_orb *)",
    "votes": 0
  },
  {
    "id": 199,
    "src": "(* SOONER: Here a direct proof:\n   Proof.\n     intros b c.\n     destruct b.\n     simpl.\n     intros H.\n     rewrite -> H.\n     reflexivity.\n     simpl.\n     intros H.\n     rewrite -> H.\n     reflexivity.  Qed.\n*)",
    "dst": "(* SOONER: Here a direct proof:\n   Proof.\n     intros b c.\n     destruct b.\n     simpl.\n     intros H.\n     rewrite -> H.\n     reflexivity.\n     simpl.\n     intros H.\n     rewrite -> H.\n     reflexivity.  Qed.\n*)",
    "votes": 0
  },
  {
    "id": 200,
    "src": "(* EX2 (andb_eq_orb) *)",
    "dst": "(* EX2 (andb_eq_orb) *)",
    "votes": 0
  },
  {
    "id": 201,
    "src": "(* GRADE_THEOREM 1: negation_fn_applied_twice *)",
    "dst": "(* GRADE_THEOREM 1: negation_fn_applied_twice *)",
    "votes": 0
  },
  {
    "id": 202,
    "src": "(* GRADE_THEOREM 1: identity_fn_applied_twice *)",
    "dst": "(* GRADE_THEOREM 1: identity_fn_applied_twice *)",
    "votes": 0
  },
  {
    "id": 203,
    "src": "(* EX2M (boolean_functions) *)",
    "dst": "(* EX2M (boolean_functions) *)",
    "votes": 0
  },
  {
    "id": 204,
    "src": "(* EX2? (decreasing) *)",
    "dst": "(* EX2? (decreasing) *)",
    "votes": 0
  },
  {
    "id": 205,
    "src": "(* LATER: There's probably much more to say about this... *)",
    "dst": "(* LATER: There's probably much more to say about this... *)",
    "votes": 0
  },
  {
    "id": 206,
    "src": "(** When Coq checks this definition, it notes that [plus'] is\n    \"decreasing on 1st argument.\"  What this means is that we are\n    performing a _structural recursion_ over the argument [n] -- i.e.,\n    that we make recursive calls only on strictly smaller values of\n    [n].  This implies that all calls to [plus'] will eventually\n    terminate.  Coq demands that some argument of _every_ [Fixpoint]\n    definition is \"decreasing.\"\n\n    This requirement is a fundamental feature of Coq's design: In\n    particular, it guarantees that every function that can be defined\n    in Coq will terminate on all inputs.  However, because Coq's\n    \"decreasing analysis\" is not very sophisticated, it is sometimes\n    necessary to write functions in slightly unnatural ways. *)",
    "dst": "(** 当 Coq 查看此定义时，它会意识到 [plus'] 是「在其第一个参数上递减」。\n    这意味着我们在参数 [n] 上执行了 _结构化递归_ 。换言之，我们仅对严格减小了的\n    [n] 值进行递归调用。这隐含说明了对 [plus'] 的调用最终会停止。Coq 要求每个\n    [Fixpoint] 定义中的某些参数必须是「递减的」。\n    这项要求是 Coq 设计的根本特性之一：尤其是，它保证了能在 Coq 中定义的\n    所有函数对于所有输入都能终止。然而，由于 Coq 的「递减分析」不是非常精致，\n    因此有时必须用一点不同寻常的方式来编写函数。 *)",
    "votes": 0
  },
  {
    "id": 207,
    "src": "(* GRADE_THEOREM 1: zero_nbeq_plus_1 *)",
    "dst": "(* GRADE_THEOREM 1: zero_nbeq_plus_1 *)",
    "votes": 0
  },
  {
    "id": 208,
    "src": "(* EX1 (zero_nbeq_plus_1) *)",
    "dst": "(* EX1 (zero_nbeq_plus_1) *)",
    "votes": 0
  },
  {
    "id": 209,
    "src": "(* GRADE_THEOREM 2: andb_true_elim2 *)",
    "dst": "(* GRADE_THEOREM 2: andb_true_elim2 *)",
    "votes": 0
  },
  {
    "id": 210,
    "src": "(* EX2 (andb_true_elim2) *)",
    "dst": "(* EX2 (andb_true_elim2) *)",
    "votes": 0
  },
  {
    "id": 211,
    "src": "(* GRADE_THEOREM 2: mult_1_plus *)",
    "dst": "(* GRADE_THEOREM 2: mult_1_plus *)",
    "votes": 0
  },
  {
    "id": 212,
    "src": "(*rewrite -> plus_1_l.*)",
    "dst": "(*rewrite -> plus_1_l.*)",
    "votes": 0
  },
  {
    "id": 213,
    "src": "(* EX2 (mult_1_plus) *)",
    "dst": "(* EX2 (mult_1_plus) *)",
    "votes": 0
  },
  {
    "id": 214,
    "src": "(* GRADE_THEOREM 2: mult_S_1 *)",
    "dst": "(* GRADE_THEOREM 2: mult_S_1 *)",
    "votes": 0
  },
  {
    "id": 215,
    "src": "(* EX2 (mult_S_1) *)",
    "dst": "(* EX2 (mult_S_1) *)",
    "votes": 0
  },
  {
    "id": 216,
    "src": "(* GRADE_THEOREM 1: plus_id_exercise *)",
    "dst": "(* GRADE_THEOREM 1: plus_id_exercise *)",
    "votes": 0
  },
  {
    "id": 217,
    "src": "(** FULL: The first line of the proof moves the universally quantified\n    variables [n] and [m] into the context.  The second moves the\n    hypothesis [n = m] into the context and gives it the name [H].\n    The third tells Coq to rewrite the current goal ([n + n = m + m])\n    by replacing the left side of the equality hypothesis [H] with the\n    right side.\n\n    (The arrow symbol in the [rewrite] has nothing to do with\n    implication: it tells Coq to apply the rewrite from left to right.\n    To rewrite from right to left, you can use [rewrite <-].  Try\n    making this change in the above proof and see what difference it\n    makes.) *)",
    "dst": "(** FULL: 证明的第一行将全称量词变量 [n] 和 [m] 移动到上下文中。第二行将前提\n    [n = m] 移动到上下文中，并将其（随意）命名为 [H]。第三行告诉 Coq\n    改写当前目标（[n + n = m + m]），把前提等式 [H] 的左边替换成右边。\n    ([rewrite] 里的箭头与蕴含无关：它指示 Coq ���左往右地应用改写。\n    若要从右往左改写，可以使用 [rewrite <-]。在上面的证明里试一试这种改变，\n    看看 Coq 的反应有何变化。) *)",
    "votes": 0
  },
  {
    "id": 218,
    "src": "(** FULL: The first line of the proof moves the universally quantified\n    variables [n] and [m] into the context.  The second moves the\n    hypothesis [n = m] into the context and gives it the name [H].\n    The third tells Coq to rewrite the current goal ([n + n = m + m])\n    by replacing the left side of the equality hypothesis [H] with the\n    right side.\n\n    (The arrow symbol in the [rewrite] has nothing to do with\n    implication: it tells Coq to apply the rewrite from left to right.\n    To rewrite from right to left, you can use [rewrite <-].  Try\n    making this change in the above proof and see what difference it\n    makes.) *)",
    "dst": "(** FULL: 证明的第一行将全称量词变量 [n] 和 [m] 移动到上下文中。第二行将前提\n    [n = m] 移动到上下文中，并将其（随意）命名为 [H]。第三行告诉 Coq\n    改写当前目标（[n + n = m + m]），把前提等式 [H] 的左边替换成右边。\n    ([rewrite] 里的箭头与蕴含无关：它指示 Coq ���左往右地应用改写。\n    若要从右往左改写，可以使用 [rewrite <-]。在上面的证明里试一试这种改变，\n    看看 Coq 的反应有何变化。) *)",
    "votes": 0
  },
  {
    "id": 219,
    "src": "(** FULL: The first line of the proof moves the universally quantified\n    variables [n] and [m] into the context.  The second moves the\n    hypothesis [n = m] into the context and gives it the name [H].\n    The third tells Coq to rewrite the current goal ([n + n = m + m])\n    by replacing the left side of the equality hypothesis [H] with the\n    right side.\n\n    (The arrow symbol in the [rewrite] has nothing to do with\n    implication: it tells Coq to apply the rewrite from left to right.\n    To rewrite from right to left, you can use [rewrite <-].  Try\n    making this change in the above proof and see what difference it\n    makes.) *)",
    "dst": "(** FULL: 证明的第一行将全称量词变量 [n] 和 [m] 移动到上下文中。第二行将前提\n    [n = m] 移动到上下文中，并将其（随意）命名为 [H]。第三行告诉 Coq\n    改写当前目标（[n + n = m + m]），把前提等式 [H] 的左边替换成右边。\n    ([rewrite] 里的箭头与蕴含无关：它指示 Coq ���左往右地应用改写。\n    若要从右往左改写，可以使用 [rewrite <-]。在上面的证明里试一试这种改变，\n    看看 Coq 的反应有何变化。) *)",
    "votes": 0
  },
  {
    "id": 220,
    "src": "(** TERSE: *** *)",
    "dst": "(** TERSE: *** *)",
    "votes": 0
  },
  {
    "id": 221,
    "src": "(* EX1 (nandb) *)",
    "dst": "(* EX1 (nandb) *)",
    "votes": 0
  },
  {
    "id": 222,
    "src": "(* GRADE_THEOREM 1: test_nandb4 *)",
    "dst": "(* GRADE_THEOREM 1: test_nandb4 *)",
    "votes": 0
  },
  {
    "id": 223,
    "src": "(* EX1 (andb3) *)",
    "dst": "(* EX1 (andb3) *)",
    "votes": 0
  },
  {
    "id": 224,
    "src": "(* GRADE_THEOREM 1: test_andb34 *)",
    "dst": "(* GRADE_THEOREM 1: test_andb34 *)",
    "votes": 0
  },
  {
    "id": 225,
    "src": "(* ===> negb : bool -> bool *)",
    "dst": "(* ===> negb : bool -> bool *)",
    "votes": 0
  },
  {
    "id": 226,
    "src": "(** * Induction: Proof by Induction *)",
    "dst": "(** * 归纳法：用归纳法证明 *)",
    "votes": 0
  },
  {
    "id": 227,
    "src": "(* TERSE *)",
    "dst": "(* TERSE *)",
    "votes": 0
  },
  {
    "id": 228,
    "src": "(** * Review *)",
    "dst": "(** * 复习 *)",
    "votes": 0
  },
  {
    "id": 229,
    "src": "(** To prove the following theorem, which tactics will we need besides\n    [intros] and [reflexivity]?  (1) none (2) [rewrite], (3)\n    [destruct], (4) both [rewrite] and [destruct], or (5) can't be\n    done with the tactics we've seen.\n[[\n    Theorem review1: (orb true false) = true.\n]]\n*)",
    "dst": "(** 为了证明以下定理，除 [intros] 和 [reflexivity] 外我们还需要什么策略？\n    (1) 不需要，(2) [rewrite]，(3) [destruct]，(4) [rewrite] 和 [destruct]，\n    (5) 用已学过的策略尚无法做到。\n[[\n    Theorem review1: (orb true false) = true.\n]]\n*)",
    "votes": 0
  },
  {
    "id": 230,
    "src": "(* /QUIZ *)",
    "dst": "(* /QUIZ *)",
    "votes": 0
  },
  {
    "id": 231,
    "src": "(* QUIZ *)",
    "dst": "(* QUIZ *)",
    "votes": 0
  },
  {
    "id": 232,
    "src": "(** What about the next one?\n[[\n    Theorem review2: forall b, (orb true b) = true.\n]]\n    Which tactics do we need besides [intros] and [reflexivity]?  (1)\n    none (2) [rewrite], (3) [destruct], (4) both [rewrite] and\n    [destruct], or (5) can't be done with the tactics we've seen.\n*)",
    "dst": "(** 这个呢？\n[[\n    Theorem review2: forall b, (orb true b) = true.\n]]\n    除 [intros] 和 [reflexivity] 外我们还需要什么策略？\n    (1) 不需要，(2) [rewrite]，(3) [destruct]，(4) [rewrite] 和 [destruct]，\n    (5) 用已学过的策略尚无法做到。\n*)",
    "votes": 0
  },
  {
    "id": 233,
    "src": "(** What if we change the order of the arguments of [orb]?\n[[\n    Theorem review3: forall b, (orb b true) = true.\n]]\n    Which tactics do we need besides [intros] and [reflexivity]?  (1)\n    none (2) [rewrite], (3) [destruct], (4) both [rewrite] and\n    [destruct], or (5) can't be done with the tactics we've seen.\n*)",
    "dst": "(** 如果我们改变 [orb] 的参数顺序呢?\n[[\n    Theorem review3: forall b, (orb b true) = true.\n]]\n    除 [intros] 和 [reflexivity] 外我们还需要什么策略？\n    (1) 不需要，(2) [rewrite]，(3) [destruct]，(4) [rewrite] 和 [destruct]，\n    (5) 用已学过的策略尚无法做到。\n*)",
    "votes": 0
  },
  {
    "id": 234,
    "src": "(** What about this one?\n[[\n    Theorem review4 : forall n : nat, 0 + n = n.\n]]\n    (1) none (2) [rewrite], (3) [destruct], (4) both [rewrite] and\n    [destruct], or (5) can't be done with the tactics we've seen.\n*)",
    "dst": "(** 这个呢？\n[[\n    Theorem review4 : forall n : nat, 0 + n = n.\n]]\n    (1) 不需要，(2) [rewrite]，(3) [destruct]，(4) [rewrite] 和 [destruct]，\n    (5) 用已学过的策略尚无法做到。\n*)",
    "votes": 0
  },
  {
    "id": 235,
    "src": "(** What about this?\n[[\n    Theorem review5 : forall n : nat, n + 0 = n.\n]]\n    (1) none (2) [rewrite], (3) [destruct], (4) both [rewrite] and\n    [destruct], or (5) can't be done with the tactics we've seen.\n*)",
    "dst": "(** 这个呢？\n[[\n    Theorem review5 : forall n : nat, n + 0 = n.\n]]\n    (1) 不需要，(2) [rewrite]，(3) [destruct]，(4) [rewrite] 和 [destruct]，\n    (5) 用已学过的策略尚无法做到。\n*)",
    "votes": 0
  },
  {
    "id": 236,
    "src": "(** * Separate Compilation *)",
    "dst": "(** * 单独编译 *)",
    "votes": 0
  },
  {
    "id": 237,
    "src": "(** TERSE: Use [coqc] from the command line or [Compile Buffer] from\n    [CoqIDE] to compile [Basics.v] into [Basics.vo] so it can be\n    imported here... *)",
    "dst": "(** TERSE: 在命令行中用 [coqc] 或在 [CoqIDE] 中用 [Compile Buffer] 将  [Basics.v]\n    编译成 [Basics.vo] 以便导入到此处... *)",
    "votes": 0
  },
  {
    "id": 238,
    "src": "(** FULL: Before getting started, we need to import all of our\n    definitions from the previous chapter: *)",
    "dst": "(** FULL: 在开始之前，我们需要把上一章中所有的定义都导入进来： *)",
    "votes": 0
  },
  {
    "id": 239,
    "src": "(** FULL: For the [Require Export] to work, you first need to use\n    [coqc] to compile [Basics.v] into [Basics.vo].  This is like\n    making a .class file from a .java file, or a .o file from a .c\n    file.  There are two ways to do it:\n\n     - In CoqIDE:\n\n         Open [Basics.v].  In the \"Compile\" menu, click on \"Compile\n         Buffer\".\n\n     - From the command line:\n\n         [coqc Basics.v]\n\n   If you have trouble (e.g., if you get complaints about missing\n   identifiers later in the file), it may be because the \"load path\"\n   for Coq is not set up correctly.  The [Print LoadPath.] command may\n   be helpful in sorting out such issues. *)",
    "dst": "(** FULL: 为了让 [Require Export] 起效，首先你需要用 [coqc] 将 [Basics.v] 编译成\n    [Basics.vo]，这类似于将 .java 文件编译成 .class 文件，或将 .c 文件编译成 .o\n    文件。我们有两种方法：\n     - 在 CoqIDE 中：\n         打开 [Basics.v]。在「Compile」菜单中点击「Compile Buffer」。\n     - 在命令行中：\n         执行 [coqc Basics.v]\n   如果你遇到了问题（例如，稍后你可能会在本文件中遇到缺少标识符的提示），\n   那可能是因为没有正确设置 Coq 的「加载路径」。命令 [Print LoadPath.]\n   能帮你理清这类问题。 *)",
    "votes": 0
  },
  {
    "id": 240,
    "src": "(** * Proof by Induction *)",
    "dst": "(** * 归纳法证明 *)",
    "votes": 0
  },
  {
    "id": 241,
    "src": "(** FULL: We proved in the last chapter that [0] is a neutral element\n    for [+] on the left, using an easy argument based on\n    simplification.  We also observed that proving the fact that it is\n    also a neutral element on the _right_... *)",
    "dst": "(** FULL: 我们在上一章中用一个基于化简的简单论据证明了 [0] 是 [+] 的左幺元。\n    我们也观察到，当我们打算证明 [0] 也是 [+] 的 _右_ 幺元时... *)",
    "votes": 0
  },
  {
    "id": 242,
    "src": "(** TERSE: We proved in the last chapter that [0] is a neutral element\n    for [+] on the left using just [reflexivity].  And we noted that\n    the proof that it is also a neutral element on the _right_ is\n    trickier... *)",
    "dst": "(** TERSE: 我们在上一章中只用 [reflexivity] 就证明了 [0] 是 [+] 的左幺元。\n    不过我们也注意到要证明它也是 _右_ 幺元的话会更棘手... *)",
    "votes": 0
  },
  {
    "id": 243,
    "src": "(** ... can't be done in the same simple way.  Just applying\n  [reflexivity] doesn't work, since the [n] in [n + 0] is an arbitrary\n  unknown number, so the [match] in the definition of [+] can't be\n  simplified.  *)",
    "dst": "(** ...事情就没这么简单了。只应用 [reflexivity] 的话不起作用，因为 [n + 0] 中的\n    [n] 是任意未知数，所以在 [+] 的定义中 [match] 无法被化简。  *)",
    "votes": 0
  },
  {
    "id": 244,
    "src": "(* Does nothing! *)",
    "dst": "(* 不起作用！ *)",
    "votes": 0
  },
  {
    "id": 245,
    "src": "(** And reasoning by cases using [destruct n] doesn't get us much\n    further: the branch of the case analysis where we assume [n = 0]\n    goes through fine, but in the branch where [n = S n'] for some [n'] we\n    get stuck in exactly the same way. *)",
    "dst": "(** 即便用 [destruct n] 分类讨论也不会有所改善：诚然，我们能够轻易地证明 [n = 0]\n    时的情况；但在证明对于某些 [n'] 而言 [n = S n'] 时，我们又会遇到与此前相同的问题。 *)",
    "votes": 0
  },
  {
    "id": 246,
    "src": "(* n = 0 *)",
    "dst": "(* n = 0 *)",
    "votes": 0
  },
  {
    "id": 247,
    "src": "(* so far so good... *)",
    "dst": "(* 虽然目前还没啥问题... *)",
    "votes": 0
  },
  {
    "id": 248,
    "src": "(* n = S n' *)",
    "dst": "(* n = S n' *)",
    "votes": 0
  },
  {
    "id": 249,
    "src": "(* ...but here we are stuck again *)",
    "dst": "(* ...不过我们又卡在这儿了 *)",
    "votes": 0
  },
  {
    "id": 250,
    "src": "(** FULL: We could use [destruct n'] to get one step further, but,\n    since [n] can be arbitrarily large, if we just go on like this\n    we'll never finish. *)",
    "dst": "(** FULL: 虽然还可以用 [destruct n'] 再推进一步，但由于 [n] 可以任意大，\n    如果照这个思路继续证明的话，我们永远也证不完。 *)",
    "votes": 0
  },
  {
    "id": 251,
    "src": "(** FULL: To prove interesting facts about numbers, lists, and other\n    inductively defined sets, we usually need a more powerful\n    reasoning principle: _induction_.\n\n    Recall (from high school, a discrete math course, etc.) the\n    _principle of induction over natural numbers_: If [P(n)] is some\n    proposition involving a natural number [n] and we want to show\n    that [P] holds for all numbers [n], we can reason like this:\n         - show that [P(O)] holds;\n         - show that, for any [n'], if [P(n')] holds, then so does\n           [P(S n')];\n         - conclude that [P(n)] holds for all [n].\n\n    In Coq, the steps are the same: we begin with the goal of proving\n    [P(n)] for all [n] and break it down (by applying the [induction]\n    tactic) into two separate subgoals: one where we must show [P(O)]\n    and another where we must show [P(n') -> P(S n')].  Here's how\n    this works for the theorem at hand: *)",
    "dst": "(** FULL: 为了证明这种关于数字、列表等归纳定���的集合的有趣事实，\n    我们通常需要一个更强大的推理原理：_归纳_。\n    回忆一下_自然数的归纳原理_，你也许曾在高中的数学课上，在某门离散数学课上或\n    在其它类似的课上学到过它：若 [P(n)] 为涉及自然数的命题，而我们想要证明 [P]\n    对于所有自然数 [n] 都成立，那么可以这样推理：\n         - 证明 [P(O)] 成立；\n         - 证明对于任何 [n']，若 [P(n')] 成立，那么 [P(S n')] 也成立。\n         - 最后得出 [P(n)] 对于所有 [n] 都成立的结论。\n    在 Coq 中的过程也一样：我们以证明 [P(n)] 对于所有 [n] 都成立的证明目标开始，\n    然后（通过应用 [induction] 策略）把它分为两个子目标：一个是我们必须证明\n    [P(O)] 成立，另一个是我们必须证明 [P(n') -> P(S n')]。下面就是该定理的用法： *)",
    "votes": 0
  },
  {
    "id": 252,
    "src": "(** TERSE: We need a bigger hammer: the _principle of induction_ over\n    natural numbers...\n\n      - If [P(n)] is some proposition involving a natural number [n],\n        and we want to show that [P] holds for _all_ numbers, we can\n        reason like this:\n\n         - show that [P(O)] holds\n         - show that, if [P(n')] holds, then so does [P(S n')]\n         - conclude that [P(n)] holds for all [n].\n\n    For example... *)",
    "dst": "(** TERSE: 我们得换个更带劲儿的：自然数的_归纳原理_...\n      - 若 [P(n)] 是某个涉及自然数 [n] 的命题，而我们想要证明 [P] 对于_所有_\n      自然数都成立，我们可以这样推理：\n         - 证明 [P(O)] 成立\n         - 证明若 [P(n')] 成立，则 [P(S n')] 也成立\n         - 最后得出 [P(n)] 对于所有 [n] 都成立的结论。\n    例如... *)",
    "votes": 0
  },
  {
    "id": 253,
    "src": "(* n = 0 *)",
    "dst": "(* n = 0 *)",
    "votes": 0
  },
  {
    "id": 254,
    "src": "(* n = S n' *)",
    "dst": "(* n = S n' *)",
    "votes": 0
  },
  {
    "id": 255,
    "src": "(** FULL: Like [destruct], the [induction] tactic takes an [as...]\n    clause that specifies the names of the variables to be introduced\n    in the subgoals.  Since there are two subgoals, the [as...] clause\n    has two parts, separated by [|].  (Strictly speaking, we can omit\n    the [as...] clause and Coq will choose names for us.  In practice,\n    this is a bad idea, as Coq's automatic choices tend to be\n    confusing.)\n\n    In the first subgoal, [n] is replaced by [0].  No new variables\n    are introduced (so the first part of the [as...] is empty), and\n    the goal becomes [0 + 0 = 0], which follows by simplification.\n\n    In the second subgoal, [n] is replaced by [S n'], and the\n    assumption [n' + 0 = n'] is added to the context with the name\n    [IHn'] (i.e., the Induction Hypothesis for [n']).  These two names\n    are specified in the second part of the [as...] clause.  The goal\n    in this case becomes [(S n') + 0 = S n'], which simplifies to\n    [S (n' + 0) = S n'], which in turn follows from [IHn']. *)",
    "dst": "(** FULL: 和 [destruct] 一样，[induction] 策略也能通过 [as...] 子句为引入到\n    子目标中的变量指定名字。由于这次有两个子目标，因此 [as...] 有两部分，用 [|]\n    隔开。（严格来说，我们可以忽略 [as...] 子句，Coq 会为它们选择名字。\n    然而在实践中这样不好，因为让 Coq 自行选择名字的话更容易导致理解上的困难。）\n    在第一个子目标中 [n] 被 [0] 取代。由于没有新的变量会被引入，因此 [as ...]\n    字句的第一部分为空；而当前的目标会变成 [0 + 0 = 0]：使用化简就能得到此结论。\n    在第二个子目标中，[n] 被 [S n'] 所取代，而对 [n'] 的归纳假设（Inductive\n    Hypothesis），即 [n' + 0 = n'] 则以 [IHn'] 为名被添加到了上下文中。\n    这两个名字在 [as...] 子句的第二部分中指定。在此上下文中，待证目标变成了\n    [(S n') + 0 = S n']；它可被化简为 [S (n' + 0) = S n']，而此结论可通过\n    [IHn'] 得出。 *)",
    "votes": 0
  },
  {
    "id": 256,
    "src": "(** TERSE: Let's try this one together: *)",
    "dst": "(** TERSE: 我们再试一个： *)",
    "votes": 0
  },
  {
    "id": 257,
    "src": "(* WORKINCLASS *)",
    "dst": "(* WORKINCLASS *)",
    "votes": 0
  },
  {
    "id": 258,
    "src": "(* n = 0 *)",
    "dst": "(* n = 0 *)",
    "votes": 0
  },
  {
    "id": 259,
    "src": "(* /WORKINCLASS *)",
    "dst": "(* /WORKINCLASS *)",
    "votes": 0
  },
  {
    "id": 260,
    "src": "(** FULL: (The use of the [intros] tactic in these proofs is actually\n    redundant.  When applied to a goal that contains quantified\n    variables, the [induction] tactic will automatically move them\n    into the context as needed.) *)",
    "dst": "(** FULL: （其实在这些证明中我们并不需要 [intros]：当 [induction] 策略被应用到\n    包含量化变量的目标中时，它会自动将需要的变量移到上下文中。） *)",
    "votes": 0
  },
  {
    "id": 261,
    "src": "(* EX2! (basic_induction) *)",
    "dst": "(* EX2! (basic_induction) *)",
    "votes": 0
  },
  {
    "id": 262,
    "src": "(** Prove the following using induction. You might need previously\n    proven results. *)",
    "dst": "(** 用归纳法证明以下命题。你可能需要之前的证明结果。 *)",
    "votes": 0
  },
  {
    "id": 263,
    "src": "(* GRADE_THEOREM 1: mult_0_r *)",
    "dst": "(* GRADE_THEOREM 1: mult_0_r *)",
    "votes": 0
  },
  {
    "id": 264,
    "src": "(* GRADE_THEOREM 1: plus_n_Sm *)",
    "dst": "(* GRADE_THEOREM 1: plus_n_Sm *)",
    "votes": 0
  },
  {
    "id": 265,
    "src": "(** TERSE: Another fact, which we'll need below.  (The proof is left\n    as an exercise.) *)",
    "dst": "(** TERSE: 以下事实之后会用到；它的证明在这里留作练习。 *)",
    "votes": 0
  },
  {
    "id": 266,
    "src": "(* m = 0 *)",
    "dst": "(* m = 0 *)",
    "votes": 0
  },
  {
    "id": 267,
    "src": "(* m = S m' *)",
    "dst": "(* m = S m' *)",
    "votes": 0
  },
  {
    "id": 268,
    "src": "(* GRADE_THEOREM 1: plus_comm *)",
    "dst": "(* GRADE_THEOREM 1: plus_comm *)",
    "votes": 0
  },
  {
    "id": 269,
    "src": "(* GRADE_THEOREM 1: plus_assoc *)",
    "dst": "(* GRADE_THEOREM 1: plus_assoc *)",
    "votes": 0
  },
  {
    "id": 270,
    "src": "(* EX2 (double_plus) *)",
    "dst": "(* EX2 (double_plus) *)",
    "votes": 0
  },
  {
    "id": 271,
    "src": "(** Consider the following function, which doubles its argument: *)",
    "dst": "(** 考虑以下函数，它将其参数乘二： *)",
    "votes": 0
  },
  {
    "id": 272,
    "src": "(** Use induction to prove this simple fact about [double]: *)",
    "dst": "(** 用归纳法证明以下关于 [double] 的简单事实： *)",
    "votes": 0
  },
  {
    "id": 273,
    "src": "(* GRADE_THEOREM 1: double_plus *)",
    "dst": "(* GRADE_THEOREM 1: double_plus *)",
    "votes": 0
  },
  {
    "id": 274,
    "src": "(* EX2? (evenb_S) *)",
    "dst": "(* EX2? (evenb_S) *)",
    "votes": 0
  },
  {
    "id": 275,
    "src": "(** One inconveninent aspect of our definition of [evenb n] is the\n    recursive call on [n - 2]. This makes proofs about [evenb n]\n    harder when done by induction on [n], since we may need an\n    induction hypothesis about [n - 2]. The following lemma gives an\n    alternative characterization of [evenb (S n)] that works better\n    with induction: *)",
    "dst": "(** 我们的 [evenb n] 定义对 [n - 2] 的递归调用不大方便。这让证明 [evenb n]\n    时更难对 [n] 进行归纳，因此我们需要一个关于 [n - 2] 的归纳假设。\n    以下引理给予了 [evenb (S n)] 另一个表征，使其在归纳时能够更好地工作：\n    我们对 [evenb n] 的定义有一点不太方便的地方：它以 [n - 2] 为参数进行了递归调用；\n    在为了证明与 [evenb n] 有关的事实而对 [n] 使用归纳法时，这会让证明过程变得更为困难，\n    因为我们可能会需要一个关于 [n - 2] 的归纳假设。以下引理用一种不同的方式刻画了\n    [evenb (S n)] 的性质，这将使归纳过程变得更加容易。 *)",
    "votes": 0
  },
  {
    "id": 276,
    "src": "(* GRADE_THEOREM 1: evenb_S *)",
    "dst": "(* GRADE_THEOREM 1: evenb_S *)",
    "votes": 0
  },
  {
    "id": 277,
    "src": "(* EX1M (destruct_induction) *)",
    "dst": "(* EX1M (destruct_induction) *)",
    "votes": 0
  },
  {
    "id": 278,
    "src": "(** Briefly explain the difference between the tactics [destruct]\n    and [induction].\n\n(* SOLUTION *)\n   Both are used to perform case analysis on an element of an\n   inductively defined type; [induction] also generates an induction\n   hypothesis, while [destruct] does not.\n(* /SOLUTION *)\n*)",
    "dst": "(** 简要说明一下 [destruct] 策略和 [induction] 策略之间的区别。\n(* SOLUTION *)\n   二者都用来对归纳定义类型的元素进行分类讨论；[induction] 还会生成一个归纳假设，而 [destruct] 则不会。\n(* /SOLUTION *)\n*)",
    "votes": 0
  },
  {
    "id": 279,
    "src": "(* GRADE_MANUAL 1: destruct_induction *)",
    "dst": "(* GRADE_MANUAL 1: destruct_induction *)",
    "votes": 0
  },
  {
    "id": 280,
    "src": "(** We've seen that there are goals that [destruct] can't solve but\n    [induction] can. What about the other way around? Are there steps\n    in a proof that can be solved by pure case analysis ([destruct])\n    but not using [induction]?\n\n    (1) No\n\n    (2) Yes\n*)",
    "dst": "(** 我们已经见过 [destruct] 无法解决而 [induction] 可以解决的目标了。\n    如果反过来，是否存在只能通过纯分类讨论（[destruct]）而无法用 [induction]\n    完成的证明的步骤？\n    (1) 否\n    (2) 是\n*)",
    "votes": 0
  },
  {
    "id": 281,
    "src": "(** * Proofs Within Proofs *)",
    "dst": "(** * 证明里的证明 *)",
    "votes": 0
  },
  {
    "id": 282,
    "src": "(** FULL: In Coq, as in informal mathematics, large proofs are often\n    broken into a sequence of theorems, with later proofs referring to\n    earlier theorems.  But sometimes a proof will require some\n    miscellaneous fact that is too trivial and of too little general\n    interest to bother giving it its own top-level name.  In such\n    cases, it is convenient to be able to simply state and prove the\n    needed \"sub-theorem\" right at the point where it is used.  The\n    [assert] tactic allows us to do this.  For example, our earlier\n    proof of the [mult_0_plus] theorem referred to a previous theorem\n    named [plus_O_n].  We could instead use [assert] to state and\n    prove [plus_O_n] in-line: *)",
    "dst": "(** FULL: 和在非形式化的数学中一样，在 Coq 中，大的证明通常会被分为一系列定理，\n    后面的定理引用之前的定理。但有时一个证明会需要一些繁杂琐碎的事实，\n    而这些事实缺乏普遍性，以至于我们甚至都不应该给它们单独取顶级的名字。\n    此时，如果能仅在需要时简单地陈述并立即证明所需的「子定理」就会很方便。\n    我们可以用 [assert] 策略来做到。例如，我们之前对 [mult_0_plus]\n    定理的证明引用了前一个名为 [plus_O_n] 的定理，而我们只需内联使用 [assert]\n    就能陈述并证明 [plus_O_n]： *)",
    "votes": 0
  },
  {
    "id": 283,
    "src": "(** TERSE: Here's an alternate proof of [mult_0_plus], using an in-line\n    assertion instead of a separate lemma.  New tactic: [assert]. *)",
    "dst": "(** TERSE: 以下是 [mult_0_plus] 的另一个证明，用内联断言代替了独立的引理。\n    新策略：[assert] *)",
    "votes": 0
  },
  {
    "id": 284,
    "src": "(** FULL: The [assert] tactic introduces two sub-goals.  The first is\n    the assertion itself; by prefixing it with [H:] we name the\n    assertion [H].  (We can also name the assertion with [as] just as\n    we did above with [destruct] and [induction], i.e., [assert (0 + n\n    = n) as H].)  Note that we surround the proof of this assertion\n    with curly braces [{ ... }], both for readability and so that,\n    when using Coq interactively, we can see more easily when we have\n    finished this sub-proof.  The second goal is the same as the one\n    at the point where we invoke [assert] except that, in the context,\n    we now have the assumption [H] that [0 + n = n].  That is,\n    [assert] generates one subgoal where we must prove the asserted\n    fact and a second subgoal where we can use the asserted fact to\n    make progress on whatever we were trying to prove in the first\n    place. *)",
    "dst": "(** FULL: [assert] 策略引入两个子目标。第一个为断言本身，通过给它加前缀 [H:]\n    我们将该断言命名为 [H]。（我们也可以用 [as] 来命名该断言，就像我们前面用\n    [destruct] 和 [induction] 做的那样。例如 [assert (0 + n = n) as H]。）\n    注意我们用花括号 [{ ... }] 将该断言的证明括了起来。这么做不仅是为了提高可读性，\n    同时也为了在交互地使用 Coq 时能更容易地看到我们已经证明了这个子目标。第二个目标\n    跟执行 [assert] 之前的子目标一样，只是这次在上下文中，我们有了名为 [H] 的前提\n    [0 + n = n]。也就是说，[assert] 生成的第一个子目标是我们必须证明的已断言的事实，\n    而在第二个子目标中，我们可以使用已断言的事实在一开始试图证明的事情上取得进展。 *)",
    "votes": 0
  },
  {
    "id": 285,
    "src": "(** Another example of [assert]... *)",
    "dst": "(** 另一个 [assert] 的例子... *)",
    "votes": 0
  },
  {
    "id": 286,
    "src": "(** FULL: For example, suppose we want to prove that [(n + m) + (p + q)\n    = (m + n) + (p + q)]. The only difference between the two sides of\n    the [=] is that the arguments [m] and [n] to the first inner [+]\n    are swapped, so it seems we should be able to use the\n    commutativity of addition ([plus_comm]) to rewrite one into the\n    other.  However, the [rewrite] tactic is not very smart about\n    _where_ it applies the rewrite.  There are three uses of [+] here,\n    and it turns out that doing [rewrite -> plus_comm] will affect\n    only the _outer_ one... *)",
    "dst": "(** FULL: 例如，假设我们想要证明 [(n + m) + (p + q) = (m + n) + (p + q)]。\n    [=] 两边唯一的不同就是第一个内部的 [+] 的参数 [m] 和 [n] 交换了位置，\n    所以看起来我们可以用加法交换律（[plus_comm]）来将它重写为另一个。然而，\n    [rewrite] 策略对于应该在_哪里_起作用这点一并不聪明。本命题中 [+] 用了三次 ，\n    结果 [rewrite -> plus_comm] 只对_外层_那个起了作用... *)",
    "votes": 0
  },
  {
    "id": 287,
    "src": "(* We just need to swap (n + m) for (m + n)... seems\n     like plus_comm should do the trick! *)",
    "dst": "(* 我们只需要为 (m + n) 交换 (n + m)... 看起来 plus_comm 能搞定！*)",
    "votes": 0
  },
  {
    "id": 288,
    "src": "(* Doesn't work...Coq rewrote the wrong plus! *)",
    "dst": "(* 不起作用... Coq 选错了要改写的加法！ *)",
    "votes": 0
  },
  {
    "id": 289,
    "src": "(** To use [plus_comm] at the point where we need it, we can introduce\n    a local lemma stating that [n + m = m + n] (for the particular [m]\n    and [n] that we are talking about here), prove this lemma using\n    [plus_comm], and then use it to do the desired rewrite. *)",
    "dst": "(** 为了在需要的地方使用 [plus_comm]，我们可以（为此处讨论的特定的 [m] 和 [n]）\n    引入一个局部引理来陈述 [n + m = m + n]，然后我们用 [plus_comm] 证明它，\n    并用它来进行期望的改写。 *)",
    "votes": 0
  },
  {
    "id": 290,
    "src": "(** #<div class=\"quote\">#\"_Informal proofs are algorithms; formal proofs are code_.\"#</div># *)",
    "dst": "(** #<div class=\"quote\">#「非形式化证明是算法，形式化证明是代码。」#</div># *)",
    "votes": 0
  },
  {
    "id": 291,
    "src": "(** FULL: What constitutes a successful proof of a mathematical claim?\n    The question has challenged philosophers for millennia, but a\n    rough and ready definition could be this: A proof of a\n    mathematical proposition [P] is a written (or spoken) text that\n    instills in the reader or hearer the certainty that [P] is true --\n    an unassailable argument for the truth of [P].  That is, a proof\n    is an act of communication.\n\n    Acts of communication may involve different sorts of readers.  On\n    one hand, the \"reader\" can be a program like Coq, in which case\n    the \"belief\" that is instilled is that [P] can be mechanically\n    derived from a certain set of formal logical rules, and the proof\n    is a recipe that guides the program in checking this fact.  Such\n    recipes are _formal_ proofs.\n\n    Alternatively, the reader can be a human being, in which case the\n    proof will be written in English or some other natural language,\n    and will thus necessarily be _informal_.  Here, the criteria for\n    success are less clearly specified.  A \"valid\" proof is one that\n    makes the reader believe [P].  But the same proof may be read by\n    many different readers, some of whom may be convinced by a\n    particular way of phrasing the argument, while others may not be.\n    Some readers may be particularly pedantic, inexperienced, or just\n    plain thick-headed; the only way to convince them will be to make\n    the argument in painstaking detail.  But other readers, more\n    familiar in the area, may find all this detail so overwhelming\n    that they lose the overall thread; all they want is to be told the\n    main ideas, since it is easier for them to fill in the details for\n    themselves than to wade through a written presentation of them.\n    Ultimately, there is no universal standard, because there is no\n    single way of writing an informal proof that is guaranteed to\n    convince every conceivable reader.\n\n    In practice, however, mathematicians have developed a rich set of\n    conventions and idioms for writing about complex mathematical\n    objects that -- at least within a certain community -- make\n    communication fairly reliable.  The conventions of this stylized\n    form of communication give a fairly clear standard for judging\n    proofs good or bad.\n\n    Because we are using Coq in this course, we will be working\n    heavily with formal proofs.  But this doesn't mean we can\n    completely forget about informal ones!  Formal proofs are useful\n    in many ways, but they are _not_ very efficient ways of\n    communicating ideas between human beings. *)",
    "dst": "(** FULL: 对数学声明的一个成功证明应该由什么构成？这个问题已经困扰了哲学家数千年，\n    不过这儿有个还算凑合的定义：数学命题 [P] 的证明是一段书面（或口头）的文本，\n    它对 [P] 的真实性进行无可辩驳的论证，逐步说服读者或听者使其确信 [P] 为真。\n    也就是说，证明是一种交流行为。\n    TODO(osc): 重写这段翻译。\n    交流行为可能涉及不同类型的读者。一方面，「读者」可以是像 Coq 这样的程序，\n    这种情况下，灌输的「确信」是 [P] 能够从一个确定的，由形式化逻辑规则组成的\n    集合中的规则机械地推导出，而证明则是指导程序检查这一事实的方法。这种方法就是\n    _形式化_证明。\n    另一方面，读者也可以是人类，这种情况下证明可以用英语或其它自然语言写出，\n    因此必然是_非形式化_的，此时成功的标准不太明确。一个「有效的」证明是让读者\n    相信 [P]。但同一个证明可能被很多不同的读者阅读，其中一些人可能会被某种特定\n    的表述论证方式说服，而其他人可能不会。有些读者可能太过于钻牛角尖，也有可能\n    缺乏经验，或者只是单纯地过于愚钝；说服他们的唯一方法就是细致入微地进行论证。\n    不过更熟悉这一领域的读者可能会觉得所有细节都太过繁琐，让他们无法抓住\n    整体的思路；他们想要的不过是抓住主要思路，因为相对于事无巨细的描述而言，\n    让他们自行补充所需细节更为容易系。\n    总之，我们没有一个通用的标准，因为没有一种编写非形式化证明的方式能够说服\n    所能顾及的每一个读者。\n    然而在实践中，数学家们已经发展出了一套用于描述复杂数学对象的约定和惯用法，\n    这让交流（至少在一些特定的社区内）变得十分可靠。这种约定俗成的交流形式已然成风，\n    它为证明的好坏的给出了清晰的判断标准。\n    由于我们在本课程中使用 Coq，因此会重度使用形式化证明。但这并不意味着我们\n    可以完全忽略掉非形式化的证明过程！形式化证明在很多方面都非常有用，\n    不过它们对人类间的思想交流而言_并不_十分高效。 *)",
    "votes": 0
  },
  {
    "id": 292,
    "src": "(** FULL: For example, here is a proof that addition is associative: *)",
    "dst": "(** FULL: 例如，下面是加法交换律的一个证明： *)",
    "votes": 0
  },
  {
    "id": 293,
    "src": "(** TERSE: An unreadable formal proof: *)",
    "dst": "(** TERSE: 一个难读的形式化证明： *)",
    "votes": 0
  },
  {
    "id": 294,
    "src": "(** FULL: Coq is perfectly happy with this.  For a human, however, it\n    is difficult to make much sense of it.  We can use comments and\n    bullets to show the structure a little more clearly... *)",
    "dst": "(** FULL: Coq 对此表示十分满意。然而人类却很难理解它。我们可以用注释和标号让它\n    的结构看上去更清晰一点... *)",
    "votes": 0
  },
  {
    "id": 295,
    "src": "(** TERSE: Comments and bullets can make things a bit clearer... *)",
    "dst": "(** TERSE: 注释和标号能让它看上去更清晰... *)",
    "votes": 0
  },
  {
    "id": 296,
    "src": "(** FULL: ... and if you're used to Coq you may be able to step\n    through the tactics one after the other in your mind and imagine\n    the state of the context and goal stack at each point, but if the\n    proof were even a little bit more complicated this would be next\n    to impossible.\n\n    A (pedantic) mathematician might write the proof something like\n    this: *)",
    "dst": "(** FULL: ...而且如果你习惯了 Coq，你可能会在脑袋里逐步过一遍策略，并想象出\n    每一点的上下文和目标栈的状态。不过若证明再复杂一点，那就几乎不可能了。\n    一个（迂腐的）数学家可能把证明写成这样： *)",
    "votes": 0
  },
  {
    "id": 297,
    "src": "(** TERSE: ... but it's still nowhere near as readable for a human as\n    a careful informal proof: *)",
    "dst": "(** TERSE: ...不过它对人类来说，远不如一个认真的非形式化证明可读： *)",
    "votes": 0
  },
  {
    "id": 298,
    "src": "(** - _Theorem_: For any [n], [m] and [p],\n[[\n      n + (m + p) = (n + m) + p.\n]]\n    _Proof_: By induction on [n].\n\n    - First, suppose [n = 0].  We must show\n[[\n        0 + (m + p) = (0 + m) + p.\n]]\n      This follows directly from the definition of [+].\n\n    - Next, suppose [n = S n'], where\n[[\n        n' + (m + p) = (n' + m) + p.\n]]\n      We must show\n[[\n        (S n') + (m + p) = ((S n') + m) + p.\n]]\n      By the definition of [+], this follows from\n[[\n        S (n' + (m + p)) = S ((n' + m) + p),\n]]\n      which is immediate from the induction hypothesis.  _Qed_. *)",
    "dst": "(** - _定理_ ：对于任何 [n], [m] 和 [p],\n[[\n      n + (m + p) = (n + m) + p.\n]]\n    _证明_：对 [n] 使用归纳法。\n    - 首先，设 [n = 0]。我们必须证明\n[[\n        0 + (m + p) = (0 + m) + p.\n]]\n      此结论可从 [+] 的定义直接得到。\n    - 接着，设 [n = S n']，其中\n[[\n        n' + (m + p) = (n' + m) + p.\n]]\n      我们必须证明\n[[\n        (S n') + (m + p) = ((S n') + m) + p.\n]]\n      根据 [+] 的定义，由此式可得\n[[\n        S (n' + (m + p)) = S ((n' + m) + p),\n]]\n      它由归纳假设直接得出。  _证毕_ 。 *)",
    "votes": 0
  },
  {
    "id": 299,
    "src": "(** FULL: The overall form of the proof is basically similar, and of\n    course this is no accident: Coq has been designed so that its\n    [induction] tactic generates the same sub-goals, in the same\n    order, as the bullet points that a mathematician would write.  But\n    there are significant differences of detail: the formal proof is\n    much more explicit in some ways (e.g., the use of [reflexivity])\n    but much less explicit in others (in particular, the \"proof state\"\n    at any given point in the Coq proof is completely implicit,\n    whereas the informal proof reminds the reader several times where\n    things stand). *)",
    "dst": "(** FULL: 证明的总体形式大体类似，当然这并非偶然：Coq 的设计使其 [induction]\n    策略会像数学家写出的标号那样，按相同的顺序生成相同的子目标。但咱细节上则有\n    明显的不同：形式化证明在某些方面更为明确（例如对 [reflexivity] 的使用），\n    但在其它方面则不够明���（特别是 Coq 证明中任何给定点的「证明状态」都是完全\n    隐含的，而非形式化证明则常会反复告诉读者目前证明进行的状态）。 *)",
    "votes": 0
  },
  {
    "id": 300,
    "src": "(* EX2!AM (plus_comm_informal) *)",
    "dst": "(* EX2!AM (plus_comm_informal) *)",
    "votes": 0
  },
  {
    "id": 301,
    "src": "(** Translate your solution for [plus_comm] into an informal proof:\n\n    Theorem: Addition is commutative.\n\n    Proof: (* SOLUTION *)\n       Let natural numbers [n] and [m] be given.  We show [n + m = m +\n       n] by induction on [m].\n\n       - First, suppose [m = 0].  We must show [n + 0 = 0 + n].  By\n         the definition of [+], we know [0 + n = 0], and we have\n         already shown (lemma [plus_n_O]) that [n + 0 = 0].  Thus,\n         showing [n + 0 = 0 + n] is equivalent to showing [0 = 0],\n         which is true by reflexivity.\n\n       - Next, suppose [m = S m'] for some [m'], where [n + m'] = [m'\n         + n].  We must show that [n + (S m') = (S m') + n].  By the\n         definition of [+] and the induction hypothesis, [(S m') + n =\n         S (m' + n) = S (n + m')].  It remains to show [n + (S m') = S\n         (n + m')], which is precisely lemma [plus_n_Sm].\n(* /SOLUTION *)\n*)",
    "dst": "(** 将你对 [plus_comm] 的解答翻译成非形式化证明：\n    定理：加法满足交换律。\n    证明： (* SOLUTION *)\n       给定自然数 [n] 和 [m]。我们通过对 [m] 的归纳证明 [n + m = m + n]。\n       - 首先，设 [m = 0]。我们必须证明 [n + 0 = 0 + n]。根据 [+] 的定义，我们\n         知道 [0 + n = n]，并且我们已经证明了（引理 [plus_n_O]） [n + 0 = n]。\n         因此，证明 [n + 0 = 0 + n] 等价于证明 [n = n]，根据自反性，此为真。\n       - 之后，对于 [m']，设 [m = S m']，其中 [n + m'] = [m' + n]。我们必须证明\n         [n + (S m') = (S m') + n]。根据 [+] 的定义和归纳假设，[(S m') + n =\n         S (m' + n) = S (n + m')]。之后我们仍需证明 [n + (S m') = S (n + m')],\n         它正好就是引理 [plus_n_Sm]。\n(* /SOLUTION *)\n*)",
    "votes": 0
  },
  {
    "id": 302,
    "src": "(* GRADE_MANUAL 3: plus_comm_informal *)",
    "dst": "(* GRADE_MANUAL 3: plus_comm_informal *)",
    "votes": 0
  },
  {
    "id": 303,
    "src": "(* EX2?M (beq_nat_refl_informal) *)",
    "dst": "(* EX2?M (beq_nat_refl_informal) *)",
    "votes": 0
  },
  {
    "id": 304,
    "src": "(** Write an informal proof of the following theorem, using the\n    informal proof of [plus_assoc] as a model.  Don't just\n    paraphrase the Coq tactics into English!\n\n    Theorem: [true = beq_nat n n] for any [n].\n\n    Proof: (* SOLUTION *)\n       By induction on [n].\n\n       - First, suppose [n = 0].  We must show [true = beq_nat 0 0].  This\n         follows directly from the definition of [beq_nat].\n\n       - Next, suppose [n = S n'], where [true = beq_nat n' n'].  We\n         must show [true = beq_nat (S n') (S n')]. This\n         follows directly from the induction hypothesis and the\n         definition of [beq_nat].\n(* /SOLUTION *)\n[] *)",
    "dst": "(** 以 [plus_assoc] 的非形式化证明为范本，写出以下定理的非形式化证明。\n    不要只是用中文来解释 Coq 策略！\n    定理： 对于任何 [n]，均有 [true = beq_nat n n]。\n    证明 (* SOLUTION *)\n       对 [n] 进行归纳。\n       - 首先，设 [n = 0]。我们必须证明 [true = beq_nat 0 0]。\n         它可直接由 [beq_nat] 的定义得出。\n       - 之后，设 [n = S n']，其中 [true = beq_nat n' n']。我们必须证明\n         [true = beq_nat (S n') (S n')]。它可直接由归纳假设和 [beq_nat]\n         的定义得出。\n(* /SOLUTION *)\n[] *)",
    "votes": 0
  },
  {
    "id": 305,
    "src": "(* EX3! (mult_comm) *)",
    "dst": "(* EX3! (mult_comm) *)",
    "votes": 0
  },
  {
    "id": 306,
    "src": "(** Use [assert] to help prove this theorem.  You shouldn't need to\n    use induction on [plus_swap]. *)",
    "dst": "(** 用 [assert] 来帮助证明此定理。你应该不需要对 [plus_swap] 进行归纳。 *)",
    "votes": 0
  },
  {
    "id": 307,
    "src": "(** Now prove commutativity of multiplication.  (You will probably\n    need to define and prove a separate subsidiary theorem to be used\n    in the proof of this one.  You may find that [plus_swap] comes in\n    handy.) *)",
    "dst": "(** 现在证明乘法交换律。（你在证明过程中可能需要定义并证明一个独立的辅助定理。\n    你可能会用上 [plus_swap]。） *)",
    "votes": 0
  },
  {
    "id": 308,
    "src": "(* GRADE_THEOREM 3: mult_comm *)",
    "dst": "(* GRADE_THEOREM 3: mult_comm *)",
    "votes": 0
  },
  {
    "id": 309,
    "src": "(* EX3? (more_exercises) *)",
    "dst": "(* EX3? (more_exercises) *)",
    "votes": 0
  },
  {
    "id": 310,
    "src": "(** Take a piece of paper.  For each of the following theorems, first\n    _think_ about whether (a) it can be proved using only\n    simplification and rewriting, (b) it also requires case\n    analysis ([destruct]), or (c) it also requires induction.  Write\n    down your prediction.  Then fill in the proof.  (There is no need\n    to turn in your piece of paper; this is just to encourage you to\n    reflect before you hack!) *)",
    "dst": "(** 找一张纸。对于以下定理，首先请_思考_ (a) 它能否能只用化简和改写来证明，\n    (b) 它还需要分类讨论（[destruct]），以及 (c) 它还需要归纳证明。先写下你的\n    预判，然后填写下面的证明（你的纸不用交上来，这只是鼓励你先思考再行动！） *)",
    "votes": 0
  },
  {
    "id": 311,
    "src": "(* GRADE_THEOREM 1: leb_refl *)",
    "dst": "(* GRADE_THEOREM 1: leb_refl *)",
    "votes": 0
  },
  {
    "id": 312,
    "src": "(* p = 0 *)",
    "dst": "(* p = 0 *)",
    "votes": 0
  },
  {
    "id": 313,
    "src": "(* p = S p' *)",
    "dst": "(* p = S p' *)",
    "votes": 0
  },
  {
    "id": 314,
    "src": "(* GRADE_THEOREM 1: plus_ble_compat_l *)",
    "dst": "(* GRADE_THEOREM 1: plus_ble_compat_l *)",
    "votes": 0
  },
  {
    "id": 315,
    "src": "(* GRADE_THEOREM 1: mult_1_l *)",
    "dst": "(* GRADE_THEOREM 1: mult_1_l *)",
    "votes": 0
  },
  {
    "id": 316,
    "src": "(* GRADE_THEOREM 1: mult_assoc *)",
    "dst": "(* GRADE_THEOREM 1: mult_assoc *)",
    "votes": 0
  },
  {
    "id": 317,
    "src": "(* EX2? (beq_nat_refl) *)",
    "dst": "(* EX2? (beq_nat_refl) *)",
    "votes": 0
  },
  {
    "id": 318,
    "src": "(** Prove the following theorem.  (Putting the [true] on the left-hand\n    side of the equality may look odd, but this is how the theorem is\n    stated in the Coq standard library, so we follow suit.  Rewriting\n    works equally well in either direction, so we will have no problem\n    using the theorem no matter which way we state it.) *)",
    "dst": "(** 证明以下定理。（把 [true] 放在等式左边可能看起来有点奇怪，不过 Coq 标准库中\n    就是这样表示的，我们照做就是。无论按哪个方向改写都一样好用，所以无论我们如何\n    表示定理，用起来都没问题。） *)",
    "votes": 0
  },
  {
    "id": 319,
    "src": "(* HIDE:\n   Note: we might expect a similar property to hold on\n   UNequal [nat]'s:\n      Theorem beq_nat_n_n' : forall n n' : nat,\n           n <> n' ->\n           beq_nat n n' = false.\n   But it will be a while before we get to terms with what\n   [n <> n'] really means... *)",
    "dst": "(* HIDE:\n   注意：我们可能期望一个类似的特性来表示_不_相等的 [nat]：\n      Theorem beq_nat_n_n' : forall n n' : nat,\n           n <> n' ->\n           beq_nat n n' = false.\n   不过我们得过段时间才会讲到 [n <> n'] 这一项真正的意义... *)",
    "votes": 0
  },
  {
    "id": 320,
    "src": "(* GRADE_THEOREM 2: beq_nat_refl *)",
    "dst": "(* GRADE_THEOREM 2: beq_nat_refl *)",
    "votes": 0
  },
  {
    "id": 321,
    "src": "(* EX2? (plus_swap') *)",
    "dst": "(* EX2? (plus_swap') *)",
    "votes": 0
  },
  {
    "id": 322,
    "src": "(** The [replace] tactic allows you to specify a particular subterm to\n   rewrite and what you want it rewritten to: [replace (t) with (u)]\n   replaces (all copies of) expression [t] in the goal by expression\n   [u], and generates [t = u] as an additional subgoal. This is often\n   useful when a plain [rewrite] acts on the wrong part of the goal.\n\n   Use the [replace] tactic to do a proof of [plus_swap'], just like\n   [plus_swap] but without needing [assert (n + m = m + n)]. *)",
    "dst": "(** [replace] 策略允许你指定一个具体的要改写的子项和你想要将它改写成的项：\n    [replace (t) with (u)] 会将目标中表达式 [t]（的所有副本）替换为表达式 [u]，\n    并生成 [t = u] 作为附加的子目标。在简单的 [rewrite] 作用在目标错误的部分上时\n    这种做法通常很有用。\n   用 [replace] 策略来证明 [plus_swap']，除了无需 [assert (n + m = m + n)]\n   外和 [plus_swap] 一样。 *)",
    "votes": 0
  },
  {
    "id": 323,
    "src": "(* EX3!M (binary_commute) *)",
    "dst": "(* EX3!M (binary_commute) *)",
    "votes": 0
  },
  {
    "id": 324,
    "src": "(** Recall the [incr] and [bin_to_nat] functions that you\n    wrote for the [binary] exercise in the \\CHAP{Basics} chapter.  Prove\n    that the following diagram commutes:\n[[\n                            incr\n              bin ----------------------> bin\n               |                           |\n    bin_to_nat |                           |  bin_to_nat\n               |                           |\n               v                           v\n              nat ----------------------> nat\n                             S\n]]\n    That is, incrementing a binary number and then converting it to\n    a (unary) natural number yields the same result as first converting\n    it to a natural number and then incrementing.\n    Name your theorem [bin_to_nat_pres_incr] (\"pres\" for \"preserves\").\n\n    Before you start working on this exercise, copy the definitions\n    from your solution to the [binary] exercise here so that this file\n    can be graded on its own.  If you want to change your original\n    definitions to make the property easier to prove, feel free to\n    do so! *)",
    "dst": "(** 回忆一下你在 \\CHAP{Basics} 中为练习 [binary] 编写的 [incr] 和 [bin_to_nat]\n    函数。证明下图可交换。\n[[\n                            incr\n              bin ----------------------> bin\n               |                           |\n    bin_to_nat |                           |  bin_to_nat\n               |                           |\n               v                           v\n              nat ----------------------> nat\n                             S\n]]\n    也就是说，一个二进制数先自增然后将它转换为（一进制）自然数，和先将它转换为\n    自然数后再自增会产生相同的结果。将你的定理命名为 [bin_to_nat_pres_incr]\n    （「pres」即「preserves」的简写，意为「保持原状」）。\n    在你开始做这个练习前，将你在 [binary] 练习的解中的定义复制到这里，\n    让这个文件可以被单独评分。若你想要更改你的原始定义以便让此属性更易证明，\n    请自便！ *)",
    "votes": 0
  },
  {
    "id": 325,
    "src": "(* b = 0 *)",
    "dst": "(* b = 0 *)",
    "votes": 0
  },
  {
    "id": 326,
    "src": "(* b = 2*b' *)",
    "dst": "(* b = 2*b' *)",
    "votes": 0
  },
  {
    "id": 327,
    "src": "(* b = 1 + 2*b' *)",
    "dst": "(* b = 1 + 2*b' *)",
    "votes": 0
  },
  {
    "id": 328,
    "src": "(* GRADE_MANUAL 3: binary_commute *)",
    "dst": "(* GRADE_MANUAL 3: binary_commute *)",
    "votes": 0
  },
  {
    "id": 329,
    "src": "(* EX5AM (binary_inverse) *)",
    "dst": "(* EX5AM (binary_inverse) *)",
    "votes": 0
  },
  {
    "id": 330,
    "src": "(** This exercise is a continuation of the previous exercise about\n    binary numbers.  You will need your definitions and theorems from\n    there to complete this one; please copy them to this file to make\n    it self contained for grading.\n\n    (a) First, write a function to convert natural numbers to binary\n        numbers.  Then prove that starting with any natural number,\n        converting to binary, then converting back yields the same\n        natural number you started with.\n\n    (b) You might naturally think that we should also prove the\n        opposite direction: that starting with a binary number,\n        converting to a natural, and then back to binary yields the\n        same number we started with.  However, this is not true!\n        Explain what the problem is.\n\n    (c) Define a \"direct\" normalization function -- i.e., a function\n        [normalize] from binary numbers to binary numbers such that,\n        for any binary number b, converting to a natural and then back\n        to binary yields [(normalize b)].  Prove it.  (Warning: This\n        part is tricky!)\n\n    Again, feel free to change your earlier definitions if this helps\n    here. *)",
    "dst": "(** 本练习是前一个关于二进制数的练习的延续。你需要你在其中的定义和定理来完成这个；\n    请将它们复制到本文件中让它自包含以便评分。\n    (a) 首先，写一个将自然数转换为二进制数的的函数。然后证明对于所有自然数，\n        用此函数将其转换为二进制数后，再转换回自然数会得到和原来一样的自然数。\n    (b) 你也许会自然而然地想到，将一个二进制数转换为自然数再转换为二进制数之后\n        应该得到与原二进制数相同的结果。然而，这并不是真的！解释问题出在哪。\n    (c) 定义一个「直接的」规范化函数——即，一个从二进制数到二进制数的函数\n        [normalize]，使得对于任何二进制数 b，将其转换为自然数后再转换二进制数\n        会产生 [(normalize b)]。证明它。（警告：这部分有点棘手！）\n    再次说明，如果对此有帮助的话，请随意更改你之前的定义。 *)",
    "votes": 0
  },
  {
    "id": 331,
    "src": "(* BZ *)",
    "dst": "(* BZ *)",
    "votes": 0
  },
  {
    "id": 332,
    "src": "(* T2 *)",
    "dst": "(* T2 *)",
    "votes": 0
  },
  {
    "id": 333,
    "src": "(* T2P1 *)",
    "dst": "(* T2P1 *)",
    "votes": 0
  },
  {
    "id": 334,
    "src": "(** * Lists: Working with Structured Data *)",
    "dst": "(** * Lists: 结构化的数据 *)",
    "votes": 0
  },
  {
    "id": 335,
    "src": "(* TERSE: HIDEFROMHTML *)",
    "dst": "(* TERSE: HIDEFROMHTML *)",
    "votes": 0
  },
  {
    "id": 336,
    "src": "(* TERSE: /HIDEFROMHTML *)",
    "dst": "(* TERSE: /HIDEFROMHTML *)",
    "votes": 0
  },
  {
    "id": 337,
    "src": "(** * Pairs of Numbers *)",
    "dst": "(** * 二元组 *)",
    "votes": 0
  },
  {
    "id": 338,
    "src": "(** FULL: In an [Inductive] type definition, each constructor can take\n    any number of arguments -- none (as with [true] and [O]), one (as\n    with [S]), or more than one, as here: *)",
    "dst": "(** FULL: 在归纳类型定义中，每个构造器（Constructor）可以有任意多个参数——可以没有（就像true和O），可以有一个（就像S），也可以更多，就像接下来那个定义： *)",
    "votes": 0
  },
  {
    "id": 339,
    "src": "(** TERSE: Here's an [Inductive] with just one constructor (taking two\n    arguments): *)",
    "dst": "(** 这是一个只有一个构造器的[Inductive] *)",
    "votes": 0
  },
  {
    "id": 340,
    "src": "(** FULL: This declaration can be read: \"There is just one way to\n    construct a pair of numbers: by applying the constructor [pair] to\n    two arguments of type [nat].\" *)",
    "dst": "(** FULL: 这个定义可以被理解作：\"只有一种方式来构造一个二元组：通过把pair这个构造器应用到两个nat类型的参数上\" *)",
    "votes": 0
  },
  {
    "id": 341,
    "src": "(* /HIDEFROMADVANCED *)",
    "dst": "(* /HIDEFROMADVANCED *)",
    "votes": 0
  },
  {
    "id": 342,
    "src": "(* HIDEFROMADVANCED *)",
    "dst": "(* HIDEFROMADVANCED *)",
    "votes": 0
  },
  {
    "id": 343,
    "src": "(** FULL: Here are two simple functions for extracting the first and\n    second components of a pair.  The definitions also illustrate how\n    to do pattern matching on two-argument constructors. *)",
    "dst": "(** FULL: 下面是两个简单的函数定义，这两个函数分别从一个二元组中抽取第一个和第二个分量。\n          （这个定义同时也展示了如何对一个两个参数的构造器进行模式匹配) *)",
    "votes": 0
  },
  {
    "id": 344,
    "src": "(** TERSE: We can define functions on pairs by pattern matching. *)",
    "dst": "(** TERSE: 我们也可以通过模式匹配来定义在二元组上的函数。*)",
    "votes": 0
  },
  {
    "id": 345,
    "src": "(* ===> 3 *)",
    "dst": "(* ===> 3 *)",
    "votes": 0
  },
  {
    "id": 346,
    "src": "(** FULL: Since pairs are used quite a bit, it is nice to be able to\n    write them with the standard mathematical notation [(x,y)] instead\n    of [pair x y].  We can tell Coq to allow this with a [Notation]\n    declaration. *)",
    "dst": "(** FULL: 因为二元组经常被用到，所以如果能有数学记号 (x,y) 来代替 pair x y 是非常好的。\n     我们可以通过声明一个Notation让Coq接受这种记号。 *)",
    "votes": 0
  },
  {
    "id": 347,
    "src": "(** TERSE: A nicer notation for pairs: *)",
    "dst": "(** TERSE: 一个更好的记号是: *)",
    "votes": 0
  },
  {
    "id": 348,
    "src": "(** TERSE: The new pair notation is supported both in expressions and\n    in pattern matches: *)",
    "dst": "(** TERSE: 这个新的记号既能被用在表达式也能被用在模式匹配中。*)",
    "votes": 0
  },
  {
    "id": 349,
    "src": "(** FULL: The new pair notation can be used both in expressions and in\n    pattern matches (indeed, we've actually seen this already in the\n    previous chapter, in the definition of the [minus] function --\n    this works because the pair notation is also provided as part of\n    the standard library): *)",
    "dst": "(** FULL: 这个新的记号既能被用在表达式也能被用在模式匹配中。（实际上，在上一章中我们已经使用过了——这个记号在标准库中也已经被提供了) *)",
    "votes": 0
  },
  {
    "id": 350,
    "src": "(** TERSE: Let's prove some facts about pairs... *)",
    "dst": "(** TERSE: 让我们来证明一些关于二元组的事实 *)",
    "votes": 0
  },
  {
    "id": 351,
    "src": "(** FULL: Let's try to prove a few simple facts about pairs.\n\n    If we state things in a particular (and slightly peculiar) way, we\n    can complete proofs with just reflexivity (and its built-in\n    simplification): *)",
    "dst": "(** FULL: 我们现在来证明一些有关二元组的简单的事实。如果我们以一种特定的（稍微有点古怪）的方式来\n 书写我们的引理，仅仅通过 [reflexivity]（还有它自带的简化）我们就能完成证明。 *)",
    "votes": 0
  },
  {
    "id": 352,
    "src": "(** But [reflexivity] is not enough if we state the lemma in a more\n    natural way: *)",
    "dst": "(** 注意，但如果我们用一种自然的方式来书写这条引理的话，仅仅使用[reflexivity]来证明是远远不够的。 *)",
    "votes": 0
  },
  {
    "id": 353,
    "src": "(** FULL: We have to expose the structure of [p] so that [simpl] can\n    perform the pattern match in [fst] and [snd].  We can do this with\n    [destruct]. *)",
    "dst": "(** FULL: 我们必须要像Coq展示[p]的具体结构，这样[simpl]才能对[fst]和[snd]\n    做模式匹配。 通过destruct可以达到这个目的。需要注意的是，不像自然数，\n    destruct不会生成一个额外的子目标，因为一共只有一种方式可以构造二元组。 *)\n(** TERSE: 解决方案：使用[destruct] *)",
    "votes": 0
  },
  {
    "id": 354,
    "src": "(** FULL: We have to expose the structure of [p] so that [simpl] can\n    perform the pattern match in [fst] and [snd].  We can do this with\n    [destruct]. *)",
    "dst": "(** FULL: 我们必须要像Coq展示[p]的具体结构，这样[simpl]才能对[fst]和[snd]\n    做模式匹配。 通过destruct可以达到这个目的。需要注意的是，不像自然数，\n    destruct不会生成一个额外的子目标，因为一共只有一种方式可以构造二元组。 *)",
    "votes": 0
  },
  {
    "id": 355,
    "src": "(** TERSE: Solution: use [destruct]. *)",
    "dst": "(** TERSE: 解决方案：使用[destruct] *)",
    "votes": 0
  },
  {
    "id": 356,
    "src": "(* EX1 (snd_fst_is_swap) *)",
    "dst": "(* EX1 (snd_fst_is_swap) *)",
    "votes": 0
  },
  {
    "id": 357,
    "src": "(* EX1? (fst_swap_is_snd) *)",
    "dst": "(* EX1? (fst_swap_is_snd) *)",
    "votes": 0
  },
  {
    "id": 358,
    "src": "(* ###################################################### *)",
    "dst": "(* ###################################################### *)",
    "votes": 0
  },
  {
    "id": 359,
    "src": "(** * Lists of Numbers *)",
    "dst": "(** * 数的列表 *)",
    "votes": 0
  },
  {
    "id": 360,
    "src": "(** FULL: Generalizing the definition of pairs, we can describe the\n    type of _lists_ of numbers like this: \"A list is either the empty\n    list or else a pair of a number and another list.\" *)",
    "dst": "(** FULL: 通过稍稍推广一下我们对二元组的定义，我们像可以这样描述列表：\n    \"一个列表要么是空的，要么就应该是一个由一个数和另一个列表组成的二元组\"。 *)",
    "votes": 0
  },
  {
    "id": 361,
    "src": "(** TERSE: An inductive definition of _lists_ of numbers: *)",
    "dst": "(** TERSE: 一个自然数组成的 _列表_ 的归纳定义： *)",
    "votes": 0
  },
  {
    "id": 362,
    "src": "(** FULL: For example, here is a three-element list: *)",
    "dst": "(** FULL: 例如，这就是一个有三个元素的列表。 *)",
    "votes": 0
  },
  {
    "id": 363,
    "src": "(** FULL: As with pairs, it is more convenient to write lists in\n    familiar programming notation.  The following declarations\n    allow us to use [::] as an infix [cons] operator and square\n    brackets as an \"outfix\" notation for constructing lists. *)",
    "dst": "(** FULL:就像二元组一样，用我们已经熟悉的编程的记号来写下一个列表会显得更为方便。\n    下面两个声明让我们可以用[::]来作中缀cons操作符，用方括号来做[mixfix]符号来构造列表 *)",
    "votes": 0
  },
  {
    "id": 364,
    "src": "(** TERSE: Some notation for lists to make our lives easier: *)",
    "dst": "(** TERSE: 对列表定义记号可以获得便利： *)",
    "votes": 0
  },
  {
    "id": 365,
    "src": "(** FULL: It is not necessary to understand the details of these\n    declarations, but in case you are interested, here is roughly\n    what's going on.  The [right associativity] annotation tells Coq\n    how to parenthesize expressions involving several uses of [::] so\n    that, for example, the next three declarations mean exactly the\n    same thing: *)",
    "dst": "(** FULL: 完全理解这些声明是不必要的，但是假使你感兴趣的话，接下来我会粗略地介绍\n    到底发生了什么。 [right associativity] 告诉 Coq 当遇到多个符号时怎么给表达式加括号。\n    如此一来下面三个声明做的就是同一件事。 *)",
    "votes": 0
  },
  {
    "id": 366,
    "src": "(** TERSE: Now these all mean exactly the same thing: *)",
    "dst": "(** TERSE: 下面这些都有着相同的意义 *)",
    "votes": 0
  },
  {
    "id": 367,
    "src": "(** FULL: The [at level 60] part tells Coq how to parenthesize\n    expressions that involve both [::] and some other infix operator.\n    For example, since we defined [+] as infix notation for the [plus]\n    function at level 50,\n[[\n  Notation \"x + y\" := (plus x y)\n                      (at level 50, left associativity).\n]]\n   the [+] operator will bind tighter than [::], so [1 + 2 :: [3]]\n   will be parsed, as we'd expect, as [(1 + 2) :: [3]] rather than [1\n   + (2 :: [3])].\n\n   (Expressions like \"[1 + 2 :: [3]]\" can be a little confusing when\n   you read them in a .v file.  The inner brackets, around 3, indicate\n   a list, but the outer brackets, which are invisible in the HTML\n   rendering, are there to instruct the \"coqdoc\" tool that the bracketed\n   part should be displayed as Coq code rather than running text.)\n\n   The second and third [Notation] declarations above introduce the\n   standard square-bracket notation for lists; the right-hand side of\n   the third one illustrates Coq's syntax for declaring n-ary\n   notations and translating them to nested sequences of binary\n   constructors. *)",
    "dst": "(** FULL: [at level 60]这部分告诉Coq当遇到表达式还有其他中缀符号的时应该如何加括号。举个例子，\n    我们已经定义了 [+] 作为 [plus] 的中缀符号，它的level是50。\n[[ Notation \"x + y\" := (plus x y)  \n              (at level 50, left associativity).\n]]\n    [+] 将会比 [::] 结合的更紧，所以 [1 + 2 :: [3]] 会被解析成 [(1 + 2) :: [3]]，就和我们期望的一样，而不是 [1 + (2 :: [3])]。\n   (值得注意的是，当你在.v文件中看到\"[1 + (2 :: [3])]\"这样的记号会感到非常疑惑。最里面的那个框住3的方括号，指示了其是一个列表。但是外面那个方括号，在HTML中是看不到的，是用来告诉\"coqdoc\"这部分要被显示为代码而非普通的文本。)\n   上面第二和第三个[Notation]申明引入了标准的方括号记号来表示列表；第三个声明的右边部分展示了在Coq中申明n元记号的语法以及如何把它们翻译成嵌套的二元构造器的序列。 *)",
    "votes": 0
  },
  {
    "id": 368,
    "src": "(** FULL: A number of functions are useful for manipulating lists.\n    For example, the [repeat] function takes a number [n] and a\n    [count] and returns a list of length [count] where every element\n    is [n]. *)",
    "dst": "(** 很多有用的函数可以用来操作列表。比如[repeat]函数接受一个数[n]和[count]，\n    返回一个长为[count]，每个元素都是[n]的列表。 *)",
    "votes": 0
  },
  {
    "id": 369,
    "src": "(** TERSE: Some useful list-manipulation functions: *)",
    "dst": "(** TERSE: 一些有用的操作list的函数 *)",
    "votes": 0
  },
  {
    "id": 370,
    "src": "(** *** Length *)",
    "dst": "(** *** Length *)",
    "votes": 0
  },
  {
    "id": 371,
    "src": "(** FULL: The [length] function calculates the length of a list. *)",
    "dst": "(** FULL: [length]函数用来计算列表的长度。 *)",
    "votes": 0
  },
  {
    "id": 372,
    "src": "(** *** Append *)",
    "dst": "(** *** Append *)",
    "votes": 0
  },
  {
    "id": 373,
    "src": "(** FULL: The [app] function concatenates (appends) two lists. *)",
    "dst": "(** FULL: [app]函数用来把两个列表联接起来。 *)",
    "votes": 0
  },
  {
    "id": 374,
    "src": "(** FULL: Actually, [app] will be used a lot in some parts of what\n    follows, so it is convenient to have an infix operator for it. *)",
    "dst": "(** FULL: 实际上，在接下来的很多地方都会用到[app]，所以如果它有一个中缀操作符的话会很方便。 *)",
    "votes": 0
  },
  {
    "id": 375,
    "src": "(** *** Head (with default) and Tail *)",
    "dst": "(** *** 带默认值的Head和tl *)",
    "votes": 0
  },
  {
    "id": 376,
    "src": "(** FULL: Here are two smaller examples of programming with lists.\n    The [hd] function returns the first element (the \"head\") of the\n    list, while [tl] returns everything but the first\n    element (the \"tail\").\n    Of course, the empty list has no first element, so we\n    must pass a default value to be returned in that case.  *)",
    "dst": "(** FULL: 我们来看两个小例子，这两个例子都是有关如何编写有关列表的程序。\n    [hd]函数返回列表的第一个元素（\"头元素\"）。类似的，[tl] 返回除了第一个元素以外\n    的所有元素。\n    当然，空列表没有第一个元素，所以我们必须传入一个默认值，让这个值成为这种情况下的返回值。  *)",
    "votes": 0
  },
  {
    "id": 377,
    "src": "(** What does the following function do? *)",
    "dst": "(** 下面这个函数做了什么？ *)",
    "votes": 0
  },
  {
    "id": 378,
    "src": "(** (Press any key when you have the answer.) *)",
    "dst": "(** (当你想到答案时按下任意键) *)",
    "votes": 0
  },
  {
    "id": 379,
    "src": "(** Complete the definitions of [nonzeros], [oddmembers] and\n    [countoddmembers] below. Have a look at the tests to understand\n    what these functions should do. *)",
    "dst": "(** 完成以下[nonzeros]，[oddmembers]和[countoddmembers]的定义，\n 你可以查看测试函数来理解这些函数应该做什么 *)",
    "votes": 0
  },
  {
    "id": 380,
    "src": "(* GRADE_THEOREM 1: NatList.test_nonzeros *)",
    "dst": "(* GRADE_THEOREM 1: NatList.test_nonzeros *)",
    "votes": 0
  },
  {
    "id": 381,
    "src": "(* GRADE_THEOREM 1: NatList.test_oddmembers *)",
    "dst": "(* GRADE_THEOREM 1: NatList.test_oddmembers *)",
    "votes": 0
  },
  {
    "id": 382,
    "src": "(* GRADE_THEOREM 1: NatList.test_countoddmembers2 *)",
    "dst": "(* GRADE_THEOREM 1: NatList.test_countoddmembers2 *)",
    "votes": 0
  },
  {
    "id": 383,
    "src": "(* EX3A (alternate) *)",
    "dst": "(* EX3A (alternate) *)",
    "votes": 0
  },
  {
    "id": 384,
    "src": "(** Complete the definition of [alternate], which \"zips up\" two lists\n    into one, alternating between elements taken from the first list\n    and elements from the second.  See the tests below for more\n    specific examples.\n\n    Note: one natural and elegant way of writing [alternate] will fail\n    to satisfy Coq's requirement that all [Fixpoint] definitions be\n    \"obviously terminating.\"  If you find yourself in this rut, look\n    for a slightly more verbose solution that considers elements of\n    both lists at the same time.  (One possible solution requires\n    defining a new kind of pairs, but this is not the only way.)  *)",
    "dst": "(** 完成[alternate]的定义，它把两个列表像拉链一样\"拉\"起来并成为一个列表，\n    从两个列表中交替地取出元素。查看后面的tests来获得更加详细的例子。\n    注意：一种自然的，优雅的方法来书写[alternate]将无法满足Coq对于[Fixpoint]必须\n    \"显然会终止\"的要求。如果你���现你被这种解法束缚住了，你可以寻找一种稍微冗长一些的解法：同时考虑两个列表。（一个可行的解法需要定义新的列表，但这不是唯一的方法） *)",
    "votes": 0
  },
  {
    "id": 385,
    "src": "(* GRADE_THEOREM 1: NatList.test_alternate1 *)",
    "dst": "(* GRADE_THEOREM 1: NatList.test_alternate1 *)",
    "votes": 0
  },
  {
    "id": 386,
    "src": "(* GRADE_THEOREM 1: NatList.test_alternate2 *)",
    "dst": "(* GRADE_THEOREM 1: NatList.test_alternate2 *)",
    "votes": 0
  },
  {
    "id": 387,
    "src": "(* GRADE_THEOREM 1: NatList.test_alternate4 *)",
    "dst": "(* GRADE_THEOREM 1: NatList.test_alternate4 *)",
    "votes": 0
  },
  {
    "id": 388,
    "src": "(* ###################################################### *)",
    "dst": "(* ###################################################### *)",
    "votes": 0
  },
  {
    "id": 389,
    "src": "(** *** Bags via Lists *)",
    "dst": "(** ** 用列表实现Bags *)",
    "votes": 0
  },
  {
    "id": 390,
    "src": "(** A [bag] (or [multiset]) is like a set, except that each element\n    can appear multiple times rather than just once.  One possible\n    implementation is to represent a bag of numbers as a list. *)",
    "dst": "(** [bag]（或者叫[multiset]）就像一个集合，但是每个元素都能够出现若干次，而不是仅仅一次。\n   背包一种合理的实现就是把它作为一个列表。 *)",
    "votes": 0
  },
  {
    "id": 391,
    "src": "(* EX3! (bag_functions) *)",
    "dst": "(* EX3! (bag_functions) *)",
    "votes": 0
  },
  {
    "id": 392,
    "src": "(** All these proofs can be done just by [reflexivity]. *)",
    "dst": "(** 这些命题都能通过[reflexivity]来证明。 *)",
    "votes": 0
  },
  {
    "id": 393,
    "src": "(* GRADE_THEOREM 1: NatList.test_count2 *)",
    "dst": "(* GRADE_THEOREM 1: NatList.test_count2 *)",
    "votes": 0
  },
  {
    "id": 394,
    "src": "(** Multiset [sum] is similar to set [union]: [sum a b] contains\n    all the elements of [a] and of [b].  (Mathematicians usually\n    define [union] on multisets a little bit differently, which\n    is why we don't use that name for this operation.)\n    For [sum] we're giving you a header that does not give explicit\n    names to the arguments.  Moreover, it uses the keyword\n    [Definition] instead of [Fixpoint], so even if you had names for\n    the arguments, you wouldn't be able to process them recursively.\n    The point of stating the question this way is to encourage you to\n    think about whether [sum] can be implemented in another way --\n    perhaps by using functions that have already been defined.  *)",
    "dst": "(** 多重集的[sum]非常像集合的[union]:[sum a b]包含了所有[a]和[b]的元素。（数学上对\n    多重集上的[sum]的定义常常不大一样，这也是为什么我们没有使用这个名字。\n    对于[sum]来说，我们给你的声明中并没有显式的���参数指派名字。除此以外，它使用[Definition]\n    而不是[Fixpont]，所以即使你给参数安排了名字，你也不能递归的处理他们。给出这个问题的意义\n    在于鼓励你思考[sum]是否能用另一种方法实现——通过使用那些你已经定义过的函数。  *)",
    "votes": 0
  },
  {
    "id": 395,
    "src": "(* GRADE_THEOREM 1: NatList.test_sum1 *)",
    "dst": "(* GRADE_THEOREM 1: NatList.test_sum1 *)",
    "votes": 0
  },
  {
    "id": 396,
    "src": "(* GRADE_THEOREM 1: NatList.test_add2 *)",
    "dst": "(* GRADE_THEOREM 1: NatList.test_add2 *)",
    "votes": 0
  },
  {
    "id": 397,
    "src": "(* GRADE_THEOREM 1: NatList.test_member1 *)",
    "dst": "(* GRADE_THEOREM 1: NatList.test_member1 *)",
    "votes": 0
  },
  {
    "id": 398,
    "src": "(* EX3? (bag_more_functions) *)",
    "dst": "(* EX3? (bag_more_functions) *)",
    "votes": 0
  },
  {
    "id": 399,
    "src": "(** Here are some more bag functions for you to practice with. *)",
    "dst": "(** 你可以把下面这些和[bag]有关的函数当做额外的练习 *)",
    "votes": 0
  },
  {
    "id": 400,
    "src": "(** When remove_one is applied to a bag without the number to remove,\n   it should return the same bag unchanged. *)",
    "dst": "(** 当[remove_one]被应用到一个没有数可以移除的背包时，它应该返回原来的那个而不做任何改变。 *)",
    "votes": 0
  },
  {
    "id": 401,
    "src": "(* EX3!M (bag_theorem) *)",
    "dst": "(* EX3!M (bag_theorem) *)",
    "votes": 0
  },
  {
    "id": 402,
    "src": "(** Write down an interesting theorem [bag_theorem] about bags\n    involving the functions [count] and [add], and prove it.  Note\n    that, since this problem is somewhat open-ended, it's possible\n    that you may come up with a theorem which is true, but whose proof\n    requires techniques you haven't learned yet.  Feel free to ask for\n    help if you get stuck! *)",
    "dst": "(** 写下一个你认为有趣的关于[bags]的定理[bag_theorem]，要涉及到[count]和[add]。\n  证明他。注意，这个问题是开放的，很有可能你会遇到你写下了正确的定理，\n  但是其证明涉及到了你现在还没有学到的技巧。如果你陷入麻烦了，欢迎提问。 *)",
    "votes": 0
  },
  {
    "id": 403,
    "src": "(* GRADE_MANUAL 3: NatList.bag_theorem *)",
    "dst": "(* GRADE_MANUAL 3: NatList.bag_theorem *)",
    "votes": 0
  },
  {
    "id": 404,
    "src": "(** * Reasoning About Lists *)",
    "dst": "(** * 有关列表的推理 *)",
    "votes": 0
  },
  {
    "id": 405,
    "src": "(** FULL: As with numbers, simple facts about list-processing\n    functions can sometimes be proved entirely by simplification.  For\n    example, the simplification performed by [reflexivity] is enough\n    for this theorem... *)",
    "dst": "(** FULL: 就像数字一样，一些简单的有关处理列表事实，有时也能仅仅通过化简来证明。\n  比方说，对于下面这个例子，[reflexivity]中所做的简化就已经足够了…… *)",
    "votes": 0
  },
  {
    "id": 406,
    "src": "(** TERSE: As with numbers, some proofs about list functions need only\n    simplification. *)",
    "dst": "(** TERSE: 就像数字那样，有些关于列表的证明只需要简化就够了。 *)",
    "votes": 0
  },
  {
    "id": 407,
    "src": "(** FULL: ... because the [[]] is substituted into the\n    \"scrutinee\" (the value being \"scrutinized\" by the match) in the\n    definition of [app], allowing the match itself to be\n    simplified. *)",
    "dst": "(** FULL: ……由于[[]]被替换进了[app]定义中的相应的match分支，这就使得整个[match]得以被简化并证明目标 *)",
    "votes": 0
  },
  {
    "id": 408,
    "src": "(** FULL: Also, as with numbers, it is sometimes helpful to perform case\n    analysis on the possible shapes (empty or non-empty) of an unknown\n    list. *)",
    "dst": "(** FULL: 并且，和数一样，又是对一个列表做分类讨论（是否是空）是非常有用的。 *)",
    "votes": 0
  },
  {
    "id": 409,
    "src": "(** TERSE: ...and some need case analysis. *)",
    "dst": "(** TERSE: 还有一些分类讨论 *)",
    "votes": 0
  },
  {
    "id": 410,
    "src": "(* l = nil *)",
    "dst": "(* l = nil *)",
    "votes": 0
  },
  {
    "id": 411,
    "src": "(* l = cons n l' *)",
    "dst": "(* l = cons n l' *)",
    "votes": 0
  },
  {
    "id": 412,
    "src": "(** FULL: Here, the [nil] case works because we've chosen to define\n    [tl nil = nil]. Notice that the [as] annotation on the [destruct]\n    tactic here introduces two names, [n] and [l'], corresponding to\n    the fact that the [cons] constructor for lists takes two\n    arguments (the head and tail of the list it is constructing). *)",
    "dst": "(** FULL: 这里，如此解决[nil]这种情况是因为我们定义了[tl nil = nil]。至于[destruct]策略中的[as]注解\n  引入的两个名字，[n]和[l']， 分别对应了[cons]构造子的两个参数（正在构造的列表的头和尾）。 *)",
    "votes": 0
  },
  {
    "id": 413,
    "src": "(** Usually, though, interesting theorems about lists require\n    induction for their proofs. *)",
    "dst": "(** 通常的情况是，就算你不相信的话也没办法，要证明关于列表的有趣的定理需要用到归纳法。 *)",
    "votes": 0
  },
  {
    "id": 414,
    "src": "(** *** Micro-Sermon *)",
    "dst": "(** ** 一点点说教 *)",
    "votes": 0
  },
  {
    "id": 415,
    "src": "(** Simply reading example proof scripts will not get you very far!\n    It is important to work through the details of each one, using Coq\n    and thinking about what each step achieves.  Otherwise it is more\n    or less guaranteed that the exercises will make no sense when you\n    get to them.  'Nuff said. *)",
    "dst": "(** 只是阅读示例证明的话，你不会获得什么特别有用的东西。搞清楚每一个的细节是非常重要的\n 使用Coq并思考有关每一步是如何得到的。否则练习题将一点用都没有。 *)",
    "votes": 0
  },
  {
    "id": 416,
    "src": "(** ** Induction on Lists *)",
    "dst": "(** ** 列表上的归纳 *)",
    "votes": 0
  },
  {
    "id": 417,
    "src": "(** FULL: Proofs by induction over datatypes like [natlist] are a\n    little less familiar than standard natural number induction, but\n    the idea is equally simple.  Each [Inductive] declaration defines\n    a set of data values that can be built up using the declared\n    constructors: a boolean can be either [true] or [false]; a number\n    can be either [O] or [S] applied to another number; a list can be\n    either [nil] or [cons] applied to a number and a list.\n\n    Moreover, applications of the declared constructors to one another\n    are the _only_ possible shapes that elements of an inductively\n    defined set can have, and this fact directly gives rise to a way\n    of reasoning about inductively defined sets: a number is either\n    [O] or else it is [S] applied to some _smaller_ number; a list is\n    either [nil] or else it is [cons] applied to some number and some\n    _smaller_ list; etc. So, if we have in mind some proposition [P]\n    that mentions a list [l] and we want to argue that [P] holds for\n    _all_ lists, we can reason as follows:\n\n      - First, show that [P] is true of [l] when [l] is [nil].\n\n      - Then show that [P] is true of [l] when [l] is [cons n l'] for\n        some number [n] and some smaller list [l'], assuming that [P]\n        is true for [l'].\n\n    Since larger lists can only be built up from smaller ones,\n    eventually reaching [nil], these two arguments together establish\n    the truth of [P] for all lists [l].  Here's a concrete example: *)",
    "dst": "(** FULL: 读者对在像[natlist]这样的数据类型上通过归纳进行证明和对自然数归纳相比可能没有name熟悉，\n  但是基本的想法是一样简单的。每个[Inductive]的声明定义了一集值，这些值可以用那些被声明\n  的构造器来构建：布尔值可以是[true]或者是[false]；自然数可以是[O]或[S]应用到另一个自然数上；\n  列表可以是[nil]或者是[cons]应用到一个自然数和另一个列表。\n  除此以外，把声明的构造子应用到别的项上面是的归纳定义的项的 _唯一_ 可能的形状，并且这个是个事实\n  直接就给出了一种用来推理归纳定义集的方法：一个自然数要么是[O]不然就是[S]应用到某个 _更小_ 的\n  自然数；一个列表要么是[nil]不然就是[cons]应用到某个自然数和某个 _更小_ 的列表上；等等。所以，\n  如果我们有某个命题[P]提到了列表[l]并且我们想证明[P]对 _一切_ 列表都成立，我们可以像这样推理：\n  - 首先，证明 [P] 当 [l] 是 [nil] 时对 [l] 成立 .\n  - 然后证明 [P] 当 [l] 是 [cons n l']成立， 其中 [n] 是某个自然数，[l'] 是某个更小的列表\n  ，假设 [P] 对 [l'] 成立.\n  由于较大的列表只可能通过较小的列表构建起来，最终这个较小的列表会变成[nil]，这两点合一起就完成了\n  [P] 对一切列表 [l] 成立的证明。 下面是一个具体的例子。 *)",
    "votes": 0
  },
  {
    "id": 418,
    "src": "(** TERSE: Coq generates an induction principle for every [Inductive]\n    definition, including lists.  We can use the [induction] tactic on lists to prove\n    things like the associativity of list-append... *)",
    "dst": "(** TERSE: Coq为包括列表在内的每个[Inductive]的定义生成了归纳原则。我们\n    可以使用[induction]这个策略来证明包括列表的附加的结合性在内的定理。*)",
    "votes": 0
  },
  {
    "id": 419,
    "src": "(* l1 = nil *)",
    "dst": "(* l1 = nil *)",
    "votes": 0
  },
  {
    "id": 420,
    "src": "(* l1 = cons n l1' *)",
    "dst": "(* l1 = cons n l1' *)",
    "votes": 0
  },
  {
    "id": 421,
    "src": "(** FULL: Notice that, as when doing induction on natural numbers, the\n    [as...] clause provided to the [induction] tactic gives a name to\n    the induction hypothesis corresponding to the smaller list [l1']\n    in the [cons] case. Once again, this Coq proof is not especially\n    illuminating as a static written document -- it is easy to see\n    what's going on if you are reading the proof in an interactive Coq\n    session and you can see the current goal and context at each\n    point, but this state is not visible in the written-down parts of\n    the Coq proof.  So a natural-language proof -- one written for\n    human readers -- will need to include more explicit signposts; in\n    particular, it will help the reader stay oriented if we remind\n    them exactly what the induction hypothesis is in the second\n    case. *)",
    "dst": "(** FULL: 再一次强调，当你把Coq的证明当做静态的文档的话你可能不会有特别多的收获——如果你\n  通过一个交互式的Coq会话���阅读证明的话你可以看到当前的目标和上下文，但是这些状态\n  对于阅读写下来的脚本的你来说是不可见的。所以一份用自然语言写成的证明——写给人看的——会\n  需要包含更多地提示，比如提醒他们第二种情况下的归纳假设到底是什么，来帮助读者明白当前的情况。 *)",
    "votes": 0
  },
  {
    "id": 422,
    "src": "(** _Theorem_: For all lists [l1], [l2], and [l3],\n   [(l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3)].\n\n   _Proof_: By induction on [l1].\n\n   - First, suppose [l1 = []].  We must show\n[[\n       ([] ++ l2) ++ l3 = [] ++ (l2 ++ l3),\n]]\n     which follows directly from the definition of [++].\n\n   - Next, suppose [l1 = n::l1'], with\n[[\n       (l1' ++ l2) ++ l3 = l1' ++ (l2 ++ l3)\n]]\n     (the induction hypothesis). We must show\n[[\n       ((n :: l1') ++ l2) ++ l3 = (n :: l1') ++ (l2 ++ l3).\n]]\n     By the definition of [++], this follows from\n[[\n       n :: ((l1' ++ l2) ++ l3) = n :: (l1' ++ (l2 ++ l3)),\n]]\n     which is immediate from the induction hypothesis.  [] *)",
    "dst": "(** _定理_ : 对所有的列表 [l1], [l2], 和 [l3]， \n  [(l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3)]。\n  _证明_: 通过对 [l1] 使用归纳法。\n  - 首先, 假设 [l1 = []]。  我们要证明：\n  ([] ++ l2) ++ l3 = [] ++ (l2 ++ l3),\n  这可以通过展开 [++] 的定义得到.\n  - 然后, 假设 [l1 = n::l1']， 有：\n  (l1' ++ l2) ++ l3 = l1' ++ (l2 ++ l3)\n  (归纳假设)。 我们必须证明\n  ((n :: l1') ++ l2) ++ l3 = (n :: l1') ++ 用来强调目的是一个不错 根据 [++] 的定义, 上面就等价于：\n  n :: ((l1' ++ l2) ++ l3) = n :: (l1' ++ (l2 ++ l3)),\n  这可以通过我们的归纳假设立马得到。  []\n  *)",
    "votes": 0
  },
  {
    "id": 423,
    "src": "(** *** Properties of [rev] *)",
    "dst": "(** *** 有关反转的证明 *)",
    "votes": 0
  },
  {
    "id": 424,
    "src": "(** FULL: Now let's prove some theorems about our newly defined [rev].\n    For something a bit more challenging than what we've seen, let's\n    prove that reversing a list does not change its length.  Our first\n    attempt gets stuck in the successor case... *)",
    "dst": "(** FULL: 现在我们用我们新定义的[snoc]和[rec]来证明一些列表的定理。\n  与我们目前已经见到过的归纳证明相比，手头这个是一个更具挑战性\n  的定理：就是反转一个列表并不会改变他的长度。当我们初次尝试时\n  我们发现我们卡在了后继这种情形上。 *)",
    "votes": 0
  },
  {
    "id": 425,
    "src": "(** TERSE: Let's try to prove [length (rev l) = length l]. *)",
    "dst": "(** TERSE: 让我们试着证明 [length (rev l) = length l]. *)",
    "votes": 0
  },
  {
    "id": 426,
    "src": "(* l = [] *)",
    "dst": "(* l = [] *)",
    "votes": 0
  },
  {
    "id": 427,
    "src": "(* l = n :: l' *)",
    "dst": "(* l = n :: l' *)",
    "votes": 0
  },
  {
    "id": 428,
    "src": "(* This is the tricky case.  Let's begin as usual\n       by simplifying. *)",
    "dst": "(* 这是一个比较棘手的情况。我们从普通的化简开始。 *)",
    "votes": 0
  },
  {
    "id": 429,
    "src": "(* Now we seem to be stuck: the goal is an equality\n       involving [++], but we don't have any useful equations\n       in either the immediate context or in the global\n       environment!  We can make a little progress by using\n       the IH to rewrite the goal... *)",
    "dst": "(* 现在我们好像卡在什么地方了：目标是要证明涉及[snoc]的等式，\n   但是我们在上下文和全局环境下并没有任何有关[snoc]的等式！\n   通过IH来重写目标，我们可以获得一点点进展…… *)",
    "votes": 0
  },
  {
    "id": 430,
    "src": "(* ... but now we can't go any further. *)",
    "dst": "(* ……但也仅此而已 *)",
    "votes": 0
  },
  {
    "id": 431,
    "src": "(** TERSE: We can prove a lemma to bridge the gap. *)",
    "dst": "(** TERSE: 我们可以证明一个引理来作为桥梁 *)",
    "votes": 0
  },
  {
    "id": 432,
    "src": "(* l1 = nil *)",
    "dst": "(* l1 = nil *)",
    "votes": 0
  },
  {
    "id": 433,
    "src": "(* l1 = cons *)",
    "dst": "(* l1 = cons *)",
    "votes": 0
  },
  {
    "id": 434,
    "src": "(** FULL: Note that, to make the lemma as general as possible, we\n    quantify over _all_ [natlist]s, not just those that result from an\n    application of [rev].  This should seem natural, because the truth\n    of the goal clearly doesn't depend on the list having been\n    reversed.  Moreover, it is easier to prove the more general\n    property. *)",
    "dst": "(** FULL: 注意我们要使得引理尽可能的 _通用_ : 具体来说，我们要对 _所有_ 的[natlist]\n  进行全称量化，而不仅仅是那些由[rev]的来的。这很自然，因为这个证明目标\n  显然不依赖于被反转的列表。除此之外，证明一个更普遍的性质更容易。 *)",
    "votes": 0
  },
  {
    "id": 435,
    "src": "(** Now we can complete the original proof. *)",
    "dst": "(** 现在我们可以完成最初的那个证明。 *)",
    "votes": 0
  },
  {
    "id": 436,
    "src": "(* l = nil *)",
    "dst": "(* l = nil *)",
    "votes": 0
  },
  {
    "id": 437,
    "src": "(* l = cons *)",
    "dst": "(* l = cons *)",
    "votes": 0
  },
  {
    "id": 438,
    "src": "(** To prove the following theorem, which tactics will we need besides\n    [intros], [simpl], [rewrite] and [reflexivity]?  (1) none (2) [destruct],\n    (3) [induction on n], (4) [induction on l], or (5) can't be\n    done with the tactics we've seen.\n[[\n      Theorem foo1 : forall n :nat, forall l: natlist,\n        repeat n 0 = l -> length l = 0.\n]]\n*)",
    "dst": "(** 要证明下面的定理，除了[intros]，[simpl]，[rewrite]和[reflexivity]以外，\n    我们还需要哪些策略？(1) 没有 (2) [destruct]，(3) [induction on n] (4)\n    [induction on l]，或者(5)使用我们现在已经见到过的策略无法证明\n[[\n    Theorem foo1 : forall n :nat, forall l: natlist, \n    repeat n 0 = l -> length l = 0.\n]]\n*)",
    "votes": 0
  },
  {
    "id": 439,
    "src": "(** What about the next one?\n[[\n      Theorem foo2 :  forall n m:nat, forall l: natlist,\n        repeat n m = l -> length l = m.\n]]\n    Which tactics do we need besides [intros], [simpl], [rewrite] and\n    [reflexivity]?  (1) none (2) [destruct],\n    (3) [induction on m], (4) [induction on l], or (5) can't be\n    done with the tactics we've seen.\n*)",
    "dst": "(** 下面这个如何？\n[[\n    Theorem foo2 :  forall n m:nat, forall l: natlist,\n    repeat n m = l -> length l = m.\n]]\n    Which tactics do we need besides [intros], [simpl], [rewrite] and\n    [reflexivity]?  (1) none (2) [destruct],\n    (3) [induction on m], (4) [induction on l], or (5) can't be\n    done with the tactics we've seen.\n*)",
    "votes": 0
  },
  {
    "id": 440,
    "src": "(* /TERSE *)",
    "dst": "(* /TERSE *)",
    "votes": 0
  },
  {
    "id": 441,
    "src": "(** TERSE: These proofs are rather longwinded.  We'd usually write\n    them in a more compressed style: *)",
    "dst": "(** TERSE: 显然， 这些证明非常的冗长。对于哪些熟悉结构化归纳的读者来说，我们\n    可以用一种更加紧凑的形式来写这些证明。*)",
    "votes": 0
  },
  {
    "id": 442,
    "src": "(** FULL: The style of these proofs is rather longwinded and pedantic.\n    After the first few, we might find it easier to follow proofs that\n    give fewer details (which can easily work out in our own minds or\n    on scratch paper if necessary) and just highlight the non-obvious\n    steps.  In this more compressed style, the above proof might look\n    like this: *)",
    "dst": "(** FULL: 显然，这些证明的样式实在是冗长而迂腐。经历过最开始的那些以后，\n  我们可能觉得细节更少并且仅仅突出那些不十分显然的步骤的那些证明\n  更容易理解（因为我们能够的在脑子中思考他们，实在不行我们还\n  可以在纸上打草稿）。下面我们以一种更加紧凑的样式\n  呈现之前的证明： *)",
    "votes": 0
  },
  {
    "id": 443,
    "src": "(** FULL: Which style is preferable in a given situation depends on\n    the sophistication of the expected audience and how similar the\n    proof at hand is to ones that the audience will already be\n    familiar with.  The more pedantic style is a good default for our\n    present purposes. *)",
    "dst": "(** FULL: 在特定情况下，我们更倾向于哪种样式取决于读者对于这个问题\n  了解程度以及当前证明和读者已经了解的那些有多相近。更加冗长\n  的版本用来强调证明目标是一个不错的方式。 *)",
    "votes": 0
  },
  {
    "id": 444,
    "src": "(** We've seen that proofs can make use of other theorems we've\n    already proved, e.g., using [rewrite].  But in order to refer to a\n    theorem, we need to know its name!  Indeed, it is often hard even\n    to remember what theorems have been proven, much less what they\n    are called.\n\n    Coq's [Search] command is quite helpful with this.  Typing\n    [Search foo] will cause Coq to display a list of all theorems\n    involving [foo].  For example, try uncommenting the following line\n    to see a list of theorems that we have proved about [rev]: *)",
    "dst": "(** 我们已经见到了很多证明需要使用之前已经证明过的结论，然后使用[rewrite]来\n  改写当前目标，接下来我们会看到其他用来重用之前证明的定理的方式。但是\n  想要指定一个定理，我们需要知道其名字，记住所有定理的名字是很困难的！\n  记住哪些定理已经被证明过了甚至都是非常困难的，更不要说记住它们的名字了。\n  Coq的[Search]命令在遇到这种情况的时候非常有用。用[Search foo]\n  会让Coq显示所有涉及到[foo]的定理的列表。举个例子，去掉下面的注释你会看到\n  一串我们已经证明过的关于[rev]的定理。 *)",
    "votes": 0
  },
  {
    "id": 445,
    "src": "(** ** List Exercises, Part 1 *)",
    "dst": "(** ** List Exercises, Part 1 *)",
    "votes": 0
  },
  {
    "id": 446,
    "src": "(* EX3M (list_exercises) *)",
    "dst": "(* EX3M (list_exercises) *)",
    "votes": 0
  },
  {
    "id": 447,
    "src": "(* GRADE_THEOREM 1: NatList.app_nil_r *)",
    "dst": "(* GRADE_THEOREM 1: NatList.app_nil_r *)",
    "votes": 0
  },
  {
    "id": 448,
    "src": "(* GRADE_THEOREM 2: NatList.rev_involutive *)",
    "dst": "(* GRADE_THEOREM 2: NatList.rev_involutive *)",
    "votes": 0
  },
  {
    "id": 449,
    "src": "(** An exercise about your implementation of [nonzeros]: *)",
    "dst": "(** 关于你所实现的[nonzeros]的习题 *)",
    "votes": 0
  },
  {
    "id": 450,
    "src": "(* GRADE_THEOREM 1: NatList.nonzeros_app *)",
    "dst": "(* GRADE_THEOREM 1: NatList.nonzeros_app *)",
    "votes": 0
  },
  {
    "id": 451,
    "src": "(* l = nil *)",
    "dst": "(* l = nil *)",
    "votes": 0
  },
  {
    "id": 452,
    "src": "(* l = cons *)",
    "dst": "(* l = cons *)",
    "votes": 0
  },
  {
    "id": 453,
    "src": "(* GRADE_THEOREM 2: NatList.beq_natlist_refl *)",
    "dst": "(* GRADE_THEOREM 2: NatList.beq_natlist_refl *)",
    "votes": 0
  },
  {
    "id": 454,
    "src": "(* 0 *)",
    "dst": "(* 0 *)",
    "votes": 0
  },
  {
    "id": 455,
    "src": "(* S n' *)",
    "dst": "(* S n' *)",
    "votes": 0
  },
  {
    "id": 456,
    "src": "(* s = nil *)",
    "dst": "(* s = nil *)",
    "votes": 0
  },
  {
    "id": 457,
    "src": "(* s = h :: t *)",
    "dst": "(* s = h :: t *)",
    "votes": 0
  },
  {
    "id": 458,
    "src": "(** Prove that the [rev] function is injective -- that is,\n[[\n    forall (l1 l2 : natlist), rev l1 = rev l2 -> l1 = l2.\n]]\n(There is a hard way and an easy way to do this.) *)",
    "dst": "(** 证明[rev]是一个单射，也就是说，\n  forall (l1 l2 : natlist), rev l1 = rev l2 -> l1 = l2.\n  这个问题既可以用简单的方式解决也可以用繁琐的方式来解决。\n*)",
    "votes": 0
  },
  {
    "id": 459,
    "src": "(** The easy way is to use the fact that [rev] is an involution.  In\n    general, every involution is injective.  The hard way is to go by\n    induction on [l1], but this requires proving a bunch of subsidiary\n    lemmas.\n*)",
    "dst": "(** 如果你注意到[rev]是复归的(译者注：或称幂等的，即 rev (rev l) == l)那么问题\n    就很简单了。通常来说，所有复归函数都是单射函数。（比较繁琐的方法是对[l1]进行\n    归纳，但这需要许多附属的引理） *)",
    "votes": 0
  },
  {
    "id": 460,
    "src": "(** * Options *)",
    "dst": "(** * 可能的失败 *)",
    "votes": 0
  },
  {
    "id": 461,
    "src": "(** FULL: Suppose we want to write a function that returns the [n]th\n    element of some list.  If we give it type [nat -> natlist -> nat],\n    then we'll have to choose some number to return when the list is\n    too short... *)",
    "dst": "(** 另一方面，如果我们让它的类型成为[nat -> natlist -> natoption]，\n  那么当列表不够长时，我们就能返回[None]，当列表有足够的元素时返回[Some a]，\n  其中[a]出现在列表的第[n]位。 *)",
    "votes": 0
  },
  {
    "id": 462,
    "src": "(** FULL: Suppose we want to write a function that returns the [n]th\n    element of some list.  If we give it type [nat -> natlist -> nat],\n    then we'll have to choose some number to return when the list is\n    too short... *)",
    "dst": "(** FULL: Suppose we want to write a function that returns the [n]th\n    element of some list.  If we give it type [nat -> natlist -> nat],\n    then we'll have to choose some number to return when the list is\n    too short... *)",
    "votes": 0
  },
  {
    "id": 463,
    "src": "(* FOLD *)",
    "dst": "(* FOLD *)",
    "votes": 0
  },
  {
    "id": 464,
    "src": "(* /FOLD *)",
    "dst": "(* /FOLD *)",
    "votes": 0
  },
  {
    "id": 465,
    "src": "(* EX2 (hd_error) *)",
    "dst": "(* EX2 (hd_error) *)",
    "votes": 0
  },
  {
    "id": 466,
    "src": "(** This exercise relates your new [hd_error] to the old [hd]. *)",
    "dst": "(** 这个练习帮助你在新的[hd_opt]和旧的[hd]之间建立联系 *)",
    "votes": 0
  },
  {
    "id": 467,
    "src": "(* GRADE_THEOREM 2: NatList.option_elim_hd *)",
    "dst": "(* GRADE_THEOREM 2: NatList.option_elim_hd *)",
    "votes": 0
  },
  {
    "id": 468,
    "src": "(** * Partial Maps *)",
    "dst": "(** * 字典 *)",
    "votes": 0
  },
  {
    "id": 469,
    "src": "(** As a final illustration of how data structures can be defined in\n    Coq, here is a simple _partial map_ data type, analogous to the\n    map or dictionary data structures found in most programming\n    languages. *)",
    "dst": "(** FULL: 作为最后一个演示在Coq中如何定义基础的数据结构的例子，这里是\n  一个简单的[dictionary]的声明，使用数作为关键字和值\n  （也就是说，一个字典代表了一个有限的从自然数到自然数的映射。） *)",
    "votes": 0
  },
  {
    "id": 470,
    "src": "(** As a final illustration of how data structures can be defined in\n    Coq, here is a simple _partial map_ data type, analogous to the\n    map or dictionary data structures found in most programming\n    languages. *)",
    "dst": "(** As a final illustration of how data structures can be defined in\n    Coq, here is a simple _partial map_ data type, analogous to the\n    map or dictionary data structures found in most programming\n    languages. *)",
    "votes": 0
  },
  {
    "id": 471,
    "src": "(** * Partial Maps *)",
    "dst": "(** * Partial Maps *)",
    "votes": 0
  },
  {
    "id": 472,
    "src": "(** Is the following claim true or false? *)",
    "dst": "(** 下面的断言是真是假？ *)",
    "votes": 0
  },
  {
    "id": 473,
    "src": "(* HIDEFROMHTML *)",
    "dst": "(* HIDEFROMHTML *)",
    "votes": 0
  },
  {
    "id": 474,
    "src": "(* /HIDEFROMHTML *)",
    "dst": "(* /HIDEFROMHTML *)",
    "votes": 0
  },
  {
    "id": 475,
    "src": "(** (1) True\n\n    (2) False\n\n    (3) Not sure\n*)",
    "dst": "(** (1) 真\n    (2) 假\n    (3) 不确定\n*)",
    "votes": 0
  },
  {
    "id": 476,
    "src": "(** (1) True\n\n    (2) False\n\n    (3) Not sure\n*)",
    "dst": "(** (1) 真\n    (2) 假\n    (3) 不确定\n*)",
    "votes": 0
  },
  {
    "id": 477,
    "src": "(** * Logic: Logic in Coq *)",
    "dst": "(** * Logic: Coq中的逻辑系统 *)",
    "votes": 0
  },
  {
    "id": 478,
    "src": "(** FULL: In previous chapters, we have seen many examples of factual\n    claims (_propositions_) and ways of presenting evidence of their\n    truth (_proofs_).  In particular, we have worked extensively with\n    _equality propositions_ of the form [e1 = e2], with\n    implications ([P -> Q]), and with quantified propositions ([forall\n    x, P]).  In this chapter, we will see how Coq can be used to carry\n    out other familiar forms of logical reasoning.\n\n    Before diving into details, let's talk a bit about the status of\n    mathematical statements in Coq.  Recall that Coq is a _typed_\n    language, which means that every sensible expression in its world\n    has an associated type.  Logical claims are no exception: any\n    statement we might try to prove in Coq has a type, namely [Prop],\n    the type of _propositions_.  We can see this with the [Check]\n    command: *)",
    "dst": "(** FULL:\n    在之前的章节中我们已经看到了很多有关事实性的声明（命题）和表达证实这些\n    声明的正确性的证据（即证明）的方法的许多例子。比如说，至今为止我们已经\n    做了许多[e1 = e2]这样的 _'相等性命题'_ ，形如[P -> Q]这样的主体为蕴含式\n    的命题，以及形如[forall x, P x]的量化命题的证明。\n    在接触更多相关的细节之前，让我们先探讨一下在Coq中数学表达式的地位。回忆\n    一下，Coq是一门 _'有类型的'_ 语言；在Coq的世界中，一切有意义的表达式都有其\n    类型。这类逻辑性的断言也是如此。所有我们试着去证明的命题在Coq中都有着[Prop]\n    这一 _'专门为命题设立的'_ 类型。我们可以用Check去查看这类命题的类型：  *)",
    "votes": 0
  },
  {
    "id": 479,
    "src": "(** We have seen...\n       - _propositions_: factual claims\n             - equality propositions ([e1 = e2])\n             - implications ([P -> Q])\n             - quantified propositions ([forall x, P])\n       - _proofs_: ways of presenting evidence for the truth of a\n          proposition\n\n    In this chapter we will see several more. *)",
    "dst": "(** 我们已经见到了……\n      - _'命题'_ ：事实性的声明\n          - 相等性命题（[e1 = e2]）\n          - 蕴含式（[P -> Q]）\n          - 量化命题（[forall x, P]）\n      - _'证明'_ ：展示某个命题的真实性的证据的方法\n      \n    在这一章中我们将会看到一些另外的命题和证明。\n     *)",
    "votes": 0
  },
  {
    "id": 480,
    "src": "(** Like everything in Coq, propositions are _typed_: *)",
    "dst": "(** 命题就像Coq中的一切事物一样都是 _'有类型'_ 的。　*)",
    "votes": 0
  },
  {
    "id": 481,
    "src": "(* ===> Prop *)",
    "dst": "(* ===> Prop *)",
    "votes": 0
  },
  {
    "id": 482,
    "src": "(** Note that _all_ syntactically well-formed propositions have type\n    [Prop] in Coq, regardless of whether they are true or not.\n\n    Simply _being_ a proposition is one thing; being _provable_ is\n    something else! *)",
    "dst": "(** 注意： _'所有语法上合法的命题的类型都为[Prop]'_ 。它们的类型与它们\n    是否为真命题无关： _'本身成为'_ 一个命题与 _'能得到这个命题的证明'_ \n    是不同的两回事。 *)",
    "votes": 0
  },
  {
    "id": 483,
    "src": "(** FULL: Indeed, propositions don't just have types: they are _first-class\n    objects_ that can be manipulated in the same ways as the other\n    entities in Coq's world.  So far, we've seen one primary place\n    that propositions can appear: in [Theorem] (and [Lemma] and\n    [Example]) declarations. *)",
    "dst": "(** FULL:\n    除了类型之外，命题也是所谓的 _'一等对象'_ ，即在Coq的世界中，我们可以像对\n    其他值进行操作一样对命题进行操作。到现在为止，我们已经知道命题可以在\n    [Theorem]（还有[Lemma]和[Example]）的定义中出现： *)",
    "votes": 0
  },
  {
    "id": 484,
    "src": "(** FULL: But propositions can be used in many other ways.  For example, we\n    can give a name to a proposition using a [Definition], just as we\n    have given names to expressions of other sorts. *)",
    "dst": "(** FULL:\n    但是它们同时也可以用于其他地方。比如说，就像我们用[Definition]给某些\n    函数或者其他类型的值取一个名字一样，我们可以用同样的方法为某些命题取\n    一个名字： *)",
    "votes": 0
  },
  {
    "id": 485,
    "src": "(** TERSE: Propositions are first-class entities in Coq.  For example,\n    we can name them: *)",
    "dst": "(** TERSE: \n    在Coq中命题也是第一等的实体。比如说，我们能给命题取名字： *)",
    "votes": 0
  },
  {
    "id": 486,
    "src": "(** FULL: We can later use this name in any situation where a proposition is\n    expected -- for example, as the claim in a [Theorem] declaration. *)",
    "dst": "(** FULL:\n    在这之后我们可以在任何需要填入一个命题的地方使用这个名字，例如在一个\n    Theorem声明中： *)",
    "votes": 0
  },
  {
    "id": 487,
    "src": "(** We can also write _parameterized_ propositions -- that is,\n    functions that take arguments of some type and return a\n    proposition. *)",
    "dst": "(** 我们也可以写出所谓 _'参数化'_ 的命题；它们实际上是一类函数：它们取某些\n    类型的值作为参数，并最终得到一个命题。 *)",
    "votes": 0
  },
  {
    "id": 488,
    "src": "(** FULL: For instance, the following function takes a number\n    and returns a proposition asserting that this number is equal to\n    three: *)",
    "dst": "(** FULL:\n    例如下面的这个函数；它取一个数字，并返回一个断言了这个数字等于3的命题。 *)",
    "votes": 0
  },
  {
    "id": 489,
    "src": "(** In Coq, functions that return propositions are said to define\n    _properties_ of their arguments.\n\n    For instance, here's a (polymorphic) property defining the\n    familiar notion of an _injective function_. *)",
    "dst": "(** 在Coq中，我们说那些返回一个命题的函数 _'定义了它们所取的参数的性质'_ 。\n    以下面这个多态函数为例子；它描述了 _'单射函数'_ 这个十分常见的概念。 *)",
    "votes": 0
  },
  {
    "id": 490,
    "src": "(** The equality operator [=] is also a function that returns a\n    [Prop].\n\n    The expression [n = m] is syntactic sugar for [eq n m], defined\n    using Coq's [Notation] mechanism. Because [eq] can be used with\n    elements of any type, it is also polymorphic: *)",
    "dst": "(** 相等性操作符 [=] 也是一个返回命题的函数：[n = m]是使用了Coq\n    的[Notation]机制定义的[eq n m]的语法糖。因为[eq]可以用在任意类型的\n    值上，所以它也是多态的：*)",
    "votes": 0
  },
  {
    "id": 491,
    "src": "(** FULL: (Notice that we wrote [@eq] instead of [eq]: The type\n    argument [A] to [eq] is declared as implicit, so we need to turn\n    off implicit arguments to see the full type of [eq].) *)",
    "dst": "(** FULL:\n    （注意在上面我们写的是[@eq]而不是[eq]；[eq]的类型参数[A]被定义成了\n    隐式参数，所以为了看到[eq]的完整的类型，我们需要通过[@]暂时取消对隐\n    式参数的处理。 *)",
    "votes": 0
  },
  {
    "id": 492,
    "src": "(** What is the type of the following expression?\n[[\n       pred (S O) = O\n]]\n   (1) [Prop]\n\n   (2) [nat->Prop]\n\n   (3) [forall n:nat, Prop]\n\n   (4) [nat->nat]\n\n   (5) Not typeable\n\n*)",
    "dst": "(** 下面的表达式的类型是？\n[[\n       pred (S O) = O\n]]\n   (1) [Prop]\n   (2) [nat->Prop]\n   (3) [forall n:nat, Prop]\n   (4) [nat->nat]\n   (5) 不可能给出类型\n*)",
    "votes": 0
  },
  {
    "id": 493,
    "src": "(** What is the type of the following expression?\n[[\n      forall n:nat, pred (S n) = n\n]]\n   (1) [Prop]\n\n   (2) [nat->Prop]\n\n   (3) [forall n:nat, Prop]\n\n   (4) [nat->nat]\n\n   (5) Not typeable\n\n*)",
    "dst": "(** 下面的表达式的类型是？\n[[\n      forall n:nat, pred (S n) = n\n]]\n   (1) [Prop]\n   (2) [nat->Prop]\n   (3) [forall n:nat, Prop]\n   (4) [nat->nat]\n   (5) 不可能给出类型\n*)",
    "votes": 0
  },
  {
    "id": 494,
    "src": "(** What is the type of the following expression?\n[[\n      forall n:nat, S (pred n) = n\n]]\n   (1) [Prop]\n\n   (2) [nat->Prop]\n\n   (3) [nat->nat]\n\n   (4) Not typeable\n\n*)",
    "dst": "(** 下面的表达式的类型是？\n[[\n      forall n:nat, S (pred n) = n\n]]\n   (1) [Prop]\n   (2) [nat->Prop]\n   (3) [nat->nat]\n   (4) 不可能给出类型\n*)",
    "votes": 0
  },
  {
    "id": 495,
    "src": "(** What is the type of the following expression?\n[[\n      forall n:nat, pred (S n)\n]]\n   (1) [Prop]\n\n   (2) [nat->Prop]\n\n   (3) [nat->nat]\n\n   (4) Not typeable\n*)",
    "dst": "(** 下面的表达式的类型是？\n[[\n      forall n:nat, pred (S n)\n]]\n   (1) [Prop]\n   (2) [nat->Prop]\n   (3) [nat->nat]\n   (4) 不可能给出类型\n*)",
    "votes": 0
  },
  {
    "id": 496,
    "src": "(** What is the type of the following expression?\n[[\n      fun n:nat => pred (S n)\n]]\n   (1) [Prop]\n\n   (2) [nat->Prop]\n\n   (3) [nat->nat]\n\n   (4) Not typeable\n*)",
    "dst": "(** 下面的表达式的类型是？\n[[\n      fun n:nat => pred (S n)\n]]\n   (1) [Prop]\n   (2) [nat->Prop]\n   (3) [nat->nat]\n   (4) 不可能给出类型\n*)",
    "votes": 0
  },
  {
    "id": 497,
    "src": "(** What is the type of the following expression?\n[[\n      fun n:nat  =>  pred (S n) = n\n]]\n   (1) [Prop]\n\n   (2) [nat->Prop]\n\n   (3) [nat->nat]\n\n   (4) Not typeable\n\n*)",
    "dst": "(** 下面的表达式的类型是？\n[[\n      fun n:nat  =>  pred (S n) = n\n]]\n   (1) [Prop]\n   (2) [nat->Prop]\n   (3) [nat->nat]\n   (4) 不可能给出类型\n*)",
    "votes": 0
  },
  {
    "id": 498,
    "src": "(** Which of the following is not a proposition?\n\n    (1) [3 + 2 = 4]\n\n    (2) [3 + 2 = 5]\n\n    (3) [beq_nat (3+2) 5]\n\n    (4) [beq_nat (3+2) 4 = false]\n\n    (5) [forall n, beq_nat (3+2) n = true -> n = 5]\n\n    (6) All of these are propositions\n*)",
    "dst": "(** 下面的表达式之中哪一个不是命题？\n    (1) [3 + 2 = 4]\n    (2) [3 + 2 = 5]\n    (3) [beq_nat (3+2) 5]\n    (4) [beq_nat (3+2) 4 = false]\n    (5) [forall n, beq_nat (3+2) n = true -> n = 5]\n    (6) 以上全部都是\n*)",
    "votes": 0
  },
  {
    "id": 499,
    "src": "(* #################################################################### *)",
    "dst": "(* #################################################################### *)",
    "votes": 0
  },
  {
    "id": 500,
    "src": "(** * Logical Connectives *)",
    "dst": "(** * 逻辑连接符 *)",
    "votes": 0
  },
  {
    "id": 501,
    "src": "(** ** Conjunction *)",
    "dst": "(** ** 合取（逻辑\"与\"） *)",
    "votes": 0
  },
  {
    "id": 502,
    "src": "(** The _conjunction_ (or _logical and_) of propositions [A] and [B]\n    is written [A /\\ B], representing the claim that both [A] and [B]\n    are true. *)",
    "dst": "(** 命题[A]与[B]的 _'合取'_ 或 _'逻辑与'_ 写作[A /\\ B]，表示一个宣称[A]和[B]都\n    为真的命题。 *)",
    "votes": 0
  },
  {
    "id": 503,
    "src": "(** To prove a conjunction, use the [split] tactic.  It will generate\n    two subgoals, one for each part of the statement: *)",
    "dst": "(** 证明合取命题一般用[split]这一证明策略；它会分别为组成合取的两个部分生成\n    子目标。 *)",
    "votes": 0
  },
  {
    "id": 504,
    "src": "(* 3 + 4 = 7 *)",
    "dst": "(* 3 + 4 = 7 *)",
    "votes": 0
  },
  {
    "id": 505,
    "src": "(* 2 + 2 = 4 *)",
    "dst": "(* 2 + 2 = 4 *)",
    "votes": 0
  },
  {
    "id": 506,
    "src": "(** For any propositions [A] and [B], if we assume that [A] is true\n    and we assume that [B] is true, we can conclude that [A /\\ B] is\n    also true. *)",
    "dst": "(** 对于任意的命题[A]和[B]，如果我们假设[A]为真而且我们也假设[B]为真，那么我\n    们能够得出[A /\\ B]也为真的结论。*)",
    "votes": 0
  },
  {
    "id": 507,
    "src": "(** Since applying a theorem with hypotheses to some goal has the\n    effect of generating as many subgoals as there are hypotheses for\n    that theorem, we can apply [and_intro] to achieve the same effect\n    as [split]. *)",
    "dst": "(** 因为定理的应用会产生与假设的个数相等的子目标，我们能够通过应用[and_intro]\n    来得到与使用[split]一样的结果。*)",
    "votes": 0
  },
  {
    "id": 508,
    "src": "(* EX2 (and_exercise) *)",
    "dst": "(* EX2 (and_exercise) *)",
    "votes": 0
  },
  {
    "id": 509,
    "src": "(** So much for proving conjunctive statements.  To go in the other\n    direction -- i.e., to _use_ a conjunctive hypothesis to help prove\n    something else -- we employ the [destruct] tactic.\n\n    If the proof context contains a hypothesis [H] of the form\n    [A /\\ B], writing [destruct H as [HA HB]] will remove [H] from the\n    context and add two new hypotheses: [HA], stating that [A] is\n    true, and [HB], stating that [B] is true.  *)",
    "dst": "(** 以上就是与证明合取有关的内容。在进行相反方向的操作，即在证明过程中需要 _'使用'_ \n    某个合取假设的时候，一般使用[destruct]。\n    如果当前证明上下文中存在形如[A /\\ B]的假设[H]，[destruct H as [HA HB]]将会从上\n    下文中去掉[H]并增加[HA]和[HB]这两个新的假设，其中前者宣称[A]为真，而后者宣称[B]\n    为真。 *)",
    "votes": 0
  },
  {
    "id": 510,
    "src": "(** As usual, we can also destruct [H] right when we introduce it,\n    instead of introducing and then destructing it: *)",
    "dst": "(** 我们也能够在将[H]引入当前上下文的同时对其进行解构： *)",
    "votes": 0
  },
  {
    "id": 511,
    "src": "(** You may wonder why we bothered packing the two hypotheses [n = 0]\n    and [m = 0] into a single conjunction, since we could have also\n    stated the theorem with two separate premises: *)",
    "dst": "(** 也许你会想，我们完全可以将[n = 0]和[m = 0]写成分开的两个假设，为什么\n    我们仍然要不厌其烦地将这两个假设包在一个单独的合取之中呢？*)",
    "votes": 0
  },
  {
    "id": 512,
    "src": "(** For this theorem, both formulations are fine.  But it's important\n    to understand how to work with conjunctive hypotheses because\n    conjunctions often arise from intermediate steps in proofs,\n    especially in bigger developments.  Here's a simple example: *)",
    "dst": "(** 单纯地就这个定理而言两种都可以，但是我们需要理解如何对合取假设进行操作，\n    因为这样的假设经常在证明的中途出现，特别是在进行较为大型的开发的时候。\n    这里就有这样的一个比较简单的例子： *)",
    "votes": 0
  },
  {
    "id": 513,
    "src": "(** Another common situation with conjunctions is that we know\n    [A /\\ B] but in some context we need just [A] (or just [B]).\n    The following lemmas are useful in such cases: *)",
    "dst": "(** 另外一个经常碰见的场合，就是我们已经知道了[A /\\ B]，但是我们只需要[A]或\n    者[B]的时候。以下的引理对于应付这样的状况而言会很有用： *)",
    "votes": 0
  },
  {
    "id": 514,
    "src": "(** Finally, we sometimes need to rearrange the order of conjunctions\n    and/or the grouping of multi-way conjunctions.  The following\n    commutativity and associativity theorems are handy in such\n    cases. *)",
    "dst": "(** 最后，我们有时也需要改变由多个命题组成的合取中某些部分所在的位置。以下的\n    引理对于应付这样的状况而言会很有用： *)",
    "votes": 0
  },
  {
    "id": 515,
    "src": "(** (In the following proof of associativity, notice how the _nested_\n    intro pattern breaks the hypothesis [H : P /\\ (Q /\\ R)] down into\n    [HP : P], [HQ : Q], and [HR : R].  Finish the proof from\n    there.) *)",
    "dst": "(** （留意一下[intros]后面所使用的 _'嵌套'_ 的模式是如何将假设[H : P /\\ (Q /\\ R)]\n    分解为[HP : P]，[HQ : Q]和[HR : R]这三个互相独立的假设的。从那个地方开始完\n    成这个证明。） *)",
    "votes": 0
  },
  {
    "id": 516,
    "src": "(** By the way, the infix notation [/\\] is actually just syntactic\n    sugar for [and A B].  That is, [and] is a Coq operator that takes\n    two propositions as arguments and yields a proposition. *)",
    "dst": "(** 顺带一提，[/\\]这一中缀记号只是[and A B]的语法糖而已；[and]才是Coq里将两个命题\n    合并得到合取命题的操作符。 *)",
    "votes": 0
  },
  {
    "id": 517,
    "src": "(** ** Disjunction *)",
    "dst": "(** ** 析取 *)",
    "votes": 0
  },
  {
    "id": 518,
    "src": "(** Another important connective is the _disjunction_, or _logical or_\n    of two propositions: [A \\/ B] is true when either [A] or [B]\n    is.  (Alternatively, we can write [or A B], where [or : Prop ->\n    Prop -> Prop].)\n\n    To use a disjunctive hypothesis in a proof, we proceed by case\n    analysis, which, as for [nat] or other data types, can be done\n    with [destruct] or [intros].  Here is an example: *)",
    "dst": "(** 另外一个重要的连接符是所谓的 _'析取'_ ，或者 _'逻辑与'_ 连接符。对于任意两个命题[A]\n    和[B]，其析取[A \\/ B]在[A]与[B]之中的任意一个命题为真时为真。（或者，我们可以写\n    [or A B]，其中[or : Prop -> Prop -> Prop]。）\n    使用某个析取假设的时候，我们使用分类讨论；就像对[nat]以及其他的数据类���进行分类\n    讨论一样，对析取假设进行分类讨论时我们也可以使用像[destruct]或者[intros]这样的\n    证明策略。以下是一个对析取假设进行分类讨论的例子： *)",
    "votes": 0
  },
  {
    "id": 519,
    "src": "(* This pattern implicitly does case analysis on\n     [n = 0 \\/ m = 0] *)",
    "dst": "(* 这个模式会自动对[n = 0 \\/ m = 0]作出分类讨论。 *)",
    "votes": 0
  },
  {
    "id": 520,
    "src": "(* Here, [n = 0] *)",
    "dst": "(* 在这里存在[n = 0] *)",
    "votes": 0
  },
  {
    "id": 521,
    "src": "(* Here, [m = 0] *)",
    "dst": "(* 在这里存在[m = 0] *)",
    "votes": 0
  },
  {
    "id": 522,
    "src": "(** TERSE: We can see in this example that, when we perform case analysis on\n    a disjunction [A \\/ B], we must satisfy two proof obligations,\n    each showing that the conclusion holds under a different\n    assumption -- [A] in the first subgoal and [B] in the second.\n    Note that the case analysis pattern ([Hn | Hm]) allows us to name\n    the hypotheses that are generated in the subgoals. *)",
    "dst": "(** TERSE: \n    从这个例子我们能够看到，当我们对某个析取[A \\/ B]进行分类讨论的时候，我们必须\n    完成两个证明的任务，即分别在不同的假设下证明同一个命题成立：在第一个子目标中\n    我们假设[A]，而在第二个子目标中我们则假设[B]。注意，我们能够在用于进行分类讨\n    论的模式（[Hn | Hm]）中对子目标中生成���假设进行命名。 *)",
    "votes": 0
  },
  {
    "id": 523,
    "src": "(** Conversely, to show that a disjunction holds, we need to show that\n    one of its sides does. This is done via two tactics, [left] and\n    [right].  As their names imply, the first one requires\n    proving the left side of the disjunction, while the second\n    requires proving its right side.  Here is a trivial use... *)",
    "dst": "(** 相对应地，要证明某个析取命题为真，我们需要证明它任意一边的命题为真。我们用[left]\n    和[right]这两种证明策略来作出这种选择。就像它们的名字所说的那样，[left]将会选择\n    待证的析取命题的左边，而[right]将会选择右边。\n    下面是一个很简单的例子：*)",
    "votes": 0
  },
  {
    "id": 524,
    "src": "(** ... and a slightly more interesting example requiring both [left]\n    and [right]: *)",
    "dst": "(** 这个更为有趣的例子则需要在同一个证明中使用[left]和[right]： *)",
    "votes": 0
  },
  {
    "id": 525,
    "src": "(** ** Falsehood and Negation *)",
    "dst": "(** ** 假命题与否定 *)",
    "votes": 0
  },
  {
    "id": 526,
    "src": "(** So far, we have mostly been concerned with proving that certain\n    things are _true_ -- addition is commutative, appending lists is\n    associative, etc.  Of course, we may also be interested in\n    _negative_ results, showing that certain propositions are _not_\n    true. In Coq, such negative statements are expressed with the\n    negation operator [~].\n\n    To see how negation works, recall the discussion of the _principle\n    of explosion_ from the \\CHAP{Tactics} chapter; it asserts that, if we\n    assume a contradiction, then any other proposition can be derived.\n    Following this intuition, we could define [~ P] (\"not [P]\") as\n    [forall Q, P -> Q].  Coq actually makes a slightly different\n    choice, defining [~ P] as [P -> False], where [False] is a\n    _particular_ contradictory proposition defined in the standard\n    library. *)",
    "dst": "(** 到现在为止我们主要都在证明某些东西 _'是真的'_ ，比如说加法真的符合交换律，\n    列表之间的连接真的符合结合律等等；我们当然也有可能对一些 _'否定'_ 的，证明\n    了某些命题 _'并非为真'_ 的事物产生兴趣。在Coq中，我们使用否定操作符[~]否定\n    某个命题。\n    为了理解否定背后的原理，回想一下在\\CHAP{Tactics}一章中有关 _'爆炸原理'_ 的\n    相关讨论；爆炸原理断言，当我们假设了矛盾的存在时，我们可以证明任意命题。\n    遵循着这一直觉，我们可以将[~ P]（即“非[P]”）定义为[forall Q, P -> Q]；\n    但Coq选择了另外一种稍微有些不同的做法：它将[~ P]定义为[P -> False]，而\n    [False]是在标准库中 _'被特别地定义了的'_ 矛盾性的命题。 *)",
    "votes": 0
  },
  {
    "id": 527,
    "src": "(** Since [False] is a contradictory proposition, the principle of\n    explosion also applies to it. If we get [False] into the proof\n    context, we can [destruct] it to complete any goal: *)",
    "dst": "(** 因为[False]是矛盾性的命题，我们也可以对其应用爆炸原理：如果我们在证明上下文\n    中得到了一个[False]，我们可以[destruct]它，并证明任何当前待证明的目标。 *)",
    "votes": 0
  },
  {
    "id": 528,
    "src": "(** FULL: The Latin _ex falso quodlibet_ means, literally, \"from falsehood\n    follows whatever you like\"; this is another common name for the\n    principle of explosion. *)",
    "dst": "(** FULL:\n    _Ex falso quodlibet_ 是拉丁文，意思是“从谬误出发你能够证明任何你想要的”；\n    这是爆炸原理的另一个为人熟知的名字。 *)",
    "votes": 0
  },
  {
    "id": 529,
    "src": "(** Show that Coq's definition of negation implies the intuitive one\n    mentioned above: *)",
    "dst": "(** 证明对于任意命题[P]，从Coq对于[~ P]的定义能够推出上面提到的对于否定的定义。 *)",
    "votes": 0
  },
  {
    "id": 530,
    "src": "(** This is how we use [not] to state that [0] and [1] are different\n    elements of [nat]: *)",
    "dst": "(** 以下是我们用[not]宣称并证明“[0]和[1]是不同的[nat]”这一命题的做法： *)",
    "votes": 0
  },
  {
    "id": 531,
    "src": "(** Such inequality statements are frequent enough to warrant a\n    special notation, [x <> y]: *)",
    "dst": "(** 这样的有关不相等的命题出现得十分频繁，足以让我们为其定义一个独立的表示法：\n    [x <> y]。 *)",
    "votes": 0
  },
  {
    "id": 532,
    "src": "(** It takes a little practice to get used to working with negation in\n    Coq.  Even though you can see perfectly well why a statement\n    involving negation is true, it can be a little tricky at first to\n    get things into the right configuration so that Coq can understand\n    it!  Here are proofs of a few familiar facts to get you warmed\n    up. *)",
    "dst": "(** 在能够熟练地在Coq中对否定命题进行操作之前确实需要一点练习：即使有时你已经很\n    清楚为什么某个否定命题为真，刚开始试图通过适当的设置让Coq接受这一点可能也会\n    稍微有些困难。以下是一些作为热身的有关一些常见的事实的证明：*)",
    "votes": 0
  },
  {
    "id": 533,
    "src": "(** Write an informal proof of [double_neg]:\n\n   _Theorem_: [P] implies [~~P], for any proposition [P]. *)",
    "dst": "(** 写出[double_neg]，即下述命题的一个非形式化的证明：\n    命题：对任意命题[P]而言，[P]蕴含[~~P]。 *)",
    "votes": 0
  },
  {
    "id": 534,
    "src": "(* _Proof_:\n   Let a proposition [P] be given, and suppose we have\n   evidence for [P].  We must show [~~P] -- i.e., [~P -> False], so\n   suppose [~P] as well and try to derive [False].\n   Then we have both [P] and [~P] (i.e., [P -> False]) from which\n   we can indeed derive [False].  So [~~P] holds. *)",
    "dst": "(* _Proof_:\n   假设对于某个给定的命题[P]我们有[P]的证明，我们需要证明[~~P]，也就是\n   [~P -> False]，所以我们假设[~P]并试图证明[False]。在此时我们同时有\n   [P]和[~P]（也就是[P -> False]）；我们当然很容易就能够从这两个假设推\n   出[False]。所以[~~P]成立。 *)",
    "votes": 0
  },
  {
    "id": 535,
    "src": "(** Write an informal proof (in English) of the proposition [forall P\n    : Prop, ~(P /\\ ~P)]. *)",
    "dst": "(** 写出[forall P : Prop, ~ (P /\\ ~P)]这一命题的非形式化的证明。你可以使用\n    任何你想用的自然语言。 *)",
    "votes": 0
  },
  {
    "id": 536,
    "src": "(* _Proof_: Suppose, for some [P], that [(P /\\ ~P)] holds.  Recall\n  that [~P] is defined as [P -> False].  Given [P] and [P -> False],\n  we can prove [False], so [(P /\\ ~P) -> False], i.e., [~ (P /\\ ~P)].\n*)",
    "dst": "(* _Proof_:\n  假设对于某些命题[P]有[(P /\\ ~P)]。因为[~P]就是[P -> False]，所以我们同时有\n  [P]和[P -> False]；从这一点我们能够证明[False]，即我们能够证明[(P /\\ ~P) -> False]，\n  也就是[~ (P /\\ ~P)]。\n*)",
    "votes": 0
  },
  {
    "id": 537,
    "src": "(** Similarly, since inequality involves a negation, it requires a\n    little practice to be able to work with it fluently.  Here is one\n    useful trick.  If you are trying to prove a goal that is\n    nonsensical (e.g., the goal state is [false = true]), apply\n    [ex_falso_quodlibet] to change the goal to [False].  This makes it\n    easier to use assumptions of the form [~P] that may be available\n    in the context -- in particular, assumptions of the form\n    [x<>y]. *)",
    "dst": "(** 类似地，因为不等式包含了一个否定，在能够熟练地使用它之前也需要一定的练习。\n    这里是一个比较有用的小技巧：如果你需要证明某个不可能的目标（例如当前的子目\n    标是[false = true]）时，用[ex_falso_quodlibet]将这个目标转换成[False]；\n    如果当前���证明上下文中存在形如[~P]的假设（例如形如[x<>y]的假设），那么这会\n    让这些假设的使用变得更容易些。*)",
    "votes": 0
  },
  {
    "id": 538,
    "src": "(** Since reasoning with [ex_falso_quodlibet] is quite common, Coq\n    provides a built-in tactic, [exfalso], for applying it. *)",
    "dst": "(** 因为我们经常会用到[ex_falso_quodlibet]，所以Coq提供了一个内置的证明策略：\n    [exfalso]；这个策略在被使用时相当于应用了[ex_falso_quodlibet]。*)",
    "votes": 0
  },
  {
    "id": 539,
    "src": "(** To prove the following proposition, which tactics will we need\n    besides [intros] and [apply]?\n[[\n        forall X, forall a b : X, (a=b) /\\ (a<>b) -> False.\n]]\n\n    (1) [destruct], [unfold], [left] and [right]\n\n    (2) [destruct] and [unfold]\n\n    (3) only [destruct]\n\n    (4) one of [left] and [right]\n\n    (5) only [unfold]\n\n    (6) none of the above\n\n*)",
    "dst": "(** 为了证明下述的命题，除了[intros]和[apply]以外我们还需要哪些证明策略？\n[[\n        forall X, forall a b : X, (a=b) /\\ (a<>b) -> False.\n]]\n    (1) [destruct]，[unfold]，[left]和[right]\n    (2) [destruct]和[unfold]\n    (3) [destruct]\n    (4) [left]，或者[right]\n    (5) [unfold]\n    (6) 以上都不是\n*)",
    "votes": 0
  },
  {
    "id": 540,
    "src": "(** To prove the following proposition, which tactics will we\n    need besides [intros] and [apply]?\n[[\n        forall P Q : Prop,  P \\/ Q -> ~~(P \\/ Q).\n]]\n\n    (1) [destruct], [unfold], [left] and [right]\n\n    (2) [destruct] and [unfold]\n\n    (3) only [destruct]\n\n    (4) one of [left] and [right]\n\n    (5) only [unfold]\n\n    (6) none of the above\n\n*)",
    "dst": "(** 为了证明下述的命题，除了[intros]和[apply]以外我们还需要哪些证明策略？\n[[\n        forall P Q : Prop,  P \\/ Q -> ~~(P \\/ Q).\n]]\n    (1) [destruct]，[unfold]，[left]和[right]\n    (2) [destruct]和[unfold]\n    (3) [destruct]\n    (4) [left]，或者[right]\n    (5) [unfold]\n    (6) 以上都不是\n*)",
    "votes": 0
  },
  {
    "id": 541,
    "src": "(** To prove the following proposition, which tactics will we\n    need besides [intros] and [apply]?\n[[\n         forall A B: Prop, A -> (A \\/ ~~B).\n]]\n\n    (1) [destruct], [unfold], [left] and [right]\n\n    (2) [destruct] and [unfold]\n\n    (3) only [destruct]\n\n    (4) one of [left] and [right]\n\n    (5) only [unfold]\n\n    (6) none of the above\n\n*)",
    "dst": "(** 为了证明下述的命题，除了[intros]和[apply]以外我们还需要哪些证明策略？\n[[\n         forall A B: Prop, A -> (A \\/ ~~B).\n]]\n    (1) [destruct]，[unfold]，[left]和[right]\n    (2) [destruct]和[unfold]\n    (3) [destruct]\n    (4) [left]，或者[right]\n    (5) [unfold]\n    (6) 以上都不是\n*)",
    "votes": 0
  },
  {
    "id": 542,
    "src": "(** To prove the following proposition, which tactics will we need\n    besides [intros] and [apply]?\n[[\n         forall P Q: Prop,  P \\/ Q -> ~~P \\/ ~~Q.\n]]\n\n    (1) [destruct], [unfold], [left] and [right]\n\n    (2) [destruct] and [unfold]\n\n    (3) only [destruct]\n\n    (4) both [left] and [right]\n\n    (5) only [unfold]\n\n    (6) none of the above\n\n*)",
    "dst": "(** 为了证明下述的命题，除了[intros]和[apply]以外我们还需要哪些证明策略？\n[[\n         forall P Q: Prop,  P \\/ Q -> ~~P \\/ ~~Q.\n]]\n    (1) [destruct]，[unfold]，[left]和[right]\n    (2) [destruct]和[unfold]\n    (3) [destruct]\n    (4) [left]和[right]\n    (5) [unfold]\n    (6) 以上都不是\n*)",
    "votes": 0
  },
  {
    "id": 543,
    "src": "(** To prove the following proposition, which tactics will we need\n    besides [intros] and [apply]?\n[[\n         forall A : Prop, 1=0 -> (A \\/ ~A).\n]]\n\n    (1) [inversion], [unfold], [left] and [right]\n\n    (2) [inversion] and [unfold]\n\n    (3) only [inversion]\n\n    (4) one of [left] and [right]\n\n    (5) only [unfold]\n\n    (6) none of the above\n\n*)",
    "dst": "(** 为了证明下述的命题，除了[intros]和[apply]以外我们还需要哪些证明策略？\n[[\n         forall A : Prop, 1=0 -> (A \\/ ~A).\n]]\n    (1) [inversion]，[unfold]，[left]和[right]\n    (2) [inversion]和[unfold]\n    (3) [inversion]\n    (4) [left]，或者[right]\n    (5) [unfold]\n    (6) 以上都不是\n*)",
    "votes": 0
  },
  {
    "id": 544,
    "src": "(** ** Truth *)",
    "dst": "(** ** 真值 *)",
    "votes": 0
  },
  {
    "id": 545,
    "src": "(** Besides [False], Coq's standard library also defines [True], a\n    proposition that is trivially true. To prove it, we use the\n    predefined constant [I : True]: *)",
    "dst": "(** 除了[False]以外，Coq的标准库中也定义了[True]这一十分容易就能证明的命题。\n    我们用[I : True]这一事先定义了的常数来证明[True]： *)",
    "votes": 0
  },
  {
    "id": 546,
    "src": "(** Unlike [False], which is used extensively, [True] is used quite\n    rarely, since it is trivial (and therefore uninteresting) to prove\n    as a goal, and it carries no useful information as a hypothesis.\n(* FULL *)\n    But it can be quite useful when defining complex [Prop]s using\n    conditionals or as a parameter to higher-order [Prop]s.  We will\n    see examples of such uses of [True] later on.\n(* /FULL *)\n*)",
    "dst": "(** 与经常被使用的[False]不同，因为证明过于简单（所以也就没什么足以引起兴趣的\n    东西）而且并不携带任何有用的信息，[True]很少被使用。\n(* FULL *)\n    然而在使用条件从句构建更加复杂的[Prop]或者作为高阶[Prop]的一个参数的时候它\n    也可以变得十分有用。以后我们将会看到[True]的这类用法。\n(* /FULL *)\n*)",
    "votes": 0
  },
  {
    "id": 547,
    "src": "(** ** Logical Equivalence *)",
    "dst": "(** ** 逻辑上的相等性 Logical Equivalence *)",
    "votes": 0
  },
  {
    "id": 548,
    "src": "(** The handy \"if and only if\" connective, which asserts that two\n    propositions have the same truth value, is just the conjunction of\n    two implications. *)",
    "dst": "(** “当且仅当”这一逻辑连接符用起来十分顺手；它是两个蕴含式的合取，声明两个命题\n    在任何情况下都有着相同的真值。 *)",
    "votes": 0
  },
  {
    "id": 549,
    "src": "(* -> *)",
    "dst": "(* -> *)",
    "votes": 0
  },
  {
    "id": 550,
    "src": "(* <- *)",
    "dst": "(* <- *)",
    "votes": 0
  },
  {
    "id": 551,
    "src": "(** Using the above proof that [<->] is symmetric ([iff_sym]) as\n    a guide, prove that it is also reflexive and transitive. *)",
    "dst": "(** 以上面的[<->]的对称性（[iff_sym]）的证明作为参照，证明[<->]同时也\n    有自反性和传递性。 *)",
    "votes": 0
  },
  {
    "id": 552,
    "src": "(** Some of Coq's tactics treat [iff] statements specially, avoiding\n    the need for some low-level proof-state manipulation.  In\n    particular, [rewrite] and [reflexivity] can be used with [iff]\n    statements, not just equalities.  To enable this behavior, we need\n    to import a special Coq library that allows rewriting with other\n    formulas besides equality: *)",
    "dst": "(** Coq的某些证明策略会以特别的方式处理[iff]，并以此避免了某些底层的对证明\n    状态的操作。比如说，[rewrite]和[reflexivity]除了可以对等式使用以外同样\n    也可以对[iff]使用。你需要加载一个特别的Coq库来让Coq允许你使用等式以外的\n    式子进行重写。 *)",
    "votes": 0
  },
  {
    "id": 553,
    "src": "(** Here is a simple example demonstrating how these tactics work with\n    [iff].  First, let's prove a couple of basic iff equivalences... *)",
    "dst": "(** 以下是一个简单的例子；它展示了这些证明策略会如何使用[iff]。\n    首先，先让我们证明一些比较基本的[iff]等价命题…… *)",
    "votes": 0
  },
  {
    "id": 554,
    "src": "(** We can now use these facts with [rewrite] and [reflexivity] to\n    give smooth proofs of statements involving equivalences.  Here is\n    a ternary version of the previous [mult_0] result: *)",
    "dst": "(** 现在我们能够在某些与等价性相关的命题的证明中使用[rewrite]和[reflexivity]\n    的时候使用这些事实。这里是上述的[mult_0]的、包含了三个变量的版本： *)",
    "votes": 0
  },
  {
    "id": 555,
    "src": "(** The [apply] tactic can also be used with [<->]. When given an\n    equivalence as its argument, [apply] tries to guess which side of\n    the equivalence to use. *)",
    "dst": "(** [apply]也可以与[<->]一同使用。当[apply]的参数是一个等价性命题的证明，它将\n    试图猜出使用该命题所包含的哪一个方向的蕴含式。 *)",
    "votes": 0
  },
  {
    "id": 556,
    "src": "(** ** Existential Quantification *)",
    "dst": "(** ** 存在量化 *)",
    "votes": 0
  },
  {
    "id": 557,
    "src": "(** FULL: Another important logical connective is _existential\n    quantification_.  To say that there is some [x] of type [T] such\n    that some property [P] holds of [x], we write [exists x : T,\n    P]. As with [forall], the type annotation [: T] can be omitted if\n    Coq is able to infer from the context what the type of [x] should\n    be. *)",
    "dst": "(** FULL:\n   '_   存在量化 '_ 也是十分重要的逻辑连接符。我们用[exists x : T, P]表示存在一些\n    类型为[T]的[x]使得一些性质[P]对于[x]成立。如果Coq能够从上下文中推断出[x]的\n    类型应该为[T]，那么就像[forall]中我们可以省略[x]的类型标注一样，在[exists]中\n    我们也可以省略[: T]这一类型标注。 *)",
    "votes": 0
  },
  {
    "id": 558,
    "src": "(** To prove a statement of the form [exists x, P], we must show that\n    [P] holds for some specific choice of value for [x], known as the\n    _witness_ of the existential.  This is done in two steps: First,\n    we explicitly tell Coq which witness [t] we have in mind by\n    invoking the tactic [exists t].  Then we prove that [P] holds after\n    all occurrences of [x] are replaced by [t]. *)",
    "dst": "(** 证明形如[exists x, P]的命题时我们需要证明[P]对于一些特定的[x]是成立的；这些\n    [x]被称作证实了这一命题的 _' 实例 '_ 。证明分为两个步骤：首先用[exists t]指出\n    我们已经知道的可以使[P]成立的实例[t]，然后我们证明所有[x]都被替换成[t]的命题\n    [P]。 *)",
    "votes": 0
  },
  {
    "id": 559,
    "src": "(** Conversely, if we have an existential hypothesis [exists x, P] in\n    the context, we can destruct it to obtain a witness [x] and a\n    hypothesis stating that [P] holds of [x]. *)",
    "dst": "(** 相反地，如果我们在上下文中有形如[exists x, P]的存在假设，我们可以将其解构得到\n    某个实例[x]以及证实[P]对[x]成立的证据。 *)",
    "votes": 0
  },
  {
    "id": 560,
    "src": "(** Prove that \"[P] holds for all [x]\" implies \"there is no [x] for\n    which [P] does not hold.\" *)",
    "dst": "(** 证明这一命题：如果[P]对所有[x]成立，那么没有使得[P]不成立的[x]。 *)",
    "votes": 0
  },
  {
    "id": 561,
    "src": "(** FULL: Prove that existential quantification distributes over\n    disjunction. *)",
    "dst": "(** FULL: 证明存在量化对析取符合分配律。 *)",
    "votes": 0
  },
  {
    "id": 562,
    "src": "(* P x *)",
    "dst": "(* P x *)",
    "votes": 0
  },
  {
    "id": 563,
    "src": "(* Q x *)",
    "dst": "(* Q x *)",
    "votes": 0
  },
  {
    "id": 564,
    "src": "(* exists x, P x *)",
    "dst": "(* exists x, P x *)",
    "votes": 0
  },
  {
    "id": 565,
    "src": "(* exists x, Q x *)",
    "dst": "(* exists x, Q x *)",
    "votes": 0
  },
  {
    "id": 566,
    "src": "(** * Programming with Propositions *)",
    "dst": "(** * 在编程中使用命题  *)",
    "votes": 0
  },
  {
    "id": 567,
    "src": "(** FULL: The logical connectives that we have seen provide a rich\n    vocabulary for defining complex propositions from simpler ones.\n    To illustrate, let's look at how to express the claim that an\n    element [x] occurs in a list [l].  Notice that this property has a\n    simple recursive structure: *)",
    "dst": "(** FULL:\n    我们所了解的逻辑连接符大幅提升了我们以简单的命题为基础构建更为复杂的命题的能力。\n    作为例子，让我们来思考如何表示“某个元素[x]出现在某个列表[l]之中”这一命题。注意到\n    这一性质有着很简单的递归结构：*)",
    "votes": 0
  },
  {
    "id": 568,
    "src": "(** TERSE: What does it mean to say that \"an element [x] occurs in a\n    list [l]\"?  *)",
    "dst": "(** TERSE: 「某个元素[x]在列表[l]中出现」实际上是什么意思？ *)",
    "votes": 0
  },
  {
    "id": 569,
    "src": "(** - If [l] is the empty list, then [x] cannot occur on it, so the\n      property \"[x] appears in [l]\" is simply false.\n\n    - Otherwise, [l] has the form [x' :: l'].  In this case, [x]\n      occurs in [l] if either it is equal to [x'] or it occurs in\n      [l'].\n\n    We can translate this directly into a straightforward recursive\n    function from taking an element and a list and returning a\n    proposition: *)",
    "dst": "(** - 如果[l]是空列表，那么[x]不可能在[l]中出现；所以“[x]在[l]中出现”应该为假命题。\n    - 如果[l]为形如[x' :: l']的列表，那么“[x]在[l]中出现”的正确性取决于[x]是否与[x']\n      相等或者[x]是否在[l']出现。\n \n    我们能够将这一定义直接翻译成一个递归函数；这个函数将取一个元素和一个列表作为参数\n    并返回一个命题：*)",
    "votes": 0
  },
  {
    "id": 570,
    "src": "(** When [In] is applied to a concrete list, it expands into a\n    concrete sequence of nested disjunctions. *)",
    "dst": "(** 当[In]被应用于某个具体的列表时，它将被展开为一串由具体的命题组成的\n    析取式。*)",
    "votes": 0
  },
  {
    "id": 571,
    "src": "(** (Notice the use of the empty pattern to discharge the last case\n    _en passant_.) *)",
    "dst": "(** （注意，在上面的例子中我们使用了空模式来 _'无视'_ 最后一种情况。） *)",
    "votes": 0
  },
  {
    "id": 572,
    "src": "(** We can also prove more generic, higher-level lemmas about [In].\n\n    Note, in the next, how [In] starts out applied to a variable and\n    only gets expanded when we do case analysis on this variable: *)",
    "dst": "(** 我们也可以证明关于[In]的一些更为一般的，或者更为高阶的引理。\n    注意在下面[In]被应用到一个变量上；只有我们对其进行分类讨论的时候，它才会\n    被展开。 *)",
    "votes": 0
  },
  {
    "id": 573,
    "src": "(* l = nil, contradiction *)",
    "dst": "(* l = nil，矛盾 *)",
    "votes": 0
  },
  {
    "id": 574,
    "src": "(** This way of defining propositions recursively, though convenient\n    in some cases, also has some drawbacks.  In particular, it is\n    subject to Coq's usual restrictions regarding the definition of\n    recursive functions, e.g., the requirement that they be \"obviously\n    terminating.\"  In the next chapter, we will see how to define\n    propositions _inductively_, a different technique with its own set\n    of strengths and limitations. *)",
    "dst": "(** 虽然递归地定义命题在某些情况下会十分方便，但是这种方法也有其劣势。比如说，\n    作为一种递归函数，这类命题也会受Coq对递归函数的要求的限制：在Coq中递归函数\n    必须是“明显可停机”的。在下一章我们将会了解如何 _'归纳地'_ 定义一个命题；这是\n    一种与之不���的技巧，有着其独特的优势和劣势。*)",
    "votes": 0
  },
  {
    "id": 575,
    "src": "(** Recall that functions returning propositions can be seen as\n    _properties_ of their arguments. For instance, if [P] has type\n    [nat -> Prop], then [P n] states that property [P] holds of [n].\n\n    Drawing inspiration from [In], write a recursive function [All]\n    stating that some property [P] holds of all elements of a list\n    [l]. To make sure your definition is correct, prove the [All_In]\n    lemma below.  (Of course, your definition should _not_ just\n    restate the left-hand side of [All_In].) *)",
    "dst": "(** 回忆一下，返回命题的函数能够被视为对其参数的某种 _'性质'_ 的定义。比如说，\n    假设[P]的类型为[nat -> Prop]，那么[P n]就是声明[n]拥有性质[P]的命题。\n    以[In]作为参考，完成[All]这一递归函数的定义；它以某个列表[l]以���针对其元素\n    的性质[P]为参数，返回一个声明“[l]中全部元素都具有性质[P]”的命题。证明[All_In]\n    这一引理以对你的定义进行测试。当然了，为了通过测试而直接将[All_In]的左半部分\n    写入[All]的定义是 _'不被接受的'_ 。\n  *)",
    "votes": 0
  },
  {
    "id": 576,
    "src": "(** Complete the definition of the [combine_odd_even] function below.\n    It takes as arguments two properties of numbers, [Podd] and\n    [Peven], and it should return a property [P] such that [P n] is\n    equivalent to [Podd n] when [n] is odd and equivalent to [Peven n]\n    otherwise. *)",
    "dst": "(** 完成[combine_odd_even]的定义；它取两个针对数字的性质作为它的两个参数\n    [Podd]和[Peven]，并返回这样的性质[P]：[P n]在[n]为奇数的时候等价于[Podd n]，\n    在[n]为偶数的时候等价于[Peven n]。 *)",
    "votes": 0
  },
  {
    "id": 577,
    "src": "(** To test your definition, prove the following facts: *)",
    "dst": "(** 证明下述的事实以测试你的定义是否正确。 *)",
    "votes": 0
  },
  {
    "id": 578,
    "src": "(** FULL: One feature of Coq that distinguishes it from many other proof\n    assistants is that it treats _proofs_ as first-class objects.\n\n    There is a great deal to be said about this, but it is not\n    necessary to understand it in detail in order to use Coq.  This\n    section gives just a taste, while a deeper exploration can be\n    found in the optional chapters [ProofObjects] and\n    [IndPrinciples]. *)",
    "dst": "(** FULL:\n    Coq拥有一个将它从其他证明助理区分开来的特性：它将 _'证明本身'_ 也作为\n    第一等的值。在这一点的背后有许多更深入的细节，但是对于使用Coq而言这\n    些细节并不是必须要了解的事实。这一节只是对相关内容进行一点简单的说明；\n    更多的细节可以在[ProofObjects]和[IndPrinciples]这两个可���的章节中得知。 *)",
    "votes": 0
  },
  {
    "id": 579,
    "src": "(** TERSE: Coq also treats _proofs_ as first-class objects! *)",
    "dst": "(** TERSE:\n    Coq也将 _'证明'_ 当作第一等的对象。 *)",
    "votes": 0
  },
  {
    "id": 580,
    "src": "(** We have seen that we can use the [Check] command to ask Coq to\n    print the type of an expression.  We can also use [Check] to ask\n    what theorem a particular identifier refers to. *)",
    "dst": "(** 我们已经知道[Check]可以显示一个表达式的类型；我们也可以用[Check]查找某个\n    名字所指的定理：*)",
    "votes": 0
  },
  {
    "id": 581,
    "src": "(* ===> forall n m : nat, n + m = m + n *)",
    "dst": "(* ===> forall n m : nat, n + m = m + n *)",
    "votes": 0
  },
  {
    "id": 582,
    "src": "(** Coq prints the _statement_ of the [plus_comm] theorem in the same\n    way that it prints the _type_ of any term that we ask it to\n    [Check].  Why?\n\n    The reason is that the identifier [plus_comm] actually refers to a\n    _proof object_ -- a data structure that represents a logical\n    derivation establishing of the truth of the statement [forall n m\n    : nat, n + m = m + n].  The type of this object _is_ the statement\n    of the theorem that it is a proof of. *)",
    "dst": "(** 在显示[plus_comm]这一定理所声明的 _'命题'_ 时，Coq使用了与显示某个值的 _'类\n    型'_ 一样的方式。为什么会这样呢？\n    实际上[plus_comm]所指向的是一个被称作 _'证明对象'_ 的结构，它表示了证实\n    [forall n m : nat, n + m = m + n]这一命题的逻辑上的演化过程。这一对象的\n    类型 _'就是'_ 它所证明的命题。 *)",
    "votes": 0
  },
  {
    "id": 583,
    "src": "(** FULL: Intuitively, this makes sense because the statement of a theorem\n    tells us what we can use that theorem for, just as the type of a\n    computational object tells us what we can do with that object --\n    e.g., if we have a term of type [nat -> nat -> nat], we can give\n    it two [nat]s as arguments and get a [nat] back.  Similarly, if we\n    have an object of type [n = m -> n + n = m + m] and we provide it\n    an \"argument\" of type [n = m], we can derive [n + n = m + m]. *)",
    "dst": "(** FULL:\n    就直觉上而言这是十分自然的：定理的声明部分说明了这一定理能被用于什么场合，\n    就像某个计算对象的类型说明了这一对象能被如何使用一样。例如，如果某个项的类\n    型为[nat -> nat -> nat]；这说明我们可以将其用在两个[nat]上，然后得到一个[nat]。\n    类似地，如果我们有类型为[n = m -> n + n = m + m]的对象，当我们给出类型为[n = m]\n    的“证据”时，我们就能运用这一定理并得到[n + n = m + m]。 *)",
    "votes": 0
  },
  {
    "id": 584,
    "src": "(** TERSE: The type of a computational object tells us what we can do\n    with that object.\n       - e.g., if we have a term of type [nat -> nat -> nat], we can\n         give it two [nat]s as arguments and get a [nat] back.\n\n    Similarly, the statement of a theorem tells us what we can use\n    that theorem for.\n       - if we have an object of type [n = m -> n + n = m + m] and we\n         provide it an \"argument\" of type [n = m], we can derive\n         [n + n = m + m]. *)",
    "dst": "(** TERSE:\n    某个计算对象的类型说明了能对其进行的操作。\n      - 例如，假设我们有某个类型为[nat -> nat -> nat]的项，我们能够提供两个[nat]作为\n        参数并得到一个[nat]。\n        \n    类似地，某个定理的声明部分说明了这一定理能够使用的场合。\n      - 如果我们有类型为[n = m -> n + n = m + m]的对象，那么如果我们提供一个类型为[n = m]\n        的“参数”，我们就能够得到[n + n = m + m]。*)",
    "votes": 0
  },
  {
    "id": 585,
    "src": "(** FULL: Operationally, this analogy goes even further: by applying a\n    theorem, as if it were a function, to hypotheses with matching\n    types, we can specialize its result without having to resort to\n    intermediate assertions.  For example, suppose we wanted to prove\n    the following result: *)",
    "dst": "(** FULL:\n    就操作本身而言，我们能够将这种类比向前更推进一步：定理能被当作函数应用在有着正确类型的\n    假设上；这样我们在将其结论特殊化的时候就不需要向证明中插入断言。比如说，假设现在我们\n    想要证明如下的结果：*)",
    "votes": 0
  },
  {
    "id": 586,
    "src": "(** TERSE: Coq actually allows us to _apply_ a theorem as if it were a\n    function: *)",
    "dst": "(** TERSE: \n    实际上Coq允许我们像应用函数一样 _'应用'_ 某个定理： *)",
    "votes": 0
  },
  {
    "id": 587,
    "src": "(** It appears at first sight that we ought to be able to prove this\n    by rewriting with [plus_comm] twice to make the two sides match.\n    The problem, however, is that the second [rewrite] will undo the\n    effect of the first. *)",
    "dst": "(** 这个定理的证明初看上去十分简单，我们只要用[plus_comm]做两次重写就行了；然而问题是，\n    第二次重写的效果会与第一次重写互相抵消：*)",
    "votes": 0
  },
  {
    "id": 588,
    "src": "(** One simple way of fixing this problem, using only tools that we\n    already know, is to use [assert] to derive a specialized version\n    of [plus_comm] that can be used to rewrite exactly where we\n    want. *)",
    "dst": "(** 我们可以使用我们已经知道的工具通过这个简单的方法来解决这个问题：用[assert]在中间插入被\n    实例化了的[plus_comm]；这样我们就能够按照我们想要的方式进行重写： *)",
    "votes": 0
  },
  {
    "id": 589,
    "src": "(** FULL: A more elegant alternative is to apply [plus_comm] directly to the\n    arguments we want to instantiate it with, in much the same way as\n    we apply a polymorphic function to a type argument. *)",
    "dst": "(** FULL:\n    另外一个更为简洁优雅的方法是将[plus_comm]直接应用在我们想要以之实例化的参数上，\n    就像我们将一个多态函数应用到某个类型时所做的那样： *)",
    "votes": 0
  },
  {
    "id": 590,
    "src": "(** TERSE: We can fix this by applying [plus_comm] to the arguments we\n    want to instantiate it with.  Then the [rewrite] can only happen\n    in one place. *)",
    "dst": "(** TERSE:\n    我们能够通过将[plus_comm]应用在我们想要以之实例化的参数上来解决这个问题；这样之后\n    [rewrite]就只能对某个特定的地方起作用。*)",
    "votes": 0
  },
  {
    "id": 591,
    "src": "(** You can \"use theorems as functions\" in this way with almost all\n    tactics that take a theorem name as an argument.  Note also that\n    theorem application uses the same inference mechanisms as function\n    application; thus, it is possible, for example, to supply\n    wildcards as arguments to be inferred, or to declare some\n    hypotheses to a theorem as implicit by default.  These features\n    are illustrated in the proof below. *)",
    "dst": "(** 对于几乎所有以定理作为其参数的证明策略，你都可以这么将一个定理作为函数应用到\n    某些参数上，并将得到的实例化的定理传给这些证明策略；注意，定理应用所使用的类\n    型推导机制跟函数应用的是同一种，所以就像对某个函数所做的那样，你可以将通配符\n    作为定理���参数，也可以将某些作为参数的前提定义为隐式参数。这些用法在以下的证\n    明中都能够看到：*)",
    "votes": 0
  },
  {
    "id": 592,
    "src": "(** We will see many more examples of the idioms from this section in\n    later chapters. *)",
    "dst": "(** 在以后的章节中我们将会看到更多这方面的例子。*)",
    "votes": 0
  },
  {
    "id": 593,
    "src": "(* #################################################################### *)",
    "dst": "(* #################################################################### *)",
    "votes": 0
  },
  {
    "id": 594,
    "src": "(** * Coq vs. Set Theory *)",
    "dst": "(** * Coq vs. 集合论  *)",
    "votes": 0
  },
  {
    "id": 595,
    "src": "(** FULL: Coq's logical core, the _Calculus of Inductive Constructions_,\n    differs in some important ways from other formal systems that are\n    used by mathematicians for writing down precise and rigorous\n    proofs.  For example, in the most popular foundation for\n    mainstream paper-and-pencil mathematics, Zermelo-Fraenkel Set\n    Theory (ZFC), a mathematical object can potentially be a member of\n    many different sets; a term in Coq's logic, on the other hand, is\n    a member of at most one type.  This difference often leads to\n    slightly different ways of capturing informal mathematical\n    concepts, but these are, by and large, quite natural and easy to\n    work with.  For example, instead of saying that a natural number\n    [n] belongs to the set of even numbers, we would say in Coq that\n    [ev n] holds, where [ev : nat -> Prop] is a property describing\n    even numbers.\n\n    However, there are some cases where translating standard\n    mathematical reasoning into Coq can be either cumbersome or\n    sometimes even impossible, unless we enrich the core logic with\n    additional axioms.  We conclude this chapter with a brief\n    discussion of some of the most significant differences between the\n    two worlds. *)",
    "dst": "(** FULL:\n    Coq的核心，即被称作 _'Calculus of Inductive Constructions'_ 的系统，在一些很重要的方面\n    与其他被数学家们用于写下精确而严谨的证明的形式系统不一样。例如在主流数学中使用最普遍\n    的策梅洛-弗兰克尔（Zermelo-Fraenkel）集合论：在这一形式系统中一个数学对象可以同时是许\n    多不同的集合的成员；而在Coq的逻辑中，一个项有且仅有一个类型。这些区别的存在使得人们\n    需要用稍微有些不同的方式去描述同一种非形式化的数学概念，但是这些都是十分自然且易于理\n    解使用的。比如说，在Coq中我们一般不会说某个自然数[n]属于某个包含了全体偶数的集合；而\n    作为替代地���我们会有（或定义）[ev : nat -> Prop]这种描述了全体偶数的性质，然后说[ev n]\n    这一命题为真。\n    然而也存在着对于某些数学概念/论证而言不为核心的逻辑系统引入新的公理就难以进行\n    描述甚至是无法描述的的情况。我们将以对两个世界之间的一些最显著的差别的讨论作为\n    这一章节的结束。 *)",
    "votes": 0
  },
  {
    "id": 596,
    "src": "(** TERSE: Coq's logical core, the _Calculus of Inductive\n    Constructions_, is a \"metalanguage for mathematics\" in the same\n    sense as familiar foundations for paper-and-pencil mathematics,\n    like Zermelo-Fraenkel Set Theory (ZFC).\n\n    Mostly, the differences are not too important.\n\n    However, there are cases where translating standard mathematical\n    reasoning into Coq can be hard or even impossible unless we enrich\n    the core logic with additional axioms... *)",
    "dst": "(** TERSE:\n    Coq的核心逻辑 _'Calculus of Inductive Constructions'_ 是某种“数学的元语言”，\n    就像我们熟悉的那些被用作纸笔数学的基础的系统一样，例如策梅洛-弗兰克尔集合论（ZFC）。\n    在大部分情况下，这两者的区别并不是特别重要；但是在某些场合中，我们可能需要为其\n    添加额外的公理，否则我们在将标准的数学推理翻译为Coq能够理解的语言时就会遭到困难，\n    或者甚至根本不可能。 *)",
    "votes": 0
  },
  {
    "id": 597,
    "src": "(** ** Functional Extensionality *)",
    "dst": "(** ** 函数外延性 *)",
    "votes": 0
  },
  {
    "id": 598,
    "src": "(** FULL: The equality assertions that we have seen so far mostly have\n    concerned elements of inductive types ([nat], [bool], etc.).  But\n    since Coq's equality operator is polymorphic, these are not the\n    only possibilities -- in particular, we can write propositions\n    claiming that two _functions_ are equal to each other: *)",
    "dst": "(** FULL:\n    目前为止我们所看见的有关相等性的断言基本上都只是有关归纳类型（例如[nat]和\n    [bool]，诸如此类），但是由于Coq的相等操作符是多态的，这些并不是唯一能够有\n    相等性命题的类型——举例而言，我们能够写出声明了 _'两个函数相等'_ 的命题：*)",
    "votes": 0
  },
  {
    "id": 599,
    "src": "(** TERSE: We can write equality propositions stating that two\n    _functions_ are equal to each other: *)",
    "dst": "(** TERSE:\n    我们能够写出声明了两个 _'函数'_ 相等的相等性命题： *)",
    "votes": 0
  },
  {
    "id": 600,
    "src": "(** In common mathematical practice, two functions [f] and [g] are\n    considered equal if they produce the same outputs:\n[[\n    (forall x, f x = g x) -> f = g\n]]\n    This is known as the principle of _functional extensionality_.\n(* FULL *)\n\n    Informally speaking, an \"extensional property\" is one that\n    pertains to an object's observable behavior.  Thus, functional\n    extensionality simply means that a function's identity is\n    completely determined by what we can observe from it -- i.e., in\n    Coq terms, the results we obtain after applying it.\n(* /FULL *)\n\n    Functional extensionality is not part of Coq's basic axioms.  This\n    means that some \"reasonable\" propositions are not provable. *)",
    "dst": "(** 在一般的数学研究中，对于任意的两个函数[f]和[g]，只要它们所产生的结果相等，\n    那么它们就会被认为相等：\n[[\n    (forall x, f x = g x) -> f = g\n]]\n    这被称作 _'函数外延性'_ 原理。\n(* FULL *)\n    不甚严谨地说，所谓“外延性”指的是某个对象的可观察的行为；因此函数外延性指\n    的就是某个函数的身份完全由其行为，（用Coq的术语来说）也就是由我们将其应用于\n    参数上之后所能得到的结果确定。\n(* /FULL *)\n    函数外延性并不在Coq的基本公理之内；因此某些“应该为真”的命题是不能被证明的：*)",
    "votes": 0
  },
  {
    "id": 601,
    "src": "(* Stuck *)",
    "dst": "(* 卡住了 *)",
    "votes": 0
  },
  {
    "id": 602,
    "src": "(** However, we can add functional extensionality to Coq's core logic\n    using the [Axiom] command. *)",
    "dst": "(** 但是我们能用[Axiom]这一命令将函数外延性添加到Coq的核心逻辑系统之中： *)",
    "votes": 0
  },
  {
    "id": 603,
    "src": "(** Using [Axiom] has the same effect as stating a theorem and\n    skipping its proof using [Admitted], but it alerts the reader that\n    this isn't just something we're going to come back and fill in\n    later!\n\n    We can now invoke functional extensionality in proofs: *)",
    "dst": "(** [Axiom]的效果与定义一个定理然后用[Admitted]跳过证明部分相同，但是它会提示我们\n    这是一个公理：我们不需要为其加上证明。\n    现在我们能够在证明中使用函数外延性了： *)",
    "votes": 0
  },
  {
    "id": 604,
    "src": "(** Naturally, we must be careful when adding new axioms into Coq's\n    logic, as they may render it _inconsistent_ -- that is, they may\n    make it possible to prove every proposition, including [False]!\n\n    Unfortunately, there is no simple way of telling whether an axiom\n    is safe to add: hard work is generally required to establish the\n    consistency of any particular combination of axioms.\n\n    However, it is known that adding functional extensionality, in\n    particular, _is_ consistent.\n\n    To check whether a particular proof relies on any additional\n    axioms, use the [Print Assumptions] command.  *)",
    "dst": "(** 当然，在为Coq增添新的公理的时候我们必须十分小心，因为新增添的公理可能会与\n    现有的公理导致整体的 _'不一致'_ ；而当系统不一致的时候，任何命题都能够被证明为真，\n    包括[False]。但不幸的是，并没有什么简单的能够判断某条公理会不会与现有的公理\n    产生不一致的方法：一般而言，确认某一组公理的一致性都需要付出艰辛的努力；然\n    而我们已经知道，添加函数外延性并不会导致这种不一致。\n    我们可以用[Print Assumptions]查看某个证明所依赖的所有附加公理。 *)",
    "votes": 0
  },
  {
    "id": 605,
    "src": "(** One problem with the definition of the list-reversing function\n    [rev] that we have is that it performs a call to [app] on each\n    step; running [app] takes time asymptotically linear in the size\n    of the list, which means that [rev] has quadratic running time.\n    We can improve this with the following definition: *)",
    "dst": "(** 对于[rev]的定义我们有一个问题：在[rev]的每一步都会执行一次对[app]的调用，\n    而一次[app]调用所需要的时间大致上与列表的长度成正比。也就是说，[rev]有着\n    与列表长度成平方关系的时间复杂度。我们能够用下面的定义来对这个问题作出改进： *)",
    "votes": 0
  },
  {
    "id": 606,
    "src": "(** This version is said to be _tail-recursive_, because the recursive\n    call to the function is the last operation that needs to be\n    performed (i.e., we don't have to execute [++] after the recursive\n    call); a decent compiler will generate very efficient code in this\n    case.  Prove that the two definitions are indeed equivalent. *)",
    "dst": "(** 这个定义被称作是 _'尾递归的'_ ，因为对函数自身的递归调用是所需进行的操作中的\n    最后一个（也就是说在递归调用之后我们并不进行[++]）。一个足够好的编译器会针对\n    这样的源码生成非常高效的目标代码。证明这两个定义等价。 *)",
    "votes": 0
  },
  {
    "id": 607,
    "src": "(** ** Propositions and Booleans *)",
    "dst": "(** ** 命题与布尔代数  *)",
    "votes": 0
  },
  {
    "id": 608,
    "src": "(** We've seen two different ways of encoding logical facts in Coq:\n    with _booleans_ (of type [bool]), and with _propositions_ (of type\n    [Prop]).\n\n    For instance, to claim that a number [n] is even, we can say\n    either\n       - (1) that [evenb n] returns [true], or\n       - (2) that there exists some [k] such that [n = double k].\n             Indeed, these two notions of evenness are equivalent, as\n             can easily be shown with a couple of auxiliary lemmas.\n\n    We often say that the boolean [evenb n] _reflects_ the proposition\n    [exists k, n = double k].  *)",
    "dst": "(** 我们已经知道在Coq中有两种不同的描述逻辑事实的方式：布尔表达式（类型为[bool]的值）\n    和命题（类型为[Prop]的值）。举例而言，我们能够通过以下两种方式声明某个数字[n]为偶数：\n      - (1) [evenb n]返回[true]；\n      - (2) 或者存在某些使得[n = double k]的数字[k]。\n      这两个对“偶数性”的定义确实是等价的；我们能够证明一些辅助用的引理来证明这一点。\n    我们一般说[evenb n]这一布尔值 _'反映'_ 了命题[exists k, n = double k]。 *)",
    "votes": 0
  },
  {
    "id": 609,
    "src": "(** Similarly, to state that two numbers [n] and [m] are equal, we can\n    say either (1) that [beq_nat n m] returns [true] or (2) that [n =\n    m].  These two notions are equivalent. *)",
    "dst": "(** 类似地，我们可以用类似的两种方式声明任意的两个数字[n]和[m]的相等性：(1)\n    [beq_nat n m]返回[true]，以及(2)[n = m]。这两种方式也是等价的。 *)",
    "votes": 0
  },
  {
    "id": 610,
    "src": "(** However, while the boolean and propositional formulations of a\n    claim are equivalent from a purely logical perspective, they need\n    not be equivalent _operationally_.  Equality provides an extreme\n    example: knowing that [beq_nat n m = true] is generally of little\n    direct help in the middle of a proof involving [n] and [m];\n    however, if we convert the statement to the equivalent form [n =\n    m], we can rewrite with it.\n\n(* FULL *)\n    The case of even numbers is also interesting.  Recall that,\n    when proving the backwards direction of [even_bool_prop] (i.e.,\n    [evenb_double], going from the propositional to the boolean\n    claim), we used a simple induction on [k].  On the other hand, the\n    converse (the [evenb_double_conv] exercise) required a clever\n    generalization, since we can't directly prove [(exists k, n =\n    double k) -> evenb n = true].\n\n(* /FULL *)\n    For these examples, the propositional claims are more useful than\n    their boolean counterparts, but this is not always the case.  For\n    instance, we cannot test whether a general proposition is true or\n    not in a function definition; as a consequence, the following code\n    fragment is rejected: *)",
    "dst": "(** 然而，即使就逻辑上而言这两种表达方式是等价的，在进行具体的操作时它们也是不一样的。\n    相等性就是这种例子之中较为极端的一个：[beq_nat n m = true]这一假设对于有关[n]和[m]的\n    命题的证明而言几乎没有帮助，但是如果我们将这一假设变换为[n = m]这一等价的形式，我们就\n    能够将其用于重写。\n(* FULL *)\n    偶数性也是一个比较有意思的例子。回想一下，在我们证明[even_bool_prop]的反方向部分\n    （即[evenb_double]，从命题到布尔表达式的方向）的时候，我们只是简单地对[k]使用了\n    归纳法；而证明另一个方向（即[evenb_double_conv]这一练习）的命题则需要某种十分聪明\n    的对命题进行一般化的手段，因为我们不能直接证明[(exists k, n = double k) -> evenb = true]。\n(* /FULL *)\n    对这些例子而言，命题性的声明比起它们所对应的布尔表达式而言要更为有用；但并不是\n    在任何情况下都是如此。比如说，在函数的定义里我们不能检查某个任意的命题是否为真；\n    因此这段代码是不被接受的： *)",
    "votes": 0
  },
  {
    "id": 611,
    "src": "(** FULL: Coq complains that [n = 2] has type [Prop], while it expects an\n    elements of [bool] (or some other inductive type with two\n    elements).  The reason for this error message has to do with the\n    _computational_ nature of Coq's core language, which is designed\n    so that every function that it can express is computable and\n    total.  One reason for this is to allow the extraction of\n    executable programs from Coq developments.  As a consequence,\n    [Prop] in Coq does _not_ have a universal case analysis operation\n    telling whether any given proposition is true or false, since such\n    an operation would allow us to write non-computable functions.\n\n    Although general non-computable properties cannot be phrased as\n    boolean computations, it is worth noting that even many\n    _computable_ properties are easier to express using [Prop] than\n    [bool], since recursive function definitions are subject to\n    significant restrictions in Coq.  For instance, the next chapter\n    shows how to define the property that a regular expression matches\n    a given string using [Prop].  Doing the same with [bool] would\n    amount to writing a regular expression matcher, which would be\n    more complicated, harder to understand, and harder to reason\n    about.\n\n    Conversely, an important side benefit of stating facts using\n    booleans is enabling some proof automation through computation\n    with Coq terms, a technique known as _proof by\n    reflection_.  Consider the following statement: *)",
    "dst": "(** FULL:\n    Coq会拒绝接受这段代码并给出「[n = 2]的类型为[Prop]」这样的错误信息，因为它想要的\n    是一个[bool]（或其他的有两个元素的归纳类型）。出现这条错误信息的原因跟Coq的核心语言\n    有关：其 _'计算性'_ 的特性使得它只能表达可计算的全函数。这么做的原因之一是为了能够\n    从使用Coq开发的代码中抽取可以执行的程序。因此在Coq中 _'并没有'_ 某种通用的判断任意\n    [Prop]是否为真的按类分析操作：一旦存在这种操作，我们就能够用它来写出不可计算的函数。\n    \n    即使一般的不可计算的函数不能被表示为布尔代数中的运算，我们也应该知道即使是对于 _'可计算的'_ \n    性质而言也存在着使用[Prop]会比[bool]方便的场合，因为递归函数定义受限于Coq对于相关内容的限制。\n    比如说，下一章将会讲述如何使用[Prop]定义「某个正则表达式可以匹配某个给出的字符串」这一性质；\n    如果使用[bool]，那么就会需要真的写一个正则表达式的匹配器：这么做会更加复杂，更加难以理解，同时\n    也更加难以对相关的内容进行推理和证明。\n    相反的，使用布尔值会带来一个重要的好处：通过对Coq中的项进行计算能够实现一些证明的自动化。这一\n    技巧被称作_proof by reflection_。考虑下面的例子： *)",
    "votes": 0
  },
  {
    "id": 612,
    "src": "(** TERSE: An important side benefit of stating facts using\n    booleans is enabling some proof automation through computation\n    with Coq terms, a technique known as _proof by\n    reflection_.  Consider the following statement: *)",
    "dst": "(** TERSE:\n    相反的，使用布尔值会带来一个重要的好处：通过对Coq中的项进行计算能够实现一些证明的自动化。这一\n    技巧被称作 _proof by reflection_ 。考虑下面的例子：*)",
    "votes": 0
  },
  {
    "id": 613,
    "src": "(** The most direct proof of this fact is to give the value of [k]\n    explicitly. *)",
    "dst": "(** 对于这个命题而言，最为直接的证明方式是直接给出[k]的值。 *)",
    "votes": 0
  },
  {
    "id": 614,
    "src": "(** On the other hand, the proof of the corresponding boolean\n    statement is even simpler: *)",
    "dst": "(** 而与它对应的使用了布尔值的声明的证明则要更加简单些： *)",
    "votes": 0
  },
  {
    "id": 615,
    "src": "(** What is interesting is that, since the two notions are equivalent,\n    we can use the boolean formulation to prove the other one without\n    mentioning the value 500 explicitly: *)",
    "dst": "(** 有趣的是，因为这两种定义是等价的，我们能够不显式地指出500这个值而用相对应的布尔值\n    方程式去完成它的对应物的证明： *)",
    "votes": 0
  },
  {
    "id": 616,
    "src": "(** FULL: Although we haven't gained much in terms of proof size in this\n    case, larger proofs can often be made considerably simpler by the\n    use of reflection.  As an extreme example, the Coq proof of the\n    famous _4-color theorem_ uses reflection to reduce the analysis of\n    hundreds of different cases to a boolean computation.  We won't\n    cover reflection in great detail, but it serves as a good example\n    showing the complementary strengths of booleans and general\n    propositions. *)",
    "dst": "(** FULL:\n    虽然在这个例子中证明的长度并没有因此而缩减多少，但是对于更加大型的证明我们一般都\n    可以用反射技巧让它们变得更小。一个比较极端的例子是，在用Coq证明著名的 _'四色定理'_ \n    时人们使用了反射技巧将对几百种不同的情况的分析工作缩减成一个对布尔值的计算。我们\n    不会详细地讲解反射技巧，但是对于展示布尔值计算和一般命题的互补的优势而言，它是个\n    很好的例子。 *)",
    "votes": 0
  },
  {
    "id": 617,
    "src": "(** The following lemmas relate the propositional connectives studied\n    in this chapter to the corresponding boolean operations. *)",
    "dst": "(** 下述引理将在这一章中进行了讨论的命题性的连接符跟相对应的布尔运算操作联系了起来。*)",
    "votes": 0
  },
  {
    "id": 618,
    "src": "(** The following theorem is an alternate \"negative\" formulation of\n    [beq_nat_true_iff] that is more convenient in certain\n    situations (we'll see examples in later chapters). *)",
    "dst": "(** 下述引理是命题[beq_nat_true_iff]的“非”版本；在某些情况下这一引理会使事情变得\n    更为方便些。（在以后的章节中我们将会看到更多这方面的例子） *)",
    "votes": 0
  },
  {
    "id": 619,
    "src": "(** Given a boolean operator [beq] for testing equality of elements of\n    some type [A], we can define a function [beq_list beq] for testing\n    equality of lists with elements in [A].  Complete the definition\n    of the [beq_list] function below.  To make sure that your\n    definition is correct, prove the lemma [beq_list_true_iff]. *)",
    "dst": "(** 给定一个用于确定类型为[A]的值之间的相等性的布尔操作符[beq]，我们能够定义\n    可以检测两个包含类型为[A]的值的列表是否相等的函数[beq_list beq]。完成下面\n    [beq_list]的定义。证明[beq_list_true_iff]这一引理以确认你的定义是正确的。 *)",
    "votes": 0
  },
  {
    "id": 620,
    "src": "(** Recall the function [forallb], from the exercise\n    [forall_exists_challenge] in chapter \\CHAP{Tactics}: *)",
    "dst": "(** 回忆一下在\\CHAP{Tactics}一章中来自练习[forall_exists_challenge]的函数[forallb]： *)",
    "votes": 0
  },
  {
    "id": 621,
    "src": "(** Prove the theorem below, which relates [forallb] to the [All]\n    property of the above exercise. *)",
    "dst": "(** 证明下述将[forallb]跟[All]这一性质联系起来的定理。*)",
    "votes": 0
  },
  {
    "id": 622,
    "src": "(** Are there any important properties of the function [forallb] which\n    are not captured by this specification? *)",
    "dst": "(** 是否存在没有被这个规范描述包括的关于函数[forallb]的性质？*)",
    "votes": 0
  },
  {
    "id": 623,
    "src": "(* This theorem exactly captures the input-output behaviour of\n   [forallb]. However, it does not say anything about the running\n   time. *)",
    "dst": "(* 这一定理完整地描述了[forallb]的输入-输出行为，但是它没有对运行时间进行任何的描述。*)",
    "votes": 0
  },
  {
    "id": 624,
    "src": "(** ** Classical vs. Constructive Logic *)",
    "dst": "(** ** 经典逻辑 vs. 构造逻辑  *)",
    "votes": 0
  },
  {
    "id": 625,
    "src": "(** FULL: We have seen that it is not possible to test whether or not a\n    proposition [P] holds while defining a Coq function.  You may be\n    surprised to learn that a similar restriction applies to _proofs_!\n    In other words, the following intuitive reasoning principle is not\n    derivable in Coq: *)",
    "dst": "(** FULL:\n    我们已经知道，在定义一个Coq函数时我们没有办法判断某个命题[P]是否为真；你或许会\n    对为此感到惊讶：对于 _'证明'_ 而言也存在类似的限制！换句话说，下面的推理原则即使\n    符合直觉，但是在Coq中它是不可被证明的：*)",
    "votes": 0
  },
  {
    "id": 626,
    "src": "(** TERSE: The following reasoning principle is _not_ derivable in\n    Coq (though, again, it can consistently be added): *)",
    "dst": "(** TERSE:\n    下面的推理原则在Coq中是 _'不可被证明的'_ （虽然它也可以被添加到Coq中而不破坏一致性）： *)",
    "votes": 0
  },
  {
    "id": 627,
    "src": "(** FULL: To understand operationally why this is the case, recall\n    that, to prove a statement of the form [P \\/ Q], we use the [left]\n    and [right] tactics, which effectively require knowing which side\n    of the disjunction holds.  But the universally quantified [P] in\n    [excluded_middle] is an _arbitrary_ proposition, which we know\n    nothing about.  We don't have enough information to choose which\n    of [left] or [right] to apply, just as Coq doesn't have enough\n    information to mechanically decide whether [P] holds or not inside\n    a function. *)",
    "dst": "(** FULL:\n    回想一下，在证明形如[P \\/ Q]的命题时，我们使用[left]和[right]这两个策略；为了使用\n    这两个策略证明这些命题，我们需要知道哪一边能够被证明为真。但是在[excluded_middle]���，\n    [P]是被全程量化的，它可以指代任意命题；因此我们对[P]本身一无所知，所以我们也不能得到\n    足够让我们确定用[left]还是[right]的信息，就像Coq因为缺乏信息而不能在函数内部机械地确定\n    [P]是否为真一样。 *)",
    "votes": 0
  },
  {
    "id": 628,
    "src": "(** However, if we happen to know that [P] is reflected in some\n    boolean term [b], then knowing whether it holds or not is trivial:\n    we just have to check the value of [b]. *)",
    "dst": "(** 然而，如果我们恰好知道[P]被某个布尔项[b]反射，那么我们就能很轻易地知道它究竟是否为真：\n    我们只要检测[b]的值就可以了。 *)",
    "votes": 0
  },
  {
    "id": 629,
    "src": "(** In particular, the excluded middle is valid for equations [n = m],\n    between natural numbers [n] and [m]. *)",
    "dst": "(** 特别地，对于关于自然数[n]和[m]的等式[n = m]而言，排中律是成立的。*)",
    "votes": 0
  },
  {
    "id": 630,
    "src": "(** FULL: It may seem strange that the general excluded middle is not\n    available by default in Coq; after all, any given claim must be\n    either true or false.  Nonetheless, there is an advantage in not\n    assuming the excluded middle: statements in Coq can make stronger\n    claims than the analogous statements in standard mathematics.\n    Notably, if there is a Coq proof of [exists x, P x], it is\n    possible to explicitly exhibit a value of [x] for which we can\n    prove [P x] -- in other words, every proof of existence is\n    necessarily _constructive_. *)",
    "dst": "(** FULL:\n    通用的排中律在Coq中并不是默认可以使用的；这一点看上去或许很奇怪，毕竟任何声明\n    肯定都是非真即假的。然而不假设排中律存在也有它的优势：Coq中的声明可以比在标���数学\n    中同样的声明更强。比如说，如果存在[exists x, P x]的Coq证明，那么我们就能够直接\n    展示出能够让我们证明[P x]的[x]的值；也就是说，任何关于存在性的证明一定都是 _'构造性'_ 的。 *)",
    "votes": 0
  },
  {
    "id": 631,
    "src": "(** Logics like Coq's, which do not assume the excluded middle, are\n    referred to as _constructive logics_.\n\n    More conventional logical systems such as ZFC, in which the\n    excluded middle does hold for arbitrary propositions, are referred\n    to as _classical_. *)",
    "dst": "(** 像Coq一样不假设排中律的正确性的逻辑系统被称作 _'构造逻辑'_ ；而更加常规的、排中律\n    对于任意命题都成立的逻辑系统（例如ZFC集合论）则被称作 _'经典逻辑'_ 。 *)",
    "votes": 0
  },
  {
    "id": 632,
    "src": "(** The following example illustrates why assuming the excluded middle\n    may lead to non-constructive proofs:\n\n    _Claim_: There exist irrational numbers [a] and [b] such that [a ^\n    b] is rational.\n\n    _Proof_: It is not difficult to show that [sqrt 2] is irrational.\n    If [sqrt 2 ^ sqrt 2] is rational, it suffices to take [a = b =\n    sqrt 2] and we are done.  Otherwise, [sqrt 2 ^ sqrt 2] is\n    irrational.  In this case, we can take [a = sqrt 2 ^ sqrt 2] and\n    [b = sqrt 2], since [a ^ b = sqrt 2 ^ (sqrt 2 * sqrt 2) = sqrt 2 ^\n    2 = 2].  []\n\n    Do you see what happened here?  We used the excluded middle to\n    consider separately the cases where [sqrt 2 ^ sqrt 2] is rational\n    and where it is not, without knowing which one actually holds!\n    Because of that, we wind up knowing that such [a] and [b] exist\n    but we cannot determine what their actual values are (at least,\n    using this line of argument).\n\n    As useful as constructive logic is, it does have its limitations:\n    There are many statements that can easily be proven in classical\n    logic but that have much more complicated constructive proofs, and\n    there are some that are known to have no constructive proof at\n    all!  Fortunately, like functional extensionality, the excluded\n    middle is known to be compatible with Coq's logic, allowing us to\n    add it safely as an axiom.  However, we will not need to do so in\n    this book: the results that we cover can be developed entirely\n    within constructive logic at negligible extra cost.\n\n    It takes some practice to understand which proof techniques must\n    be avoided in constructive reasoning, but arguments by\n    contradiction, in particular, are infamous for leading to\n    non-constructive proofs.  Here's a typical example: suppose that\n    we want to show that there exists [x] with some property [P],\n    i.e., such that [P x].  We start by assuming that our conclusion\n    is false; that is, [~ exists x, P x]. From this premise, it is not\n    hard to derive [forall x, ~ P x].  If we manage to show that this\n    intermediate fact results in a contradiction, we arrive at an\n    existence proof without ever exhibiting a value of [x] for which\n    [P x] holds!\n\n    The technical flaw here, from a constructive standpoint, is that\n    we claimed to prove [exists x, P x] using a proof of\n    [~ ~ (exists x, P x)].  Allowing ourselves to remove double\n    negations from arbitrary statements is equivalent to assuming the\n    excluded middle, as shown in one of the exercises below.  Thus,\n    this line of reasoning cannot be encoded in Coq without assuming\n    additional axioms. *)",
    "dst": "(** 下述例子展示了为什么假设排中律成立会导致非构造性的证明：\n   '_  声明'_ ：存在无理数[a]和[b]使得[a ^ b]为有理数。\n   '_  证明'_ ：易知[sqrt 2]为无理数。如果[sqrt 2 ^ sqrt 2]为有理数，那么可以取\n    [a = b = sqrt 2]；如果[sqrt 2 ^ sqrt 2]为无理数，那么可以取[a = sqrt 2 ^ sqrt 2]和\n    [b = sqrt 2]，因为[a ^ b = sqrt 2 ^ (sqrt 2 * sqrt 2) = sqrt 2 ^ 2 = 2]。[]\n    看得到在这个证明中发生了什么吗？我们在不知道[sqrt 2 ^ sqrt 2]是否为有理数的\n    情况下就使用了排中律将它分为两种不同的情况；因此在最后，我们知道这样的[a]和[b]\n    是存在的，但是我们并不能确定它们的值。\n    即使构造逻辑很有用，它也有它的限制：有很多在经典逻辑中能够轻易被证明的声明会有\n    更加复杂的构造性证明，而对于某些声明而言这样的证明甚至不存在。幸运的是，排中律\n    就像函数外延性一样与Coq的逻辑系统相兼容；我们可以安全地将其作为公理添加到Coq中。\n    但是在这本书中我们不需要这样做：这本书所覆盖的内容都可以使用构造逻辑得到，而且\n    因此所产生的额外的耗费都微不足道。\n    一般而言在意识到有哪些证明技巧不应该在进行构建性证明时使用之前都要经过一定的实践和\n    练习，但是在这些证明技巧之中反证法尤为臭名昭著，因为它的使用将会导向一个非构造性的\n    证明。这里是一个典型的例子：假设我们希望证明存在有着性质[P]的某个[x]，也就是说，\n    我们希望证明存在某个[x]使得[P x]。我们先假设这个命题为假，即假设[~ exists x, P x]。\n    从这个假设中我们不用特别费劲就能得到[forall x, ~ P x]。如果我们能够通过这个命题得到\n    矛盾，我们就能够得到一个对于存在性的证明，即使我们完全没有指出能够使[P x]成立的[x]的值。\n    从构造性的角度来看，在这里存在着的技术上的瑕疵，是我们试图用[~ ~ (exists x, P x)]的证明\n    去证明[exists x, P x]。从下面的练习我们可以看到，允许自己从任意声明中去掉双重否定等价于\n    引入排中律。因此只要不引入这一额外的公理，我们就不能在Coq中写出这行证明。 *)",
    "votes": 0
  },
  {
    "id": 633,
    "src": "(** The consistency of Coq with the general excluded middle axiom\n    requires complicated reasoning that cannot be carried out within\n    Coq itself.  However, the following theorem implies that it is\n    always safe to assume a decidability axiom (i.e., an instance of\n    excluded middle) for any _particular_ Prop [P].  Why? Because we\n    cannot prove the negation of such an axiom; if we could, we would\n    have both [~ (P \\/ ~P)] and [~ ~ (P \\/ ~P)], a contradiction. *)",
    "dst": "(** 通用的排中律跟Coq之间的一致性的证明十分复杂而且并不能在Coq系统自身进行。然而，下述定理\n    说明了对于 _'任意指定的某个'_ Prop [P]而言，加入一个可判定公理（也就是一个排中律的特例）\n    都是安全的。之所以这样是因为我们不能证明这样的公���的否定命题；如果我们能够证明这样的命题，\n    那么我们就会同时有[~ (P \\/ ~P)]和[~ ~ (P \\/ ~P)]，而这将产生矛盾。*)",
    "votes": 0
  },
  {
    "id": 634,
    "src": "(** It is a theorem of classical logic that the following two\n    assertions are equivalent:\n[[\n    ~ (exists x, ~ P x)\n    forall x, P x\n]]\n    The [dist_not_exists] theorem above proves one side of this\n    equivalence. Interestingly, the other direction cannot be proved\n    in constructive logic. Your job is to show that it is implied by\n    the excluded middle. *)",
    "dst": "(** 在经典逻辑中有这么一条定理；它声明下述两条假设是等价的：\n[[\n    ~ (exists x, ~ P x)\n    forall x, P x\n]]\n    [dist_not_exists]证明了这一等价性的其中一个方向。有趣的事是，在构造逻辑中我们\n    不能证明另外一个方向。你的任务就是证明这个方向的证明能够使用排中律得到。*)",
    "votes": 0
  },
  {
    "id": 635,
    "src": "(* P x *)",
    "dst": "(* P x *)",
    "votes": 0
  },
  {
    "id": 636,
    "src": "(* ~P x *)",
    "dst": "(* ~P x *)",
    "votes": 0
  },
  {
    "id": 637,
    "src": "(** For those who like a challenge, here is an exercise taken from the\n    Coq'Art book by Bertot and Casteran (p. 123).  Each of the\n    following four statements, together with [excluded_middle], can be\n    considered as characterizing classical logic.  We can't prove any\n    of them in Coq, but we can consistently add any one of them as an\n    axiom if we wish to work in classical logic.\n\n    Prove that all five propositions (these four plus\n    [excluded_middle]) are equivalent. *)",
    "dst": "(** 对于那些喜欢挑战的人，这里是摘自Bertor和Casteran所著的Coq'Art这本书（第123页）的练习。\n    下述的四个句子，包括上面提到的[excluded_middle]，都被认为描述了经典逻辑。在Coq中我们不能\n    证明它们，但是假如我们希望在经典逻辑下工作的话，���们可以安全地将其中任意一条作为公理添加\n    到Coq中。\n    证明这五个命题（以下四个以及[excluded_middle]）互相等价。 *)",
    "votes": 0
  },
  {
    "id": 638,
    "src": "(* P *)",
    "dst": "(* P *)",
    "votes": 0
  },
  {
    "id": 639,
    "src": "(* ~P *)",
    "dst": "(* ~P *)",
    "votes": 0
  },
  {
    "id": 640,
    "src": "(* Q *)",
    "dst": "(* Q *)",
    "votes": 0
  },
  {
    "id": 641,
    "src": "(* ~Q *)",
    "dst": "(* ~Q *)",
    "votes": 0
  },
  {
    "id": 642,
    "src": "(** The above suffices (along with [demorgan__em]), but we can also\n    prove it directly this way *)",
    "dst": "(** 上面的证明（包括[demorgan__em]）已经足够了，但是我们也能够这样证明它： *)",
    "votes": 0
  },
  {
    "id": 643,
    "src": "(* ~(P->Q) *)",
    "dst": "(* ~(P->Q) *)",
    "votes": 0
  },
  {
    "id": 644,
    "src": "(** * ImpParser: Lexing and Parsing in Coq *)",
    "dst": "(** * ImpParser: 用Coq做词法分析和语法分析 *)",
    "votes": 0
  },
  {
    "id": 645,
    "src": "(** The development of the Imp language in [Imp.v] completely ignores\n    issues of concrete syntax -- how an ascii string that a programmer\n    might write gets translated into abstract syntax trees defined by\n    the datatypes [aexp], [bexp], and [com].  In this chapter, we\n    illustrate how the rest of the story can be filled in by building\n    a simple lexical analyzer and parser using Coq's functional\n    programming facilities.\n\n    It is not important to understand all the details here (and\n    accordingly, the explanations are fairly terse and there are no\n    exercises).  The main point is simply to demonstrate that it can\n    be done.  You are invited to look through the code -- most of it\n    is not very complicated, though the parser relies on some\n    \"monadic\" programming idioms that may require a little work to\n    make out -- but most readers will probably want to just skim down\n    to the Examples section at the very end to get the punchline. *)",
    "dst": "(** 在Imp.v中���计[Imp]语言时完全忽略了具体语法的问题 —— 如何把\n    程序员可能写下的ascii字符串翻译成一棵由[aexp]，[bexp]，\n    [com]所定义的抽象语法树。在这个文件能我们将通过用Coq的\n    函数式语言特性来构建一个简单的词法分析器和语法解析器，并回答\n    之前的遗留问题。\n    \n    这一章读者可以不求甚解：本章解释都相当的简短并且也没什么\n    练习题。主要的意义是为了演示我们能做什么。非常欢迎你通读\n    这段代码 —— 大部分不那么复杂，尽管解析器依赖于某种\"monadic\"\n    的编程风格，这可能需要你花点时间来理解 —— 大部分读者可以直接\n    跳到末尾的例子部分弄懂这章做了什么。 *)",
    "votes": 0
  },
  {
    "id": 646,
    "src": "(* ####################################################### *)",
    "dst": "(* ####################################################### *)",
    "votes": 0
  },
  {
    "id": 647,
    "src": "(** * Internals *)",
    "dst": "(** * 内部结构 *)",
    "votes": 0
  },
  {
    "id": 648,
    "src": "(** ** Lexical Analysis *)",
    "dst": "(** ** 词法分析 *)",
    "votes": 0
  },
  {
    "id": 649,
    "src": "(** ** Parsing *)",
    "dst": "(** ** 解析 *)",
    "votes": 0
  },
  {
    "id": 650,
    "src": "(** *** Options With Errors *)",
    "dst": "(** *** 出错后的备选 *)",
    "votes": 0
  },
  {
    "id": 651,
    "src": "(** An [option] type with error messages: *)",
    "dst": "(* 带出错信息的option *)",
    "votes": 0
  },
  {
    "id": 652,
    "src": "(** Some syntactic sugar to make writing nested match-expressions on\n    optionE more convenient. *)",
    "dst": "(* 加点语法糖来使得书写嵌套的匹配optionE的表达式更加方便。 *)",
    "votes": 0
  },
  {
    "id": 653,
    "src": "(** *** Generic Combinators for Building Parsers *)",
    "dst": "(** *** 构造解析器的通用组合子 *)",
    "votes": 0
  },
  {
    "id": 654,
    "src": "(** A (step-indexed) parser that expects zero or more [p]s: *)",
    "dst": "(* 一个接受零个或多个[p]的解析器 *)",
    "votes": 0
  },
  {
    "id": 655,
    "src": "(** A parser that expects a given token, followed by [p]: *)",
    "dst": "(* 一个接受紧跟在[p]后给定的符号的解析器 *)",
    "votes": 0
  },
  {
    "id": 656,
    "src": "(** A parser that expects a particular token: *)",
    "dst": "(* 一个接受某个特定符号的解析器 *)",
    "votes": 0
  },
  {
    "id": 657,
    "src": "(** *** A Recursive-Descent Parser for Imp *)",
    "dst": "(** *** Imp的一个递归下降的解析器 *)",
    "votes": 0
  },
  {
    "id": 658,
    "src": "(** Identifiers: *)",
    "dst": "(* 标识符 *)",
    "votes": 0
  },
  {
    "id": 659,
    "src": "(** Numbers: *)",
    "dst": "(* 数字 *)",
    "votes": 0
  },
  {
    "id": 660,
    "src": "(** Parse arithmetic expressions *)",
    "dst": "(* 解析算数表达式 *)",
    "votes": 0
  },
  {
    "id": 661,
    "src": "(** Parsing boolean expressions: *)",
    "dst": "(* 解析布尔表达式 *)",
    "votes": 0
  },
  {
    "id": 662,
    "src": "(** Parsing commands: *)",
    "dst": "(* 解析命令 *)",
    "votes": 0
  },
  {
    "id": 663,
    "src": "(** * Examples *)",
    "dst": "(** * 例子 *)",
    "votes": 0
  },
  {
    "id": 664,
    "src": "(** * Equiv: Program Equivalence *)",
    "dst": "(** * Equiv: 程序等价性 *)",
    "votes": 0
  },
  {
    "id": 665,
    "src": "(* INSTRUCTORS: This chapter can be skipped if desired.  It is\n   probably a good idea to keep it if students are still having\n   trouble internalizing material from previous chapters, as it goes\n   at a bit more gentle pace and will help build up mathematical\n   muscles.  (Doing all or most of the WORKINCLASS exercises will make\n   the chapter take 1.5 or 2 lectures, which can also help give people\n   a chance to catch up.)  With a more advanced class, it should\n   probably be omitted to leave time for more interesting things at\n   the end of the course.\n*)",
    "dst": "(* INSTRUCTORS: 如果需要, 本章可以跳过.  如果学生对前面章节的内容不完全理解\n   的话, 保留本章是很好的主意, 因为这让进度柔和一些从而有助于建立数学思维.\n   (完成大部分或者全部课上练习会让这课分为两讲, 而帮助学生赶上进度.)\n   如果是水平更高的班, 则应该省略以留出时间在整个课程末尾做更有趣的事情. *)",
    "votes": 0
  },
  {
    "id": 666,
    "src": "(* INSTRUCTORS: In these lectures I tried an experiment with using\n   clickers to involve students in interactive Coq proof demos in\n   class.  I handed out a paper key with the following ...\n\n     1: induction\n     2: destruct\n     3: inversion (plus subst)\n     4: unfold\n     5: remember\n     6: rewrite\n     7: assumption\n     8: apply a constructor\n     9: apply a previously proved lemma/theorem\n     0: other\n\n   ... and asked the class to use their clickers to vote for which\n   tactic to apply next as the proof develops.  The result was a bit\n   chaotic (there were lots of situations that the above choices did\n   not cover), but it generated a lot of energy and people seemed\n   to enjoy it.\n*)",
    "dst": "(* INSTRUCTORS: 在这几讲里我们做了一个实验, 让学生在课上投票选出Coq证明.\n   分为以下的证明 ...\n     1: induction\n     2: destruct \n     3: inversion (plus subst)\n     4: unfold\n     5: remember\n     6: rewrite\n     7: assumption\n     8: apply a constructor\n     9: apply a previously proved lemma/theorem\n     0: other\n   ... 然后让学生们投票选出应用哪条证明策略让证明继续.\n*)",
    "votes": 0
  },
  {
    "id": 667,
    "src": "(* SOONER: More good exercises from recent exams...\n\n-------\nIs this claim...\nClaim: Suppose the command c is equivalent to c;;c. Then, for any b, the command\nwhile b do c\nis equivalent to\n              testif b then c else skip.\n... true or false? Briefy explain.\n\n--------\nEach part of this question makes a general claim about program equivalences in Imp. For each one, indicate whether it is true or false. If it is false, give a counter-example. (For reference, the definition of program equivalence is provided on page 17.)\n(a) For all commands c and boolean expressions b, cequiv (WHILE b DO c END)\n            (IF b THEN c ELSE SKIP FI;; WHILE b DO c END)\n(b) For all arithmetic expressions e1 and e2, cequiv (X ::= e1;; Y ::= e2)\n            (Y ::= e2;; X ::= e1)\n(c) For all boolean expressions b1 and b2 so that bequiv b1 BTrue and bequiv b2 BFalse, cequiv (WHILE b1 DO (WHILE b2 DO SKIP END) END)\n            (WHILE b2 DO (WHILE b1 DO SKIP END) END)\n\n*)",
    "dst": "(* SOONER: 更多好习题比如... \n-------\n这是一个断言...\n断言: 假设c等价于c;;c那么对于任意b, 命令\nwhile b do c\n等价于\ntestif b then c else skip.\n... 是真是假? 简要说明.\n--------\n这题的每部分都是关于Imp中程序等价性的一般断言. 对每一条指出是真还是假.\n如果是假, 举出一个反例. (程序等价性的定义在17页以供参考.)\n(a) 对于所有的命令c和布尔表达式b,\n        cequiv (WHILE b DO c END)\n               (IF b THEN c ELSE SKIP FI;; WHILE b DO c END)\n(b) 对于所有算数表达式 e1 和 e2,\n       cequiv (X ::= e1;; Y ::= e2)\n              (Y ::= e2;; X ::= e1)\n(c) 对于所有的布尔表达式 b1 和 b2 bequiv b1 BTrue 且 bequiv b2 BFalse,\n       cequiv (WHILE b1 DO (WHILE b2 DO SKIP END) END)\n              (WHILE b2 DO (WHILE b1 DO SKIP END) END)\n *)",
    "votes": 0
  },
  {
    "id": 668,
    "src": "(* IMPORTS *)",
    "dst": "(* IMPORTS *)",
    "votes": 0
  },
  {
    "id": 669,
    "src": "(* /IMPORTS *)",
    "dst": "(* /IMPORTS *)",
    "votes": 0
  },
  {
    "id": 670,
    "src": "(** FULL: *** Some Advice for Working on Exercises:\n\n    - Most of the Coq proofs we ask you to do are similar to proofs\n      that we've provided.  Before starting to work on exercises\n      problems, take the time to work through our proofs (both\n      informally, on paper, and in Coq) and make sure you understand\n      them in detail.  This will save you a lot of time.\n\n    - The Coq proofs we're doing now are sufficiently complicated that\n      it is more or less impossible to complete them simply by random\n      experimentation or \"following your nose.\"  You need to start\n      with an idea about why the property is true and how the proof is\n      going to go.  The best way to do this is to write out at least a\n      sketch of an informal proof on paper -- one that intuitively\n      convinces you of the truth of the theorem -- before starting to\n      work on the formal one.  Alternately, grab a friend and try to\n      convince them that the theorem is true; then try to formalize\n      your explanation.\n\n    - Use automation to save work!  The proofs in this chapter's\n      exercises can get pretty long if you try to write out all the\n      cases explicitly. *)",
    "dst": "(** FULL: *** 一些关于练习的一般性建议:\n    - 这里要进行的大多数Coq证明都与先前我们所提供的相似. 在做作业之前, 花一些时间\n      （非形式化的在纸上和Coq中）思考我们的证明确保你理解他们的的每一个细节. 这会节省你\n      大量的时间.\n    - 我们现在进行的Coq证明已经足够复杂，以至于近乎不可能单靠“灵感”或者以随机的尝试误打误撞的完成证明。你需要一个关于为何\n      某个属性为真以及如何进行证明的概念并从这个概念开始。完成这一项任务的最好的方\n      法是在开始进行形式化证明之前至少在纸上写出一个非形式化证明的梗概\n      --直观的说服自己相信定理成立--然后再进行形式化证明。另外，\n      你也可以拉来一个好友，尝试说服他相信这条定理成立; 然后试着形式化你刚才的解释。\n    - 使用自动化工具来减少工作量！本章的一些证明练习，如果全部一个个分类去分析的话\n      会非常长. *)",
    "votes": 0
  },
  {
    "id": 671,
    "src": "(** * Behavioral Equivalence *)",
    "dst": "(** * 行为的等价性 *)",
    "votes": 0
  },
  {
    "id": 672,
    "src": "(** In an earlier chapter, we investigated the correctness of a very\n    simple program transformation: the [optimize_0plus] function.  The\n    programming language we were considering was the first version of\n    the language of arithmetic expressions -- with no variables -- so\n    in that setting it was very easy to define what it means for a\n    program transformation to be correct: it should always yield a\n    program that evaluates to the same number as the original.\n\n    To talk about the correctness of program transformations for the\n    full Imp language, including assignment and other commands, we\n    need to consider the role of variables and state. *)",
    "dst": "(** 在上一章中我们讨论了一个非常简单的程序变换的正确性; [optimize_0plus] 函数。\n    这是我们考虑的算数表达式语言的第一个版本--它没有变量--所以很容易定义 _（什么是）_ \n    正确的程序变换： 即输出一个求值结果与原程序相同的程序。\n    \n    为了更进一步的讨论整个Imp语言变换的正确性，我们需要考虑状态和变量的作用。 *)",
    "votes": 0
  },
  {
    "id": 673,
    "src": "(** In the last chapter, we studied a simple transformation on\n    arithmetic expressions. Our transformation was correct because it\n    preserved the value of the expressions given as input.\n\n    For Imp programs, correct transformations will be those that\n    preserve the behavior of programs. In order to study those, we\n    must first define the notion of _behavioral equivalence_ (or\n    _program equivalence_). *)",
    "dst": "(** 在上一章, 我们探讨了一个算术表达式的简单变换. 因为它保持了\n    原有表达式的值不改变。\n    对于Imp程序而言, 正确的变换保持程序的行为不改变. 为了研究这类变换, 我们必须首先定义\n    _（程序等价性）_ 的概念。 *)",
    "votes": 0
  },
  {
    "id": 674,
    "src": "(** ** Definitions *)",
    "dst": "(** ** 定义 *)",
    "votes": 0
  },
  {
    "id": 675,
    "src": "(** For [aexp]s and [bexp]s with variables, the definition we want is\n    clear.  We say that two [aexp]s or [bexp]s are _behaviorally\n    equivalent_ if they evaluate to the same result in every state. *)",
    "dst": "(** 对于包含变量的 [aexp] 和 [bexp], 我们需要的定义简单明了。在 _（所有状态）_\n    下两个 [aexp] 或者 [bexp] 的求值结果相同，我们就说他们 _（行为等价）_ 。*)",
    "votes": 0
  },
  {
    "id": 676,
    "src": "(** FULL: For commands, the situation is a little more subtle.  We can't\n    simply say \"two commands are behaviorally equivalent if they\n    evaluate to the same ending state whenever they are started in the\n    same initial state,\" because some commands, when run in some\n    starting states, don't terminate in any final state at all!  What\n    we need instead is this: two commands are behaviorally equivalent\n    if, for any given starting state, they either (1) both diverge\n    or (2) both terminate in the same final state.  A compact way to\n    express this is \"if the first one terminates in a particular state\n    then so does the second, and vice versa.\" *)",
    "dst": "(** FULL: For commands, the situation is a little more subtle.  We can't\n    simply say \"two commands are behaviorally equivalent if they\n    evaluate to the same ending state whenever they are started in the\n    same initial state,\" because some commands, when run in some\n    starting states, don't terminate in any final state at all!  What\n    we need instead is this: two commands are behaviorally equivalent\n    if, for any given starting state, they either (1) both diverge\n    or (2) both terminate in the same final state.  A compact way to\n    express this is \"if the first one terminates in a particular state\n    then so does the second, and vice versa.\" *)",
    "votes": 0
  },
  {
    "id": 677,
    "src": "(** FULL: For commands, the situation is a little more subtle.  We can't\n    simply say \"two commands are behaviorally equivalent if they\n    evaluate to the same ending state whenever they are started in the\n    same initial state,\" because some commands, when run in some\n    starting states, don't terminate in any final state at all!  What\n    we need instead is this: two commands are behaviorally equivalent\n    if, for any given starting state, they either (1) both diverge\n    or (2) both terminate in the same final state.  A compact way to\n    express this is \"if the first one terminates in a particular state\n    then so does the second, and vice versa.\" *)",
    "dst": "(** 对于命令，情况有些微妙。我们不能简单的说：“如果两个指令在相同的初始状态下求值到相同\n    的终止状态，那么说这两个指令等价。”，因为有些命令（在某些初始状态下）根本不会在任何\n    状态终止！我们实际上需要的是：“若两个指���在给出任何初始状态时都发散或者终止在相同\n    的状态上，则这两个指令行为等价。”。简单的说就是：“如果其中一个终止在某\n    状态上那么另一个也终止在这个状态上，反之亦然。” *)",
    "votes": 0
  },
  {
    "id": 678,
    "src": "(** Are these two programs equivalent?\n[[\n    X ::= 1;;\n    Y ::= 2\n]]\n    and\n[[\n    Y ::= 2;;\n    X ::= 1\n]]\n\n    (1) Yes\n\n    (2) No\n\n    (3) Not sure\n*)",
    "dst": "(** 这两个程序等价吗?  \n[[\n    X ::= 1;;\n    Y ::= 2\n]]\n    和\n[[\n    Y ::= 2;;\n    X ::= 1\n]]\n    (1) 是\n    (2) 否\n    \n    (3) 不确定\n*)",
    "votes": 0
  },
  {
    "id": 679,
    "src": "(** What about these?\n\n[[\n    X ::= 1;;\n    Y ::= 2\n]]\n    and\n[[\n    X ::= 2;;\n    Y ::= 1\n]]\n\n    (1) Yes\n\n    (2) No\n\n    (3) Not sure\n*)",
    "dst": "(** 这两个如何?\n[[\n    X ::= 1;;\n    Y ::= 2\n]]\n    和\n[[\n    X ::= 2;;\n    Y ::= 1\n]]\n    (1) 是\n    (2) 否\n    (3) 不确定\n*)",
    "votes": 0
  },
  {
    "id": 680,
    "src": "(** What about these?\n\n[[\n    WHILE 1 <= X DO\n      X ::= X + 1\n    END\n]]\n    and\n[[\n    WHILE 2 <= X DO\n      X ::= X + 1\n    END\n]]\n\n    (1) Yes\n\n    (2) No\n\n    (3) Not sure\n\n*)",
    "dst": "(** 这些呢?\n[[\n    WHILE 1 <= X DO\n      X ::= X + 1\n    END\n]]\n    和\n[[\n    WHILE 2 <= X DO\n      X ::= X + 1\n    END\n]]\n    (1) 是\n    (2) 否\n    (3) 不确定\n*)",
    "votes": 0
  },
  {
    "id": 681,
    "src": "(* INSTRUCTORS: No. (When started in a state where variable X has value 1,\n    the first program diverges while the second one halts.) *)",
    "dst": "(* HIDE: 非也. (在起始状态变量X的值为1的时候, 的一个程序永远循环而第二个能终止.) *)",
    "votes": 0
  },
  {
    "id": 682,
    "src": "(** These?\n[[\n    WHILE TRUE DO\n      WHILE FALSE DO X ::= X + 1 END\n    END\n]]\n    and\n[[\n    WHILE FALSE DO\n      WHILE TRUE DO X ::= X + 1 END\n    END\n]]\n\n    (1) Yes\n\n    (2) No\n\n    (3) Not sure\n*)",
    "dst": "(** 这些呢?\n[[\n    WHILE TRUE DO\n      WHILE FALSE DO X ::= X + 1 END\n    END\n]]\n    和\n[[\n    WHILE FALSE DO\n      WHILE TRUE DO X ::= X + 1 END\n    END\n]]\n    (1) 是\n    (2) 否\n    (3) 不确定\n*)",
    "votes": 0
  },
  {
    "id": 683,
    "src": "(* INSTRUCTORS: No. (The first program always diverges; the second\n   always halts.) *)",
    "dst": "(* HIDE: 否. (第一个程序总是死循环; 第二个总能终止.) *)",
    "votes": 0
  },
  {
    "id": 684,
    "src": "(** Prove that adding a [SKIP] after a command results in an\n    equivalent program *)",
    "dst": "(** 试证在任一命令后加上SKIP所变换出的新程序与原程序等价。 *)",
    "votes": 0
  },
  {
    "id": 685,
    "src": "(** Similarly, here is a simple transformation that optimizes [IFB]\n    commands: *)",
    "dst": "(** 类似的，这里是一些简化 [IFB] 的简单变换: *)",
    "votes": 0
  },
  {
    "id": 686,
    "src": "(** Of course, few programmers would be tempted to write a conditional\n    whose guard is literally [BTrue].  A more interesting case is when\n    the guard is _equivalent_ to true: *)",
    "dst": "(** 当然，一些程序员会尝试以IF的判断条件字面上是否等于 [BTrue] 作为优化前提。但一个\n    更有趣的方式是看IF的判断条件是否等价于真: *)",
    "votes": 0
  },
  {
    "id": 687,
    "src": "(** _Theorem_: If [b] is equivalent to [BTrue], then [IFB b THEN c1\n    ELSE c2 FI] is equivalent to [c1]. *)",
    "dst": "(** _Theorem_: 如果 [b] 等价于 [BTrue], 那么 [IFB b THEN c1\n   ELSE c2 FI] 等价于 [c1].\n*)",
    "votes": 0
  },
  {
    "id": 688,
    "src": "(**\n   _Proof_:\n\n     - ([->]) We must show, for all [st] and [st'], that if [IFB b\n       THEN c1 ELSE c2 FI / st \\\\ st'] then [c1 / st \\\\ st'].\n\n       Proceed by cases on the rules that could possibly have been\n       used to show [IFB b THEN c1 ELSE c2 FI / st \\\\ st'], namely\n       [E_IfTrue] and [E_IfFalse].\n\n       - Suppose the final rule rule in the derivation of [IFB b THEN\n         c1 ELSE c2 FI / st \\\\ st'] was [E_IfTrue].  We then have, by\n         the premises of [E_IfTrue], that [c1 / st \\\\ st'].  This is\n         exactly what we set out to prove.\n\n       - On the other hand, suppose the final rule in the derivation\n         of [IFB b THEN c1 ELSE c2 FI / st \\\\ st'] was [E_IfFalse].\n         We then know that [beval st b = false] and [c2 / st \\\\ st'].\n\n         Recall that [b] is equivalent to [BTrue], i.e., forall [st],\n         [beval st b = beval st BTrue].  In particular, this means\n         that [beval st b = true], since [beval st BTrue = true].  But\n         this is a contradiction, since [E_IfFalse] requires that\n         [beval st b = false].  Thus, the final rule could not have\n         been [E_IfFalse].\n\n     - ([<-]) We must show, for all [st] and [st'], that if [c1 / st\n       \\\\ st'] then [IFB b THEN c1 ELSE c2 FI / st \\\\ st'].\n\n       Since [b] is equivalent to [BTrue], we know that [beval st b] =\n       [beval st BTrue] = [true].  Together with the assumption that\n       [c1 / st \\\\ st'], we can apply [E_IfTrue] to derive [IFB b THEN\n       c1 ELSE c2 FI / st \\\\ st'].  []\n\n   Here is the formal version of this proof: *)",
    "dst": "(**\n   _Proof_:\n     - ([->]) 我们必须证明, 对于所有 [st] 和 [st'], 如果 [IFB b\n       THEN c1 ELSE c2 FI / st || st'] 则 [c1 / st || st'].\n       能够应用于 [IFB b THEN c1 ELSE c2 FI / st || st'] 的证明规则只有两条：\n       [E_IfTrue] 和 [E_IfFalse].\n       - 假设 [IFB b THEN c1 ELSE c2 FI / st || st'] 证明自 [E_IfTrue]\n         这条证明规则.  若使用证明规则 [E_IfTrue] 其必备的前提条件 [c1 / st || st'] 必为真， 而这正好是\n         我们的证明所需要的条件。\n       - 另一方面, 假设 [IFB b THEN c1 ELSE c2 FI / st || st'] 证明自\n         [E_IfFalse]. 我们能得知 [beval st b = false] 和 [c2 / st || st'].\n         之前提到 [b] 等价于 [BTrue], 也就是说对于所有 [st], 有[beval st b = beval st BTrue].\n         具体的说就是 [beval st b = true] 成立, 导致 [beval st BTrue = true] 成立。 \n         但是与此同时，之前假设 [E_IfFalse] 必备的前提条件 [beval st b = false] 也成立，\n         这就构成了一组矛盾。从而说明不可能使用了 [E_IfFalse] 这条证明规则。\n     - ([<-]) 我们必须证明，对于所有 [st] 和 [st'], 如果 [c1 / st || st']  \n       则 [IFB b THEN c1 ELSE c2 FI / st || st'].\n       已知 [b] 等价于 [BTrue], 我们知道 [beval st b] = [beval st BTrue] = [true].\n       结合 [c1 / st || st'] 这条假设, 我们能应用 [E_IfTrue] 来证明出 [IFB b THEN\n       c1 ELSE c2 FI / st || st'].  []\n   下面是这个证明的形式化版本: *)",
    "votes": 0
  },
  {
    "id": 689,
    "src": "(* b evaluates to true *)",
    "dst": "(* b 求值得出 true *)",
    "votes": 0
  },
  {
    "id": 690,
    "src": "(* b evaluates to false (contradiction) *)",
    "dst": "(* b 求值得出 false (矛盾) *)",
    "votes": 0
  },
  {
    "id": 691,
    "src": "(** TERSE: Similarly: *)",
    "dst": "(** TERSE: 同样: *)",
    "votes": 0
  },
  {
    "id": 692,
    "src": "(* b evaluates to true (contradiction) *)",
    "dst": "(* b 求值得出 true (矛盾) *)",
    "votes": 0
  },
  {
    "id": 693,
    "src": "(* b evaluates to false *)",
    "dst": "(* b 求值得出 false *)",
    "votes": 0
  },
  {
    "id": 694,
    "src": "(** Show that we can swap the branches of an IF if we also negate its\n    guard. *)",
    "dst": "(** 证明我们可以通过对条件取反来交换 IF 的两个分支 *)",
    "votes": 0
  },
  {
    "id": 695,
    "src": "(* b is true *)",
    "dst": "(* b 是 true *)",
    "votes": 0
  },
  {
    "id": 696,
    "src": "(* b is false *)",
    "dst": "(* b 是 false *)",
    "votes": 0
  },
  {
    "id": 697,
    "src": "(** For [WHILE] loops, we can give a similar pair of theorems.  A loop\n    whose guard is equivalent to [BFalse] is equivalent to [SKIP],\n    while a loop whose guard is equivalent to [BTrue] is equivalent to\n    [WHILE BTrue DO SKIP END] (or any other non-terminating program).\n    The first of these facts is easy. *)",
    "dst": "(** 对于 [WHILE] 循环我们能够给出一组相似的定理：当一个循环的条件等价于 [BFalse] 的\n    时候它等价于 [SKIP], 当一个循环的条件等价于 [BTrue] 的时候它等价于\n    [WHILE BTrue DO SKIP END] （或者任意不终止的程序）。\n    前者比较简单. *)",
    "votes": 0
  },
  {
    "id": 698,
    "src": "(** Write an informal proof of [WHILE_false].\n\n(* SOLUTION *)\n   Theorem: forall [b] [c], if [b] is equivalent to [BFalse],\n   then [WHILE b DO c END] is equivalent to [SKIP].\n\n   Proof:\n\n   - (->) We know that [b] is equivalent to [BFalse].  We must\n     show, for all [st] and [st'], that if [(WHILE b DO c END) /\n     st \\\\ st'] then [SKIP / st \\\\ st'].\n\n     There are only two ways we can have [(WHILE b DO c END) /\n     st \\\\ st']: using [E_WhileEnd] and [E_WhileLoop].\n\n     - Suppose the final rule used to show [(WHILE b DO c END) /\n       st \\\\ st'] was [E_WhileEnd].  We then know that [st =\n       st']; by [E_Skip], we know that [SKIP / st \\\\ st].\n\n     - Suppose the final rule used to show [(WHILE b DO c END) / st\n       \\\\ st'] was [E_WhileLoop].  But this rule only applies when\n       [beval st b = true].  However, we are assuming that\n       that [b] is equivalent to [BFalse], i.e., forall\n       [st], [beval st b = beval st BFalse = false]. So we have\n       a contradiction, and the final rule could not have been\n       [E_WhileLoop] after all.\n\n   - (<-) We know that [b] is equivalent to [BFalse].  We must\n     show, for all [st] and [st'], that if [SKIP / st \\\\ st']\n     then [(WHILE b DO c END) / st \\\\ st'].\n\n     [E_Skip] is the only rule that could have proven [SKIP / st\n     \\\\ st'], so we know that [st' = st].  We must show\n     that [(WHILE b DO c LOOP) / st \\\\ st].\n\n     Since [b] is equivalent to [BFalse], we know that [beval st\n     b = false].  By [E_WhileEnd], then, we can derive that\n     [(WHILE b DO c END) / st \\\\ st], and we are done.\n(* /SOLUTION *)\n[]\n*)",
    "dst": "(** 写出 [WHILE_false] 的非形式化证明.\n(* SOLUTION *)\n   Theorem: 对于所有 [b] [c], 如果 [b] 等价于 [BFalse],\n   那么 [WHILE b DO c END] 等价于 [SKIP].\n \n   Proof: \n   - (->) 已知 [b] 等价于 [BFalse]。那么我们需要证明对于所有 [st] 和 [st'] ，\n     如果 [(WHILE b DO c END) / st || st'] 成立那么 [SKIP / st || st'] 也成立。\n     \n     这里只有两种方法可以得到 [(WHILE b DO c END) /\n     st || st']: 使用 [E_WhileEnd] 或 [E_WhileLoop].\n     \n     - 假设 [(WHILE b DO c END) / st || st'] 使用的证明\n       规则是 [E_WhileEnd].  我们就得知假设的必备条件 [st = st']; 同时\n       根据证明规则 [E_Skip] 得知与之前等价的结论 [SKIP / st || st].\n     \n     - 假设最终的到 [(WHILE b DO c END) / st || st'] 使用的证明规则\n       是 [E_WhileLoop] 。那么证明的必备条件 [beval st b = true] 成立。\n       然而我们已经假设了 [b] 等价于 [BFalse] 。也就是说，对于所有 [st] ,\n       [beval st b = beval st BFalse = false] 。所以产生矛盾，\n       所以不可能最终使用了证明规则 [E_WhileLoop] 。\n   - (<-) 已知 [b] 等价于 [BFalse] 。我们需要证明对于所有 [st] 和 [st']，\n     如果 [SKIP / st || st'] 则 [(WHILE b DO c END) / st || st'] 。\n   \n     只有规则 [E_Skip] 可以证明出 [SKIP / st || st'] ，所以证明的必备条件 [st' = st] 成立。\n     我们必须证明 [(WHILE b DO c LOOP) / st || st] 。\n   \n     由于 [b] 等价于 [BFalse], 我们能够得知 [beval st b = false] 。显然 [E_WhileEnd]\n     证明出的 [(WHILE b DO c END) / st || st] 就是我们所需的，至此证毕 。\n(* /SOLUTION *)\n[]\n*)",
    "votes": 0
  },
  {
    "id": 699,
    "src": "(** To prove the second fact, we need an auxiliary lemma stating that\n    [WHILE] loops whose guards are equivalent to [BTrue] never\n    terminate. *)",
    "dst": "(** 为了证明第2个定理, 我们需要一个辅助定理: [WHILE] 循环在条件等价于\n     [BTrue] 的时候循环不会终止: *)",
    "votes": 0
  },
  {
    "id": 700,
    "src": "(** FULL: _Lemma_: If [b] is equivalent to [BTrue], then it cannot be the\n    case that [(WHILE b DO c END) / st \\\\ st'].\n\n    _Proof_: Suppose that [(WHILE b DO c END) / st \\\\ st'].  We show,\n    by induction on a derivation of [(WHILE b DO c END) / st \\\\ st'],\n    that this assumption leads to a contradiction.\n\n      - Suppose [(WHILE b DO c END) / st \\\\ st'] is proved using rule\n        [E_WhileEnd].  Then by assumption [beval st b = false].  But\n        this contradicts the assumption that [b] is equivalent to\n        [BTrue].\n\n      - Suppose [(WHILE b DO c END) / st \\\\ st'] is proved using rule\n        [E_WhileLoop].  Then we are given the induction hypothesis\n        that [(WHILE b DO c END) / st \\\\ st'] is contradictory, which\n        is exactly what we are trying to prove!\n\n      - Since these are the only rules that could have been used to\n        prove [(WHILE b DO c END) / st \\\\ st'], the other cases of\n        the induction are immediately contradictory. [] *)",
    "dst": "(** FULL: _Lemma_: 如果 [b] 等价于 [BTrue], 则不可能像\n     [(WHILE b DO c END) / st || st'] 这样会终止。\n    _Proof_: 假设循环会终止，即 [(WHILE b DO c END) / st || st'].  我们将证明在通过\n    对 [(WHILE b DO c END) / st || st'] 使用归纳法可以引出矛盾。\n      - 假设 [(WHILE b DO c END) / st || st'] 使用了 [E_WhileEnd] 这条证明规则。\n        那么根据假设得出 [beval st b = false] 。但是这和 [b] 等价于 [BTrue] 矛盾。\n      - 假设 [(WHILE b DO c END) / st || st'] 使用了 [E_WhileLoop] 这条证明规则.\n        结果就是给出了一个和 [(WHILE b DO c END) / st || st'] 矛盾的假设, 正巧是\n        我们正要证明的那个!\n      - 由于只有以上的几条规则可以证明出 [(WHILE b DO c END) / st || st'] 所以归纳时\n        的其他的情况会立即导致矛盾。 [] *)",
    "votes": 0
  },
  {
    "id": 701,
    "src": "(* Most rules don't apply, and we can rule them out\n       by inversion *)",
    "dst": "(* 大多数证明规则不可能应用，我们可以用 反演（inversion）来去除他们 *)",
    "votes": 0
  },
  {
    "id": 702,
    "src": "(* Most rules don't apply, and we can rule them out\n       by inversion *)",
    "dst": "(* 我们只关心这两个关于 WHILE 循环的证明规则: *)",
    "votes": 0
  },
  {
    "id": 703,
    "src": "(* The two interesting cases are the ones for WHILE loops: *)",
    "dst": "(* 我们只关心这两个关于 WHILE 循环的证明规则: *)",
    "votes": 0
  },
  {
    "id": 704,
    "src": "(* Most rules don't apply, and we can rule them out\n       by inversion *)",
    "dst": "(* 大多数证明规则不可能应用，我们可以用 反演（inversion）来去除他们 *)",
    "votes": 0
  },
  {
    "id": 705,
    "src": "(* contradictory -- b is always true! *)",
    "dst": "(* 矛盾 -- b 总是 true! *)",
    "votes": 0
  },
  {
    "id": 706,
    "src": "(* [rewrite] is able to instantiate the quantifier in [st] *)",
    "dst": "(* [rewrite] 能实例化Hb中的变量 [st] *)",
    "votes": 0
  },
  {
    "id": 707,
    "src": "(* immediate from the IH *)",
    "dst": "(* 直接使用IH *)",
    "votes": 0
  },
  {
    "id": 708,
    "src": "(** Explain what the lemma [WHILE_true_nonterm] means in English.\n\n(* SOLUTION *) [WHILE_true_nonterm] claims that if a [bexp] [b] is\n   equivalent to [BTrue] (i.e., if [forall st, beval st b = true]),\n   then it is not possible to construct a derivation [(WHILE b DO c\n   END) / st \\\\ st'] for any [st], [st'], or [c].\n\n   We can understand this lack of a derivation as nontermination: the\n   reason a derivation can't be constructed is because the\n   [E_WhileLoop] rule would need to be applied infinitely many times,\n   but derivations are finite.\n(* /SOLUTION *)\n*)",
    "dst": "(** 试解释 [WHILE_true_nonterm] 的意义。\n(* SOLUTION *) [WHILE_true_nonterm] 声称如果 [bexp] [b] 等价于 [BTrue]\n   (也就是说, 如果 [forall st, beval st b = true])，\n   那么对于任意的 [st], [st'], 和 [c] 我们都无法证明出 [(WHILE b DO c\n   END) / st || st'] 。\n   \n   我们可以理解这种无法推导为无法达到终止状态: 无法推导出的原因是推导规则 [E_WhileLoop] \n   需要无限次使用, 所以不可能在有限次推导内得出结果.\n(* /SOLUTION *)\n*)",
    "votes": 0
  },
  {
    "id": 709,
    "src": "(** FULL: Prove the following theorem. _Hint_: You'll want to use\n    [WHILE_true_nonterm] here. *)",
    "dst": "(** FULL: 证明下面的定理. _（提示）_ : 你可能需要使用 [WHILE_true_nonterm]. *)",
    "votes": 0
  },
  {
    "id": 710,
    "src": "(* TERSE: FOLD *)",
    "dst": "(* TERSE: FOLD *)",
    "votes": 0
  },
  {
    "id": 711,
    "src": "(* TERSE: /FOLD *)",
    "dst": "(* TERSE: /FOLD *)",
    "votes": 0
  },
  {
    "id": 712,
    "src": "(** FULL: [] *)",
    "dst": "(** FULL: [] *)",
    "votes": 0
  },
  {
    "id": 713,
    "src": "(* loop doesn't run *)",
    "dst": "(* 不执行循环 *)",
    "votes": 0
  },
  {
    "id": 714,
    "src": "(* loop runs *)",
    "dst": "(* 执行循环 *)",
    "votes": 0
  },
  {
    "id": 715,
    "src": "(* SOONER: AAA: I am just adding these to grade the exercise. If we decide to\n   keep this infrastructure, we could maybe move those to Imp.v. *)",
    "dst": "(* AAA: 我增加这些是为了给练习分级. 如果我们决定留下这些基础设施, 我们\n也许会把它们放在 Imp.v 里. *)",
    "votes": 0
  },
  {
    "id": 716,
    "src": "(** * Properties of Behavioral Equivalence *)",
    "dst": "(** * 行为等价的性质 *)",
    "votes": 0
  },
  {
    "id": 717,
    "src": "(** We next consider some fundamental properties of the program\n    equivalence relations. *)",
    "dst": "(** 现在我们开始开发之前定义的程序等价中的一些性质. *)",
    "votes": 0
  },
  {
    "id": 718,
    "src": "(** ** Behavioral Equivalence Is an Equivalence *)",
    "dst": "(** ** 行为等价是一种等价性 *)",
    "votes": 0
  },
  {
    "id": 719,
    "src": "(** First, we verify that the equivalences on [aexps], [bexps], and\n    [com]s really are _equivalences_ -- i.e., that they are reflexive,\n    symmetric, and transitive.  The proofs are all easy. *)",
    "dst": "(** 首先, 我们验证 [aexps], [bexps], 和 [com] 的确满足 _（等价性）_ （ _equivalences_ ）\n    -- 也就是说, 它们都满足 自反性（reflexive），对称性（symmetric）和 传递性（transitive）。\n    这些证明全都不难。 *)",
    "votes": 0
  },
  {
    "id": 720,
    "src": "(* Proof of assertion *)",
    "dst": "(* 断言的证明 *)",
    "votes": 0
  },
  {
    "id": 721,
    "src": "(* INSTRUCTORS: Note, this is in the standard libraries as\n   Coq.Class.RelationClasses.iff_Transitive; however, it is defined in\n   terms of a Transitive type class, so we re-prove a simpler version\n   here to avoid having to talk about type classes. *)",
    "dst": "(* INSTRUCTORS: 注意, 这在标准库中叫做 Coq.Class.RelationClasses.iff_Transitive;\n   但是它被定义成某个 Transitive 类型类中的一个成员, 所以我们用一个简化的版来避免涉及类型类. *)",
    "votes": 0
  },
  {
    "id": 722,
    "src": "(* ######################################################## *)",
    "dst": "(* ######################################################## *)",
    "votes": 0
  },
  {
    "id": 723,
    "src": "(** ** Behavioral Equivalence Is a Congruence *)",
    "dst": "(** ** 行为等价是一种一致性 *)",
    "votes": 0
  },
  {
    "id": 724,
    "src": "(** Less obviously, behavioral equivalence is also a _congruence_.\n    That is, the equivalence of two subprograms implies the\n    equivalence of the larger programs in which they are embedded:\n[[[\n              aequiv a1 a1'\n      -----------------------------\n      cequiv (i ::= a1) (i ::= a1')\n\n              cequiv c1 c1'\n              cequiv c2 c2'\n         ------------------------\n         cequiv (c1;;c2) (c1';;c2')\n]]]\n    ...and so on for the other forms of commands. *)",
    "dst": "(** 不太明显地, 行为等价也满足 _（一致性）_ （ _congruence_ ). 也就是说\n    两个子程序等价那么只有子程序有差异的两个大程序也等价:\n[[[\n              aequiv a1 a1'\n      -----------------------------\n      cequiv (i ::= a1) (i ::= a1')\n \n              cequiv c1 c1'    \n              cequiv c2 c2'\n         ------------------------\n         cequiv (c1;;c2) (c1';;c2')\n]]]\n    ...等等.  *)",
    "votes": 0
  },
  {
    "id": 725,
    "src": "(** FULL: (Note that we are using the inference rule notation here not\n    as part of a definition, but simply to write down some valid\n    implications in a readable format. We prove these implications\n    below.) *)",
    "dst": "(** FULL: (注意我们这里用的推理规则记号并不是定义的一部分, 只是将一些合法的蕴含式用易读的方式写下而已.\n    接下来我们将证明这些蕴含式.) *)",
    "votes": 0
  },
  {
    "id": 726,
    "src": "(** FULL: We will see a concrete example of why these congruence\n    properties are important in the following section (in the proof of\n    [fold_constants_com_sound]), but the main idea is that they allow\n    us to replace a small part of a large program with an equivalent\n    small part and know that the whole large programs are equivalent\n    _without_ doing an explicit proof about the non-varying parts --\n    i.e., the \"proof burden\" of a small change to a large program is\n    proportional to the size of the change, not the program. *)",
    "dst": "(** FULL: 我们会在接下来的章节（在 [fold_constants_com_sound] 的证明中）看到\n    一些例子能够说明为何这些一致性十分重要。但是它的主要意义在于这些一致性允许我们在用一小部\n    分程序替换一个大程序中等价的一部分并证明替换前和替换后程序的等价\n    性时 _（无需）_ 进行与不变的部分相关的证明；也即是说，程序的改变所产生\n    的证明的工作量与改变的大小而不是与整个程序的大小成比例。 *)",
    "votes": 0
  },
  {
    "id": 727,
    "src": "(** TERSE: These properties allow us to reason that a large program\n    behaves the same when we replace a small part with something\n    equivalent. *)",
    "dst": "(** TERSE: 这些性质允许我们证明当一个大程序之中的一个部分被行为等价的另一个\n      部分替换之后大程序的行为不变。 *)",
    "votes": 0
  },
  {
    "id": 728,
    "src": "(** FULL: The congruence property for loops is a little more interesting,\n    since it requires induction.\n\n    _Theorem_: Equivalence is a congruence for [WHILE] -- that is, if\n    [b1] is equivalent to [b1'] and [c1] is equivalent to [c1'], then\n    [WHILE b1 DO c1 END] is equivalent to [WHILE b1' DO c1' END].\n\n    _Proof_: Suppose [b1] is equivalent to [b1'] and [c1] is\n    equivalent to [c1'].  We must show, for every [st] and [st'], that\n    [WHILE b1 DO c1 END / st \\\\ st'] iff [WHILE b1' DO c1' END / st\n    \\\\ st'].  We consider the two directions separately.\n\n      - ([->]) We show that [WHILE b1 DO c1 END / st \\\\ st'] implies\n        [WHILE b1' DO c1' END / st \\\\ st'], by induction on a\n        derivation of [WHILE b1 DO c1 END / st \\\\ st'].  The only\n        nontrivial cases are when the final rule in the derivation is\n        [E_WhileEnd] or [E_WhileLoop].\n\n          - [E_WhileEnd]: In this case, the form of the rule gives us\n            [beval st b1 = false] and [st = st'].  But then, since\n            [b1] and [b1'] are equivalent, we have [beval st b1' =\n            false], and [E-WhileEnd] applies, giving us [WHILE b1' DO\n            c1' END / st \\\\ st'], as required.\n\n          - [E_WhileLoop]: The form of the rule now gives us [beval st\n            b1 = true], with [c1 / st \\\\ st'0] and [WHILE b1 DO c1\n            END / st'0 \\\\ st'] for some state [st'0], with the\n            induction hypothesis [WHILE b1' DO c1' END / st'0 \\\\\n            st'].\n\n            Since [c1] and [c1'] are equivalent, we know that [c1' /\n            st \\\\ st'0].  And since [b1] and [b1'] are equivalent, we\n            have [beval st b1' = true].  Now [E-WhileLoop] applies,\n            giving us [WHILE b1' DO c1' END / st \\\\ st'], as\n            required.\n\n      - ([<-]) Similar. [] *)",
    "dst": "(** FULL: 循环的一致性更有趣, 因为他需要使用归纳法（induction）.\n    _Theorem_: 对于 [WHILE] ，等价性是一种一致性 -- 也就是说, 如果 [b1] 等价于 [b1']\n    同时 [c1] 等价于 [c1'] ，那么 [WHILE b1 DO c1 END] 等价于\n     [WHILE b1' DO c1' END] 。\n    _Proof_: 假设 [b1] 等价于 [b1'] 同时 [c1] 等价于 [c1'] 。\n    我们要证明，对于所有 [st] 和 [st'] ， [WHILE b1 DO c1 END / st || st']\n    当且仅当 [WHILE b1' DO c1' END / st || st'] 。我们把两个方向分开考虑。\n      - ([->]) 我们证明 [WHILE b1 DO c1 END / st || st'] 蕴涵\n        [WHILE b1' DO c1' END / st || st'] ，对 [WHILE b1 DO c1 END / st || st']\n        使用归纳法。只有推导最后所使用的规则是 [E_WhileEnd] 和 [E_WhileLoop] 情况才需要\n\t   特别进行讨论。\n          - [E_WhileEnd]: 在这种情况时, 我们拥有假设的必备条件 [beval st b1 = false]\n            和 [st = st'] 。但是，因为 [b1] 和 [b1'] 是等价的，\n            我们有 [beval st b1' = false], 然后应用 [E-WhileEnd] ，\n            得出我们需要的 [WHILE b1' DO c1' END / st || st'] 。\n          - [E_WhileLoop]: 在这种情况时, 我们拥有假设的必备条件 [beval st b1 = true] ， \n            [c1 / st || st'0] 和 以及对某个状态 [st'0] 而言，有假设 [WHILE b1 DO c1 END / st'0 || st']\n            ，另外还有归纳假设 [WHILE b1' DO c1' END / st'0 || st'] 。\n            因为 [c1] 和 [c1'] 等价，推导出 [c1' / st || st'0] 。\n            然后因为 [b1] 和 [b1'] 等价，推导出 [beval st b1' = true] ，\n            最后应用 [E-WhileLoop] ，得出我们\n            需要的 [WHILE b1' DO c1' END / st || st'] 。\n      - ([<-]) 反之亦然. [] *)",
    "votes": 0
  },
  {
    "id": 729,
    "src": "(* E_WhileEnd *)",
    "dst": "(* E_WhileEnd *)",
    "votes": 0
  },
  {
    "id": 730,
    "src": "(* E_WhileLoop *)",
    "dst": "(* E_WhileLoop *)",
    "votes": 0
  },
  {
    "id": 731,
    "src": "(** For example, here are two equivalent programs and a proof of their\n    equivalence... *)",
    "dst": "(** 比如, 这里有两个等价的程序, 和他们的等价性证明... *)",
    "votes": 0
  },
  {
    "id": 732,
    "src": "(* <--- changed here *)",
    "dst": "(* <--- 这里有改动 *)",
    "votes": 0
  },
  {
    "id": 733,
    "src": "(** * Program Transformations *)",
    "dst": "(** * 程序变换 *)",
    "votes": 0
  },
  {
    "id": 734,
    "src": "(** A _program transformation_ is a function that takes a program as\n    input and produces some variant of the program as output.\n    Compiler optimizations such as constant folding are a canonical\n    example, but there are many others. *)",
    "dst": "(** _（程序变换）_ （ _program transformation_ ）是一种以任意程序\n    作为输入并且输出这个程序的某种变体的函数。比如编译中的常量折叠优化就是\n    一个典型的例子，但是程序变换不限于此。 *)",
    "votes": 0
  },
  {
    "id": 735,
    "src": "(** A program transformation is _sound_ if it preserves the\n    behavior of the original program. *)",
    "dst": "(** 如果一个程序变换的输出持有与其输入程序相同的行为，那么这个程序变换\n    是 _（健全）_ （ _sound_ ）的. \n \n    我们可以定义出 [aexp], [bexp], 和 [com] 的健全性的概念。 *)",
    "votes": 0
  },
  {
    "id": 736,
    "src": "(** ** The Constant-Folding Transformation *)",
    "dst": "(** ** 常量折叠变换 *)",
    "votes": 0
  },
  {
    "id": 737,
    "src": "(** An expression is _constant_ when it contains no variable\n    references.\n\n    Constant folding is an optimization that finds constant\n    expressions and replaces them by their values. *)",
    "dst": "(** 如果一个表达式不引用变量, 那么他就是 _（常量）_ （ _constant_ ）.\n \n    常量折叠是这样一种优化方式：找到常量表达式然后用它们的值替换它们. *)",
    "votes": 0
  },
  {
    "id": 738,
    "src": "(** Note that this version of constant folding doesn't eliminate\n    trivial additions, etc. -- we are focusing attention on a single\n    optimization for the sake of simplicity.  It is not hard to\n    incorporate other ways of simplifying expressions; the definitions\n    and proofs just get longer. *)",
    "dst": "(** 注意这个版本的常量折叠不包括优化显而易见的加法等. -- 为了简单起见我们先\n    把注意力集中在一个优化上.  把其他简化表达式的优化合并进来也不难; 只是\n    定义和证明会更长. *)",
    "votes": 0
  },
  {
    "id": 739,
    "src": "(** Not only can we lift [fold_constants_aexp] to [bexp]s (in the\n    [BEq] and [BLe] cases); we can also look for constant _boolean_\n    expressions and evaluate them in-place. *)",
    "dst": "(** 我们不仅可以把 [fold_constants_aexp] 优化到 [bexp] (比如在某些 [BEq]\n    和 [BLe] 的时候), 我们也能找到一些 _（布尔）_ （ _boolean_ ）表达式的常量\n    在原地化简他们. *)",
    "votes": 0
  },
  {
    "id": 740,
    "src": "(** To fold constants in a command, we apply the appropriate folding\n    functions on all embedded expressions. *)",
    "dst": "(** 为了化简程序中的常量, 我们需要在所有子表达式上使用适当的函数. *)",
    "votes": 0
  },
  {
    "id": 741,
    "src": "(* Original program: *)",
    "dst": "(* 原程序: *)",
    "votes": 0
  },
  {
    "id": 742,
    "src": "(* After constant folding: *)",
    "dst": "(* 常量折叠后: *)",
    "votes": 0
  },
  {
    "id": 743,
    "src": "(** ** Soundness of Constant Folding *)",
    "dst": "(** ** 常量折叠的健全性 *)",
    "votes": 0
  },
  {
    "id": 744,
    "src": "(** Now we need to show that what we've done is correct. *)",
    "dst": "(** 现在我们证明之前所做的事情的正确性. *)",
    "votes": 0
  },
  {
    "id": 745,
    "src": "(** FULL: Here's the proof for arithmetic expressions: *)",
    "dst": "(** FULL: 这是对算数表达式的证明: *)",
    "votes": 0
  },
  {
    "id": 746,
    "src": "(* ANum and AId follow immediately *)",
    "dst": "(* ANum 和 AId 很显然 *)",
    "votes": 0
  },
  {
    "id": 747,
    "src": "(* APlus, AMinus, and AMult follow from the IH\n       and the observation that\n              aeval st (APlus a1 a2)\n            = ANum ((aeval st a1) + (aeval st a2))\n            = aeval st (ANum ((aeval st a1) + (aeval st a2)))\n       (and similarly for AMinus/minus and AMult/mult) *)",
    "dst": "(* 从IH和下面的观察出发很容易完成 APlus , Aminus 和 AMult 的情况的证明：\n              aeval st (APlus a1 a2) \n            = ANum ((aeval st a1) + (aeval st a2)) \n            = aeval st (ANum ((aeval st a1) + (aeval st a2)))\n(之后的s AMinus/minus 和 AMult/mult 同理) *)",
    "votes": 0
  },
  {
    "id": 748,
    "src": "(** Here is an informal proof of the [BEq] case of the soundness\n    argument for boolean expression constant folding.  Read it\n    carefully and compare it to the formal proof that follows.  Then\n    fill in the [BLe] case of the formal proof (without looking at the\n    [BEq] case, if possible).\n\n   _Theorem_: The constant folding function for booleans,\n   [fold_constants_bexp], is sound.\n\n   _Proof_: We must show that [b] is equivalent to [fold_constants_bexp],\n   for all boolean expressions [b].  Proceed by induction on [b].  We\n   show just the case where [b] has the form [BEq a1 a2].\n\n   In this case, we must show\n[[\n       beval st (BEq a1 a2)\n     = beval st (fold_constants_bexp (BEq a1 a2)).\n]]\n   There are two cases to consider:\n\n     - First, suppose [fold_constants_aexp a1 = ANum n1] and\n       [fold_constants_aexp a2 = ANum n2] for some [n1] and [n2].\n\n       In this case, we have\n[[\n           fold_constants_bexp (BEq a1 a2)\n         = if beq_nat n1 n2 then BTrue else BFalse\n]]\n       and\n[[\n           beval st (BEq a1 a2)\n         = beq_nat (aeval st a1) (aeval st a2).\n]]\n       By the soundness of constant folding for arithmetic\n       expressions (Lemma [fold_constants_aexp_sound]), we know\n[[\n           aeval st a1\n         = aeval st (fold_constants_aexp a1)\n         = aeval st (ANum n1)\n         = n1\n]]\n       and\n[[\n           aeval st a2\n         = aeval st (fold_constants_aexp a2)\n         = aeval st (ANum n2)\n         = n2,\n]]\n       so\n[[\n           beval st (BEq a1 a2)\n         = beq_nat (aeval a1) (aeval a2)\n         = beq_nat n1 n2.\n]]\n       Also, it is easy to see (by considering the cases [n1 = n2] and\n       [n1 <> n2] separately) that\n[[\n           beval st (if beq_nat n1 n2 then BTrue else BFalse)\n         = if beq_nat n1 n2 then beval st BTrue else beval st BFalse\n         = if beq_nat n1 n2 then true else false\n         = beq_nat n1 n2.\n]]\n       So\n[[\n           beval st (BEq a1 a2)\n         = beq_nat n1 n2.\n         = beval st (if beq_nat n1 n2 then BTrue else BFalse),\n]]\n       as required.\n\n     - Otherwise, one of [fold_constants_aexp a1] and\n       [fold_constants_aexp a2] is not a constant.  In this case, we\n       must show\n[[\n           beval st (BEq a1 a2)\n         = beval st (BEq (fold_constants_aexp a1)\n                         (fold_constants_aexp a2)),\n]]\n       which, by the definition of [beval], is the same as showing\n[[\n           beq_nat (aeval st a1) (aeval st a2)\n         = beq_nat (aeval st (fold_constants_aexp a1))\n                   (aeval st (fold_constants_aexp a2)).\n]]\n       But the soundness of constant folding for arithmetic\n       expressions ([fold_constants_aexp_sound]) gives us\n[[\n         aeval st a1 = aeval st (fold_constants_aexp a1)\n         aeval st a2 = aeval st (fold_constants_aexp a2),\n]]\n       completing the case.  []\n*)",
    "dst": "(** 这里有一个 “布尔表达式常量折叠中 [BEq] 的健全性” 的非形式化证明。认真读完\n    再和下面的形式化证明做比较。然后补充完整下面 [BLe] 的情况的形式化证明 （尽量\n    不看之前的 [BEq] 的情况的证明 ）。\n   _Theorem_: 布尔表达式的常量折叠函数 [fold_constants_bexp] ，有健全性。\n   _Proof_: 我们必须证明 对于所有 [b] ， [fold_constants_bexp] 有健全性。\n   我们在 [b] 上使用归纳法. 这里只给出 [b] 有 [BEq a1 a2] 的形式的证明。\n   在本例中, 我们需要证明 \n[[\n       beval st (BEq a1 a2) \n     = beval st (fold_constants_bexp (BEq a1 a2)).\n]]\n   有两种情况需要讨论：\n     - 首先，假设对于某些 [n1] 和 [n2] 而言有 [fold_constants_aexp a1 = ANum n1] 和\n       [fold_constants_aexp a2 = ANum n2] 成立。\n       在这种���况下，我们有\n[[\n           fold_constants_bexp (BEq a1 a2) \n         = if beq_nat n1 n2 then BTrue else BFalse\n]]\n       和\n[[\n           beval st (BEq a1 a2) \n         = beq_nat (aeval st a1) (aeval st a2).\n]]\n       由于算数表达式的健全性(定理 [fold_constants_aexp_sound])，可得\n[[\n           aeval st a1 \n         = aeval st (fold_constants_aexp a1) \n         = aeval st (ANum n1) \n         = n1\n]]\n       和\n[[\n           aeval st a2 \n         = aeval st (fold_constants_aexp a2) \n         = aeval st (ANum n2) \n         = n2,\n]]\n       所以\n[[\n           beval st (BEq a1 a2) \n         = beq_nat (aeval a1) (aeval a2)\n         = beq_nat n1 n2.\n]]\n       同时, 容易看出 （在分别考虑 [n1 = n2] 和 [n1 <> n2] 的情况之后）\n[[\n           beval st (if beq_nat n1 n2 then BTrue else BFalse)\n         = if beq_nat n1 n2 then beval st BTrue else beval st BFalse\n         = if beq_nat n1 n2 then true else false\n         = beq_nat n1 n2.\n]]\n       所以\n[[\n           beval st (BEq a1 a2) \n         = beq_nat n1 n2.\n         = beval st (if beq_nat n1 n2 then BTrue else BFalse),\n]]         \n       正是所需的假设。\n     - 另一方面，假设 [fold_constants_aexp a1] 和 [fold_constants_aexp a2]\n       之中有一个不是常量。这种情况我们需要证明\n[[\n           beval st (BEq a1 a2) \n         = beval st (BEq (fold_constants_aexp a1)\n                         (fold_constants_aexp a2)),\n]]\n       根据 [beval] 的定义，它等同于证明\n[[\n           beq_nat (aeval st a1) (aeval st a2) \n         = beq_nat (aeval st (fold_constants_aexp a1))\n                   (aeval st (fold_constants_aexp a2)).\n]]\n       但是，由于算数表达式的健全性（定理 [fold_constants_aexp_sound]），可得出\n[[\n         aeval st a1 = aeval st (fold_constants_aexp a1)\n         aeval st a2 = aeval st (fold_constants_aexp a2),\n]]\n       本例证毕。 []\n*)",
    "votes": 0
  },
  {
    "id": 749,
    "src": "(* BTrue and BFalse are immediate *)",
    "dst": "(* BTrue 和 BFalse 是显然的 *)",
    "votes": 0
  },
  {
    "id": 750,
    "src": "(* BEq *)",
    "dst": "(* BEq *)",
    "votes": 0
  },
  {
    "id": 751,
    "src": "(** FULL: (Doing induction when there are a lot of constructors makes\n    specifying variable names a chore, but Coq doesn't always\n    choose nice variable names.  We can rename entries in the\n    context with the [rename] tactic: [rename a into a1] will\n    change [a] to [a1] in the current goal and context.) *)",
    "dst": "(* 当存在许多构造子时使用归纳法会使得认为指定变量名成为\n       一件琐事，然而Coq并不总是能够选择足够漂亮的变量名。\n       我们可以使用 重命名（[rename]）策略: [rename a into a1] \n会把当前目标和上下文中的 [a] 替换成 [a1]. *)",
    "votes": 0
  },
  {
    "id": 752,
    "src": "(* The only interesting case is when both a1 and a2\n       become constants after folding *)",
    "dst": "(* 唯一有趣的情况是 a1 和 a2 在折叠后同时变为常量 *)",
    "votes": 0
  },
  {
    "id": 753,
    "src": "(* a slightly alternative approach using asserts: *)",
    "dst": "(* 使用断言做一个小变形: *)",
    "votes": 0
  },
  {
    "id": 754,
    "src": "(* Again, the only interesting case is when both a1 and a2\n          become constants after folding *)",
    "dst": "(* 再次, 有趣的例子只有 a1 和 a2 在折叠后同时变为常量 *)",
    "votes": 0
  },
  {
    "id": 755,
    "src": "(* HIDE: compressed version of above [is this useful? -BCP]\n\n    unfold btrans_sound; unfold bequiv.\n    induction b; intros;\n    try reflexivity;\n    try\n      (simpl;\n       remember (fold_constants_aexp a) as a';\n       remember (fold_constants_aexp a0) as a0';\n       assert (aeval st a = aeval st a') as Ha;\n       assert (aeval st a0 = aeval st a0') as Ha0;\n         try (subst; apply fold_constants_aexp_sound);\n       destruct a'; destruct a0'; rewrite Ha; rewrite Ha0;\n       simpl; (try destruct (beq_nat n n0)); (try destruct (leb n n0));\n       reflexivity);\n    try (simpl; destruct (fold_constants_bexp b); rewrite IHb; reflexivity);\n    try (simpl; destruct (fold_constants_bexp b1);\n         destruct (fold_constants_bexp b2);\n         rewrite IHb1; rewrite IHb2; reflexivity). *)",
    "dst": "(* HIDE: 之前证明的紧凑版 [这个有必要吗? -BCP]\n    unfold btrans_sound; unfold bequiv. \n    induction b; intros; \n    try reflexivity;\n    try \n      (simpl; \n       remember (fold_constants_aexp a) as a';\n       remember (fold_constants_aexp a0) as a0';\n       assert (aeval st a = aeval st a') as Ha;\n       assert (aeval st a0 = aeval st a0') as Ha0; \n         try (subst; apply fold_constants_aexp_sound); \n       destruct a'; destruct a0'; rewrite Ha; rewrite Ha0;\n       simpl; (try destruct (beq_nat n n0)); (try destruct (ble_nat n n0)); \n       reflexivity);\n    try (simpl; destruct (fold_constants_bexp b); rewrite IHb; reflexivity);\n    try (simpl; destruct (fold_constants_bexp b1); \n         destruct (fold_constants_bexp b2); \n         rewrite IHb1; rewrite IHb2; reflexivity). *)",
    "votes": 0
  },
  {
    "id": 756,
    "src": "(** Complete the [WHILE] case of the following proof. *)",
    "dst": "(** 补充以下证明的有关 [WHILE] 的部分. *)",
    "votes": 0
  },
  {
    "id": 757,
    "src": "(* SKIP *)",
    "dst": "(* SKIP *)",
    "votes": 0
  },
  {
    "id": 758,
    "src": "(* ::= *)",
    "dst": "(* ::= *)",
    "votes": 0
  },
  {
    "id": 759,
    "src": "(* ;; *)",
    "dst": "(* ;; *)",
    "votes": 0
  },
  {
    "id": 760,
    "src": "(* IFB *)",
    "dst": "(* IFB *)",
    "votes": 0
  },
  {
    "id": 761,
    "src": "(* (If the optimization doesn't eliminate the if, then the\n          result is easy to prove from the IH and\n          [fold_constants_bexp_sound].) *)",
    "dst": "(* 如果if没有被优化掉, 那么我们很容易使用 IH 和 fold_constants_bexp_sound 来得出证明*)",
    "votes": 0
  },
  {
    "id": 762,
    "src": "(* b always true *)",
    "dst": "(* b 总为真 *)",
    "votes": 0
  },
  {
    "id": 763,
    "src": "(* b always false *)",
    "dst": "(* b 总为假 *)",
    "votes": 0
  },
  {
    "id": 764,
    "src": "(* WHILE *)",
    "dst": "(* WHILE *)",
    "votes": 0
  },
  {
    "id": 765,
    "src": "(* Again, the cases where [fold_constants_com] doesn't change\n          the test or don't change the loop body follow from the IH\n          and [fold_constants_bexp_sound] *)",
    "dst": "(* 依旧, 这种情况下 [fold_constants_com] 不会改变判断条件或者依然\n遵循 IH 和 [fold_constants_bexp_sound] *)",
    "votes": 0
  },
  {
    "id": 766,
    "src": "(* Pf of assertion *)",
    "dst": "(* 断言的证明 *)",
    "votes": 0
  },
  {
    "id": 767,
    "src": "(* ########################################################## *)",
    "dst": "(* ########################################################## *)",
    "votes": 0
  },
  {
    "id": 768,
    "src": "(** *** Soundness of (0 + n) Elimination, Redux *)",
    "dst": "(** *** (0 + n) 优化的健全性, 最终版 *)",
    "votes": 0
  },
  {
    "id": 769,
    "src": "(** Recall the definition [optimize_0plus] from the \\CHAP{Imp} chapter:\n[[\n    Fixpoint optimize_0plus (e:aexp) : aexp :=\n      match e with\n      | ANum n =>\n          ANum n\n      | APlus (ANum 0) e2 =>\n          optimize_0plus e2\n      | APlus e1 e2 =>\n          APlus (optimize_0plus e1) (optimize_0plus e2)\n      | AMinus e1 e2 =>\n          AMinus (optimize_0plus e1) (optimize_0plus e2)\n      | AMult e1 e2 =>\n          AMult (optimize_0plus e1) (optimize_0plus e2)\n      end.\n]]\n   Note that this function is defined over the old [aexp]s,\n   without states.\n\n   Write a new version of this function that accounts for variables,\n   plus analogous ones for [bexp]s and commands:\n[[\n     optimize_0plus_aexp\n     optimize_0plus_bexp\n     optimize_0plus_com\n]]\n   Prove that these three functions are sound, as we did for\n   [fold_constants_*].  Make sure you use the congruence lemmas in\n   the proof of [optimize_0plus_com] -- otherwise it will be _long_!\n\n   Then define an optimizer on commands that first folds\n   constants (using [fold_constants_com]) and then eliminates [0 + n]\n   terms (using [optimize_0plus_com]).\n\n   - Give a meaningful example of this optimizer's output.\n\n   - Prove that the optimizer is sound.  (This part should be _very_\n     easy.)  *)",
    "dst": "(** 回顾 \\CHAP{Imp} 中 [optimize_0plus] 的定义:\n[[\n    Fixpoint optimize_0plus (e:aexp) : aexp := \n      match e with\n      | ANum n => \n          ANum n\n      | APlus (ANum 0) e2 => \n          optimize_0plus e2\n      | APlus e1 e2 => \n          APlus (optimize_0plus e1) (optimize_0plus e2)\n      | AMinus e1 e2 => \n          AMinus (optimize_0plus e1) (optimize_0plus e2)\n      | AMult e1 e2 => \n          AMult (optimize_0plus e1) (optimize_0plus e2)\n      end.\n]]\n   注意这个函数是针对没有状态的旧 [aexp] 写的.\n   给 [aexp] [bexp] 和 [com] 都写一个带状态的新版本:\n[[\n     optimize_0plus_aexp\n     optimize_0plus_bexp\n     optimize_0plus_com\n]]\n   明这三个函数都具有健全性，就像之前证明 [fold_constants_*] 那样。\n   （在 [optimize_0plus_com] 的证明中你需要一致性引理 -- 否则证明过程会 _（很长）_ ！）\n   然后再在命令上定义一个新优化器，它首先使用常量折叠 （ [fold_constants_com] ）\n   然后使用 [0 + n] 优化（ [optimize_0plus_com] ）。\n   - 给这个优化器���出一个有意义的测试用例。\n   - 证明这个优化程序有健全性。（这部分应该会 _（很简单）_ 。） *)",
    "votes": 0
  },
  {
    "id": 770,
    "src": "(* ANum and AId are immediate by definition *)",
    "dst": "(* ANum 和 AId 根据其定义显而易见 *)",
    "votes": 0
  },
  {
    "id": 771,
    "src": "(* AMinus and AMult are immediate by IH *)",
    "dst": "(* AMinus 和 AMult 根据IH显而易见 *)",
    "votes": 0
  },
  {
    "id": 772,
    "src": "(* APlus *)",
    "dst": "(* APlus *)",
    "votes": 0
  },
  {
    "id": 773,
    "src": "(* everything but ANum and AId follow from the IH *)",
    "dst": "(* 除了 ANum 和 AId 都用 IH *)",
    "votes": 0
  },
  {
    "id": 774,
    "src": "(* ANum *)",
    "dst": "(* ANum *)",
    "votes": 0
  },
  {
    "id": 775,
    "src": "(* AId *)",
    "dst": "(* AId *)",
    "votes": 0
  },
  {
    "id": 776,
    "src": "(* BNot *)",
    "dst": "(* BNot *)",
    "votes": 0
  },
  {
    "id": 777,
    "src": "(** * Proving That Programs Are _Not_ Equivalent *)",
    "dst": "(** * 证明程序不等价 *)",
    "votes": 0
  },
  {
    "id": 778,
    "src": "(** Suppose that [c1] is a command of the form [X ::= a1;; Y ::= a2]\n    and [c2] is the command [X ::= a1;; Y ::= a2'], where [a2'] is\n    formed by substituting [a1] for all occurrences of [X] in [a2].\n    For example, [c1] and [c2] might be:\n[[\n       c1  =  (X ::= 42 + 53;;\n               Y ::= Y + X)\n       c2  =  (X ::= 42 + 53;;\n               Y ::= Y + (42 + 53))\n]]\n    Clearly, this _particular_ [c1] and [c2] are equivalent.  Is this\n    true in general? *)",
    "dst": "(** 假设 [c1] 是形如 [X ::= a1;; Y ::= a2] 的命令, 并且 [c2] 是\n    形如 [X ::= a1;; Y ::= a2'] 的命令, [a2'] 是把 [a2] 中\n    所有 [X] 都替换为 [a1] 后的结果.\n    比如, [c1] 和 [c2] 可以像这样:\n[[\n       c1  =  (X ::= 42 + 53;; \n               Y ::= Y + X)\n       c2  =  (X ::= 42 + 53;; \n               Y ::= Y + (42 + 53))\n]]\n    很明显在 _（这个特定例子中）_ [c1] 和 [c2] 是等价的. 但是对一般程序而言这个结果成立吗? *)",
    "votes": 0
  },
  {
    "id": 779,
    "src": "(** FULL: We will see in a moment that it is not, but it is worthwhile\n    to pause, now, and see if you can find a counter-example on your\n    own. *)",
    "dst": "(** FULL: 我们马上就能看到这是不行的, 但是且慢, 现在, 看你自己能否找一个反例出来. *)",
    "votes": 0
  },
  {
    "id": 780,
    "src": "(** More formally, here is the function that substitutes an arithmetic\n    expression for each occurrence of a given variable in another\n    expression: *)",
    "dst": "(** 下面形式化的定义描述了在算数表达式里如何把某个变量的所有引用替换为另一个表达式: *)",
    "votes": 0
  },
  {
    "id": 781,
    "src": "(** And here is the property we are interested in, expressing the\n    claim that commands [c1] and [c2] as described above are\n    always equivalent.  *)",
    "dst": "(** 而这里是一个我们感兴趣的性质：它说明了类似上述形式的 [c1] 和 [c2] 总是等价.  *)",
    "votes": 0
  },
  {
    "id": 782,
    "src": "(** Sadly, the property does _not_ always hold -- i.e., it is not the\n    case that, for all [i1], [i2], [a1], and [a2],\n[[\n      cequiv (i1 ::= a1;; i2 ::= a2)\n             (i1 ::= a1;; i2 ::= subst_aexp i1 a1 a2).\n]]\n    To see this, suppose (for a contradiction) that for all [i1], [i2],\n    [a1], and [a2], we have\n[[\n      cequiv (i1 ::= a1;; i2 ::= a2)\n             (i1 ::= a1;; i2 ::= subst_aexp i1 a1 a2).\n]]\n    Consider the following program:\n[[\n       X ::= APlus (AId X) (ANum 1);; Y ::= AId X\n]]\n    Note that\n[[\n       (X ::= APlus (AId X) (ANum 1);; Y ::= AId X)\n       / empty_state \\\\ st1,\n]]\n    where [st1 = { X |-> 1, Y |-> 1 }].\n\n    By assumption, we know that\n[[\n      cequiv (X ::= APlus (AId X) (ANum 1);;\n              Y ::= AId X)\n             (X ::= APlus (AId X) (ANum 1);;\n              Y ::= APlus (AId X) (ANum 1))\n]]\n    so, by the definition of [cequiv], we have\n[[\n      (X ::= APlus (AId X) (ANum 1);; Y ::= APlus (AId X) (ANum 1))\n      / empty_state \\\\ st1.\n]]\n    But we can also derive\n[[\n      (X ::= APlus (AId X) (ANum 1);; Y ::= APlus (AId X) (ANum 1))\n      / empty_state \\\\ st2,\n]]\n    where [st2 = { X |-> 1, Y |-> 2 }].  But [st1 <> st2], which is a\n    contradiction, since [ceval] is deterministic!  [] *)",
    "dst": "(** 遗憾的是, 这个性质 _（不）_ 总是成立. \n    _Theorem_: 对于所有 [i1], [i2], [a1], 和 [a2] 以下命题并不总是成立,\n[[\n         cequiv (i1 ::= a1;; i2 ::= a2)\n                (i1 ::= a1;; i2 ::= subst_aexp i1 a1 a2).\n]] \n    _Proof_: 我们使用反证法，假设对于所有 [i1], [i2], [a1], 和 [a2], 下面的假设成立\n[[\n      cequiv (i1 ::= a1;; i2 ::= a2) \n             (i1 ::= a1;; i2 ::= subst_aexp i1 a1 a2).\n]]\n    那么考虑下面的程序:\n[[\n         X ::= APlus (AId X) (ANum 1);; Y ::= AId X\n]]\n    注意下面的假设\n[[\n         (X ::= APlus (AId X) (ANum 1);; Y ::= AId X)\n         / empty_state || st1,\n]]\n    在 [st1 = { X |-> 1, Y |-> 1 }] 时成立.\n    根据假设\n[[\n        cequiv (X ::= APlus (AId X) (ANum 1);; Y ::= AId X)\n               (X ::= APlus (AId X) (ANum 1);; Y ::= APlus (AId X) (ANum 1))\n]]\n    同时根据 [cequiv] 的定义, 我们有\n[[\n        (X ::= APlus (AId X) (ANum 1);; Y ::= APlus (AId X) (ANum 1))\n        / empty_state || st1.\n]]\n    同时我们也能证明出\n[[\n        (X ::= APlus (AId X) (ANum 1);; Y ::= APlus (AId X) (ANum 1))\n        / empty_state || st2,\n]]\n    在 [st2 = { X |-> 1, Y |-> 2 }] 时成立。这里注意, 因为 [ceval] 是确定性的\n    但是已知 [st1 <> st2] 这就造成矛盾!  [] *)",
    "votes": 0
  },
  {
    "id": 783,
    "src": "(* SOONER: The [|->] notation hasn't been introduced, has it? *)",
    "dst": "(* SOONER: [|->] 记号没被引入, 有吗? *)",
    "votes": 0
  },
  {
    "id": 784,
    "src": "(* Here is the counterexample: assuming that [subst_equiv_property]\n     holds allows us to prove that these two programs are\n     equivalent... *)",
    "dst": "(* 这里有个反例: 假设 [subst_equiv_property] 让我们证明以下两个程序等价... *)",
    "votes": 0
  },
  {
    "id": 785,
    "src": "(* ... allows us to show that the command [c2] can terminate\n     in two different final states:\n        st1 = {X |-> 1, Y |-> 1}\n        st2 = {X |-> 1, Y |-> 2}. *)",
    "dst": "(* ... 让我们证明 [c2] 能终止于两个不同的状态: \n        st1 = {X |-> 1, Y |-> 1} \n        st2 = {X |-> 1, Y |-> 2}. *)",
    "votes": 0
  },
  {
    "id": 786,
    "src": "(* Finally, we use the fact that evaluation is deterministic\n     to obtain a contradiction. *)",
    "dst": "(* 最后, 因为程序求值的确定性而产生矛盾. *)",
    "votes": 0
  },
  {
    "id": 787,
    "src": "(** The equivalence we had in mind above was not complete nonsense --\n    it was actually almost right.  To make it correct, we just need to\n    exclude the case where the variable [X] occurs in the\n    right-hand-side of the first assignment statement. *)",
    "dst": "(** 之前我们想的等价性也不是完全胡说八道 -- 差一点就正确了. 只要增加一个\n    条件就是正确的, 只要保证 [X] 不在第一个等式的右边出现. *)",
    "votes": 0
  },
  {
    "id": 788,
    "src": "(* the binary operators follow from the IH *)",
    "dst": "(* 用 IH 证二元操作 *)",
    "votes": 0
  },
  {
    "id": 789,
    "src": "(** Using [var_not_used_in_aexp], formalize and prove a correct verson\n    of [subst_equiv_property]. *)",
    "dst": "(** 使用 [var_not_used_in_aexp] 形式化证明这个正确版的 [subst_equiv_property]. *)",
    "votes": 0
  },
  {
    "id": 790,
    "src": "(* operator cases follow from the IH *)",
    "dst": "(* 运算符的分类用 IH 证 *)",
    "votes": 0
  },
  {
    "id": 791,
    "src": "(* i = i0 *)",
    "dst": "(* i = i0 *)",
    "votes": 0
  },
  {
    "id": 792,
    "src": "(* i <> i0 *)",
    "dst": "(* i <> i0 *)",
    "votes": 0
  },
  {
    "id": 793,
    "src": "(** Prove that an infinite loop is not equivalent to [SKIP] *)",
    "dst": "(** 证明死循环不等价于 [SKIP] *)",
    "votes": 0
  },
  {
    "id": 794,
    "src": "(** * Extended Exercise: Nondeterministic Imp *)",
    "dst": "(** * 扩展练习: 非确定性 Imp *)",
    "votes": 0
  },
  {
    "id": 795,
    "src": "(* HIDE: Mukund: This issue will need repetition when we introduce\n   small-step semantics. There's also a nice exercise for Hoare.v in\n   the midterm. *)",
    "dst": "(* HIDE: Mukund: 这个问题需要在我们引入小步语义的时候重提. 这同样也是 Hoare.v\n   中期的好练习. *)",
    "votes": 0
  },
  {
    "id": 796,
    "src": "(** As we have seen (in theorem [ceval_deterministic] in the [Imp]\n    chapter), Imp's evaluation relation is deterministic.  However,\n    _non_-determinism is an important part of the definition of many\n    real programming languages. For example, in many imperative\n    languages (such as C and its relatives), the order in which\n    function arguments are evaluated is unspecified.  The program\n    fragment\n[[\n      x = 0;;\n      f(++x, x)\n]]\n    might call [f] with arguments [(1, 0)] or [(1, 1)], depending how\n    the compiler chooses to order things.  This can be a little\n    confusing for programmers, but it gives the compiler writer useful\n    freedom.\n\n    In this exercise, we will extend Imp with a simple\n    nondeterministic command and study how this change affects\n    program equivalence.  The new command has the syntax [HAVOC X],\n    where [X] is an identifier. The effect of executing [HAVOC X] is\n    to assign an _arbitrary_ number to the variable [X],\n    nondeterministically. For example, after executing the program:\n[[\n      HAVOC Y;;\n      Z ::= Y * 2\n]]\n    the value of [Y] can be any number, while the value of [Z] is\n    twice that of [Y] (so [Z] is always even). Note that we are not\n    saying anything about the _probabilities_ of the outcomes -- just\n    that there are (infinitely) many different outcomes that can\n    possibly happen after executing this nondeterministic code.\n\n    In a sense, a variable on which we do [HAVOC] roughly corresponds\n    to an unitialized variable in a low-level language like C.  After\n    the [HAVOC], the variable holds a fixed but arbitrary number.  Most\n    sources of nondeterminism in language definitions are there\n    precisely because programmers don't care which choice is made (and\n    so it is good to leave it open to the compiler to choose whichever\n    will run faster).\n\n    We call this new language _Himp_ (``Imp extended with [HAVOC]''). *)",
    "dst": "(** 就像之前看到的 (在 Imp那章里的 [ceval_deterministic]), Imp 的关联的求值\n    是确定性的.  但是, _（不确定性）_ 是很多程序语言定义中重要的一部分. 比如, 在很多\n    命令式语言中 (比如C和类C的语言), 函数参数的求值顺序是未定义的. 程序片段\n[[\n      x = 0;;\n      f(++x, x)\n]]\n    调用 [f] 的参数也许是 [(1, 0)] 又也许是 [(1, 1)], 取决于编译器的选择. \n    这可能让程序员有些困惑, 但是给了编译器作者选择实现的自由.\n    在这个练习里, 我们要用一个简单的非确定性命令扩展 Imp 来学习这个扩展对响程\n    序等价性有什么影响.  这个新命令写作 [HAVOC X], [X] 是一个标识符.\n    执行 [HAVOC X] 的作用是给 [X] 分配一个不确定的 _（任意）_ 数字. 比如,\n    计算这个程序之后:\n[[\n      HAVOC Y;;\n      Z ::= Y * 2\n]]\n    [Y] 的值可以是任意变量, 且 [Z] 的值是 [Y] 的两倍 (所以 [Z] 总是偶数).\n    注意, 我们并没有讨论输出值的 _（概率）_ -- 只是这里在执行非确定性代码后有\n    非常多（无穷）的可能的不同的输出.\n    某种意义上来说 [HAVOC] 大致相当与C语言中的未初始化变量. 经过了 [HAVOC]\n    变量获得一个任意的但是不会改变的数字.  语言定义中非确定性大部分来源于程序员\n    对程序到底作出了什么选择并不那么关心 (好处是能让编译器有自由选择运行速度更快的方法).\n    我们称这个新语言为 _Himp_ (``在 Imp 上扩展了 [HAVOC]''). *)",
    "votes": 0
  },
  {
    "id": 797,
    "src": "(** To formalize Himp, we first add a clause to the definition of\n    commands. *)",
    "dst": "(** 为了形式化这个语言, 我们先在命令定义里增加一条. *)",
    "votes": 0
  },
  {
    "id": 798,
    "src": "(* <---- new *)",
    "dst": "(* <---- 新的 *)",
    "votes": 0
  },
  {
    "id": 799,
    "src": "(** Now, we must extend the operational semantics. We have provided\n   a template for the [ceval] relation below, specifying the big-step\n   semantics. What rule(s) must be added to the definition of [ceval]\n   to formalize the behavior of the [HAVOC] command? *)",
    "dst": "(** 现在, 我们必须扩展操作语义. 这里提供了一个 [ceval] 关系的模板, 规定了\n    其大步语义. 现在为了形式化 [HAVOC] 规则还需要怎样的扩充？ *)",
    "votes": 0
  },
  {
    "id": 800,
    "src": "(** As a sanity check, the following claims should be provable for\n    your definition: *)",
    "dst": "(** 作为合理的检查, 下面的命题使用你的定义应该是可证的: *)",
    "votes": 0
  },
  {
    "id": 801,
    "src": "(** Finally, we repeat the definition of command equivalence from above: *)",
    "dst": "(** 最后, 我们重新定义和之前相同的等价性定理: *)",
    "votes": 0
  },
  {
    "id": 802,
    "src": "(** Let's apply this definition to prove some nondeterministic\n    programs equivalent / inequivalent. *)",
    "dst": "(** 这个定义对于可终止的程序仍然是合理的, 然后我们来用它证明非确定性程序的等价\n    或者非等价. *)",
    "votes": 0
  },
  {
    "id": 803,
    "src": "(** Are the following two programs equivalent? *)",
    "dst": "(** 下面的两个程序等价吗? *)",
    "votes": 0
  },
  {
    "id": 804,
    "src": "(** If you think they are equivalent, prove it. If you think they are\n    not, prove that. *)",
    "dst": "(** 如果你认为他是等价的, 证明它是等价的, 如果认为它是不等价的, 也给出证明. *)",
    "votes": 0
  },
  {
    "id": 805,
    "src": "(* X = Y *)",
    "dst": "(* X = Y *)",
    "votes": 0
  },
  {
    "id": 806,
    "src": "(* X <> Y *)",
    "dst": "(* X <> Y *)",
    "votes": 0
  },
  {
    "id": 807,
    "src": "(** Are the following two programs equivalent? *)",
    "dst": "(** 下面的两个程序等价吗? *)",
    "votes": 0
  },
  {
    "id": 808,
    "src": "(** If you think they are equivalent, then prove it. If you think they\n    are not, then prove that.  (Hint: You may find the [assert] tactic\n    useful.) *)",
    "dst": "(** 如果你认为他是等价的, 证明它是等价的, 如果认为它是不等价的, 也给出证明.\n    (Hint: 你也许会发现 [assert] 策略很有用.) *)",
    "votes": 0
  },
  {
    "id": 809,
    "src": "(** The definition of program equivalence we are using here has some\n    subtle consequences on programs that may loop forever.  What\n    [cequiv] says is that the set of possible _terminating_ outcomes\n    of two equivalent programs is the same. However, in a language\n    with nondeterminism, like Himp, some programs always terminate,\n    some programs always diverge, and some programs can\n    nondeterministically terminate in some runs and diverge in\n    others. The final part of the following exercise illustrates this\n    phenomenon.\n*)",
    "dst": "(** 我们使用的程序等价的定义在无限循环的程序上的结果有点复杂. 因为 [cequiv] \n    描述的是 _（程序能够终止时）_ 两个程序的输出等价. 但是, 在有类似 Himp 的\n    非确定性的语言里，有些程序总是停机，有些程序总是死循环，还有一些程序会\n    非确定性地在某些时候停机或者在另外一些时候不断循环。下面习题的最后一部分展示了这个现���.\n*)",
    "votes": 0
  },
  {
    "id": 810,
    "src": "(** Consider the following commands: *)",
    "dst": "(** 考虑下面两个命令: *)",
    "votes": 0
  },
  {
    "id": 811,
    "src": "(** Intuitively, [p1] and [p2] have the same termination behavior:\n    either they loop forever, or they terminate in the same state they\n    started in.  We can capture the termination behavior of [p1] and\n    [p2] individually with these lemmas: *)",
    "dst": "** 直觉上, 这两个程序有相同的终止行为: 要么都死循环, 要么终止在同一个状态.\n    我们用下面的引理可以分别捕获 p1 和 p2 的终止行为: *)",
    "votes": 0
  },
  {
    "id": 812,
    "src": "(** Use these two lemmas to prove that [p1] and [p2] are actually\n    equivalent. *)",
    "dst": "(** 你应该用这些引理证明 p1 和 p2 确实等价. *)",
    "votes": 0
  },
  {
    "id": 813,
    "src": "(** First, note that the programs [p3] and [p4] are not equivalent:\n    when [p3] terminates, even though [X] definitely has value [0],\n    [Z] might have any natural number as the value. *)",
    "dst": "(** 首先, 注意程序 [p3] 和 [p4] 不等价:\n    在 [p3] 停机时, 即使 [X] 的值必然为 [0], [Z] 的值也会是任意自然数. *)",
    "votes": 0
  },
  {
    "id": 814,
    "src": "(** Prove that the following programs are _not_ equivalent.  (Hint:\n    What should the value of [Z] be when [p3] terminates?  What about\n    [p4]?) *)",
    "dst": "(** 证明下面的程序 _（不等价）_ . (Hint:\n    What should the value of [Z] be when [p3] terminates?  What about\n    [p4]?) *)",
    "votes": 0
  },
  {
    "id": 815,
    "src": "(** Programs [p5] and [p6] are equivalent although [p5] may diverge,\n    while [p6] always terminates. The definition we took for [cequiv]\n    cannot distinguish between these two scenarios. It accepts the two\n    programs as equivalent on the basis that: if [p5] terminates it\n    produces the same final state as [p6], and there exists an\n    execution in which [p5] terminates and does exactly as [p6].\n\n    There are two directions to the proof:\n\n    [->]: Observe that whenever [p5] terminates, it does so with [X]\n    set to [1], and no other variable changed. But this is exactly the\n    behavior of [p6]. Thus given a pair of states [st] and [st'] and\n    that [p5 / st \\\\ st'], the answer to the question \"Does [p6 / st\n    \\\\ st']?\"  is \"Yes\".\n\n    [<-] (and more controversially): Given that [p6 / st \\\\ st'] for\n    some [st] and [st'], can we show that [p5 / st | st']? Observe\n    that we can use the hypothesis to conclude that [st' = t_update st X\n    1]. Is there some execution of [p5] starting from [st] which also\n    ends up in [st']? Yes!\n\n    Hence their equivalence. *)",
    "dst": "(** 程序 [p5] 和 [p6] 等价，虽然 [p5] 也许死循环，而 [p6] 总是能停机。\n    我们选择的 [cequiv] 的定义不能区分这两种情况。它会在基于以下事实接受两个程序的等价：\n    如果 [p5] 能停机他产生和 [p6] 相同的最终状态，而且确实存在一种计算使得\n    [p5] 停机且最终状态与 [p6] 一致。\n    这里有证明的两个方向:\n    [->]: 观察可知当 [p5] 能够停机时，它将 [X] 设置为 [1] 且不改变其他的变量。\n    这也是 [p6] 的行为。所以给出状态 [st] 和 [st'] 且 [p5 / st || st'],\n    问题 \"是否能证明 [p6 / st || st'] ？\" 的回答是肯定的。\n    [<-] (更具争议): 当 [p6 / st || st'] 对 [st] 和 [st'] 成立时，\n    我们能得出 [p5 / st | st'] 的结论吗? 显然我们可以使用假设来推断出\n    [st' = update st X 1] 。可能存在从 [st] 开始执行 [p5] 最终终止在 [st'] 上的情况吗？\n    显然存在！\n    因此它们等价。 *)",
    "votes": 0
  },
  {
    "id": 816,
    "src": "(* SOONER: Mukund: The following proof is a Coq circus show.\n   Can it be simplified? *)",
    "dst": "(* SOONER: Mukund: 下面的证明使用了一些花巧的Coq技巧，它能被简化吗？ *)",
    "votes": 0
  },
  {
    "id": 817,
    "src": "(* X = 1 *)",
    "dst": "(* X = 1 *)",
    "votes": 0
  },
  {
    "id": 818,
    "src": "(* X <> 1 *)",
    "dst": "(* X <> 1 *)",
    "votes": 0
  },
  {
    "id": 819,
    "src": "(** * Doing Without Extensionality (Optional) *)",
    "dst": "(** * 不使用外延公理 (进阶) *)",
    "votes": 0
  },
  {
    "id": 820,
    "src": "(** Purists might object to using the [functional_extensionality]\n    axiom as we have here (e.g., in the proof of the [t_update_same]\n    lemma).  In general, it can be dangerous to add axioms willy\n    nilly, particularly several at once (as they may be mutually\n    inconsistent). In fact, it is known that\n    [functional_extensionality] and [excluded_middle] can both be\n    assumed without any problems; nevertheless, some Coq users prefer\n    to avoid such \"heavyweight\" general techniques and instead try to\n    craft solutions for specific problems that stay within Coq's\n    built-in logic.\n\n    For our particular problem here, rather than extending the\n    definition of equality to do what we want on functions\n    representing states, we could instead give an explicit notion of\n    _equivalence_ on states.  For example: *)",
    "dst": "(** 纯粹主义者可能会反对使用 外延公理（ [functional_extensionality] ）。\n    总的来说, 增加新公理是���危险的, 特别是一次增加多个的时候（它们可能会互相不一致）。\n    事实上， [functional_extensionality] 和 [excluded_middle] 的加入\n    都不会造成任何问题，但是一些 Coq 使用者更愿意避开这些“重量级”的通用技巧，\n    而对特定问题在Coq的标准逻辑之内构造解决方案。\n    与其为了对表示状态的函数进行我们想进行的任意操作而扩展等价的定义，\n    不如为了表示状态的 _（等价性）_ 而专门给出一个明晰的定义。例如： *)",
    "votes": 0
  },
  {
    "id": 821,
    "src": "(** It is easy to prove that [stequiv] is an _equivalence_ (i.e., it\n   is reflexive, symmetric, and transitive), so it partitions the set\n   of all states into equivalence classes. *)",
    "dst": "(** 证明 [stequiv] 的 _（等价性）_ （ _equivalence_ ）很简单 （即，它包含自反性，对称性和\n    传递性），所以它能把所有状态中等价的状态分离出来。 *)",
    "votes": 0
  },
  {
    "id": 822,
    "src": "(** It is then straightforward to show that [aeval] and [beval] behave\n    uniformly on all members of an equivalence class: *)",
    "dst": "(** 显然 [aeval] 和 [beval] 对所有等价的情况行为一致： *)",
    "votes": 0
  },
  {
    "id": 823,
    "src": "(* BLe *)",
    "dst": "(* BLe *)",
    "votes": 0
  },
  {
    "id": 824,
    "src": "(* BAnd *)",
    "dst": "(* BAnd *)",
    "votes": 0
  },
  {
    "id": 825,
    "src": "(** We can also characterize the behavior of [ceval] on equivalent\n    states (this result is a bit more complicated to write down\n    because [ceval] is a relation). *)",
    "dst": "(** 我们同样能描述 [ceval] 在等价状态下的行为 (因为[ceval]是一个关系，\n    所以这里有一点复杂)。 *)",
    "votes": 0
  },
  {
    "id": 826,
    "src": "(* := *)",
    "dst": "(* := *)",
    "votes": 0
  },
  {
    "id": 827,
    "src": "(* ; *)",
    "dst": "(* ; *)",
    "votes": 0
  },
  {
    "id": 828,
    "src": "(* IfTrue *)",
    "dst": "(* IfTrue *)",
    "votes": 0
  },
  {
    "id": 829,
    "src": "(* IfFalse *)",
    "dst": "(* IfFalse *)",
    "votes": 0
  },
  {
    "id": 830,
    "src": "(* WhileEnd *)",
    "dst": "(* WhileEnd *)",
    "votes": 0
  },
  {
    "id": 831,
    "src": "(* WhileLoop *)",
    "dst": "(* WhileLoop *)",
    "votes": 0
  },
  {
    "id": 832,
    "src": "(** Now we need to redefine [cequiv] to use [~] instead of [=].  It is\n    not completely trivial to do this in a way that keeps the\n    definition simple and symmetric, but here is one approach (thanks\n    to Andrew McCreight). We first define a looser variant of [\\\\]\n    that \"folds in\" the notion of equivalence. *)",
    "dst": "(** 现在我们需要使用 [~] 而不是 [=] 来重新定义 [cequiv] 。 让定义保持简单\n    而又对称不是那么简单，这里是其中一种比较好的方式 （感谢 Andrew McCreight）。\n    我们先定义一个宽松版的 [\\\\] 来“概括”等价性的记号。 *)",
    "votes": 0
  },
  {
    "id": 833,
    "src": "(** Now the revised definition of [cequiv'] looks familiar: *)",
    "dst": "(** 修订过的 [cequiv'] 定义看上去比较眼熟： *)",
    "votes": 0
  },
  {
    "id": 834,
    "src": "(** A sanity check shows that the original notion of command\n   equivalence is at least as strong as this new one.  (The converse\n   is not true, naturally.) *)",
    "dst": "(** 现在仔细检查原等价概念是不是至少和新的一样强。 （当然。逆命题是不成立的。） *)",
    "votes": 0
  },
  {
    "id": 835,
    "src": "(** Finally, here is our example once more... Notice that we use the\n    [t_update_same_no_ext] lemma in order to avoid invoking functional\n    extensionality. (You can complete the proofs.) *)",
    "dst": "(** 最终，这里又是我们的例子... 注意, 我们使用 [t_update_same_no_ext] 引理来避免使用外延公理. （现在你可以完成证明了。） *)",
    "votes": 0
  },
  {
    "id": 836,
    "src": "(* x1 = x2 *)",
    "dst": "(* x1 = x2 *)",
    "votes": 0
  },
  {
    "id": 837,
    "src": "(* false *)",
    "dst": "(* false *)",
    "votes": 0
  },
  {
    "id": 838,
    "src": "(** On the whole, this explicit equivalence approach is considerably\n    harder to work with than relying on functional\n    extensionality. (Coq does have an advanced mechanism called\n    \"setoids\" that makes working with equivalences somewhat easier, by\n    allowing them to be registered with the system so that standard\n    rewriting tactics work for them almost as well as for equalities.)\n    But it is worth knowing about, because it applies even in\n    situations where the equivalence in question is _not_ over\n    functions.  For example, if we chose to represent state mappings\n    as binary search trees, we would need to use an explicit\n    equivalence of this kind. *)",
    "dst": "(** 总的来说, 使用这种显性定义等价的方法相较起使用外延公理来会相当复杂。\n    （Coq有一个称作‘等价类型’（\"setoids\"）的高级机制，它允许这些关系在Coq\n    系统中登记并让标准的重写策略将这些关系与等式几乎看作是相同的，这样在进行\n    与等价性相关的工作时会在某种程度上变得更加容易。）\n    但是这是值得去做的, 因为它也能应用在函数 _（之外）_ 的等价问题上。比如，\n    如果我们使用二叉搜索树来实现状态映射，对这类问题我们就需要显性等价。 *)",
    "votes": 0
  },
  {
    "id": 839,
    "src": "(* ####################################### *)",
    "dst": "(* ####################################### *)",
    "votes": 0
  },
  {
    "id": 840,
    "src": "(* For the record, here's how we could use setoids here. I don't think\n   this is worth showing, though. *)",
    "dst": "(* 只为了记录, 这里展示怎么用setoids. 虽然我不认为值得展示. *)",
    "votes": 0
  },
  {
    "id": 841,
    "src": "(* We can redo this proof using setoid rewriting... *)",
    "dst": "(* 我们可以用setoid的写法重写证明... *)",
    "votes": 0
  },
  {
    "id": 842,
    "src": "(* And this one... *)",
    "dst": "(* 还有这个... *)",
    "votes": 0
  },
  {
    "id": 843,
    "src": "(* The example gets slightly simpler too... *)",
    "dst": "(* 这个例子也稍微精简了一些... *)",
    "votes": 0
  },
  {
    "id": 844,
    "src": "(** * Additional Exercises *)",
    "dst": "(** * 附加题 *)",
    "votes": 0
  },
  {
    "id": 845,
    "src": "(** This exercise extends the optional [add_for_loop] exercise from\n    the \\CHAP{Imp} chapter, where you were asked to extend the language\n    of commands with C-style [for] loops.  Prove that the command:\n[[\n      for (c1 ; b ; c2) {\n          c3\n      }\n]]\n    is equivalent to:\n[[\n       c1 ;\n       WHILE b DO\n         c3 ;\n         c2\n       END\n]]\n*)",
    "dst": "(** 这个练习是 Imp.v 中 可选练习[add_for_loop] 的扩展,\n    就是那个让你扩展出类似C风格的for循环命令的练习.  证明命令:\n[[\n      for (c1 ; b ; c2) {\n          c3\n      }\n]]\n    等价于:\n[[\n       c1 ; \n       WHILE b DO\n         c3 ;\n         c2\n       END\n]]\n*)",
    "votes": 0
  },
  {
    "id": 846,
    "src": "(** (Hint: You'll need [functional_extensionality] for this one.) *)",
    "dst": "(** (Hint: 你也许需要 [functional_extensionality] 来完成此题.) *)",
    "votes": 0
  },
  {
    "id": 847,
    "src": "(** In this exercise we define an asymmetric variant of program\n    equivalence we call _program approximation_. We say that a\n    program [c1] _approximates_ a program [c2] when, for each of\n    the initial states for which [c1] terminates, [c2] also terminates\n    and produces the same final state. Formally, program approximation\n    is defined as follows: *)",
    "dst": "(** 这个练习里我们定义一个非对称的程序等价变形, 叫做\n    _（程序近似）_ （ _program approximation_ ）。 当每个能让 [c1] 终止的初始状态\n    也能让 [c2] 终止到相同的状态，我们就说程序 [c1] _（近似）_ 程序 [c2] 。\n    下面形式化定义程序近似: *)",
    "votes": 0
  },
  {
    "id": 848,
    "src": "(** For example, the program [c1 = WHILE X <> 1 DO X ::= X - 1 END]\n    approximates [c2 = X ::= 1], but [c2] does not approximate [c1]\n    since [c1] does not terminate when [X = 0] but [c2] does.  If two\n    programs approximate each other in both directions, then they are\n    equivalent. *)",
    "dst": "(** 例如, 程序 [c1 = WHILE X <> 1 DO X ::= X - 1 END]\n    近似 [c2 = X ::= 1], 但是 [c2] 不近似 [c1]\n    因为 [c1] 在 [X = 0] 时死循环, 但是 [c2] 不会. 如果两个程序互相近似,\n    那么他们等价. *)",
    "votes": 0
  },
  {
    "id": 849,
    "src": "(** Find two programs [c3] and [c4] such that neither approximates\n    the other. *)",
    "dst": "(** 请找出互不近似的两个程序 [c3] 和 [c4]. 证明他们互不近似. *)",
    "votes": 0
  },
  {
    "id": 850,
    "src": "(** Find a program [cmin] that approximates every other program. *)",
    "dst": "(** 找到一个程序 [cmin] 近似所有别的程序。\n    给出形式化的 [cmin_minimal] 证明。 *)",
    "votes": 0
  },
  {
    "id": 851,
    "src": "(** Finally, find a non-trivial property which is preserved by\n    program approximation (when going from left to right). *)",
    "dst": "(** 最后，再找出程序近似的一个不太直观的属性 （当从左到右时）。\n    给出形式化的 [zprop_preserving] 证明。 *)",
    "votes": 0
  },
  {
    "id": 852,
    "src": "(** Intuitively, [zprop] holds of programs that terminate on all\n    inputs. *)",
    "dst": "(** 直观地看， [zprop] 包含所有对于所有输入都停机的程序。 *)",
    "votes": 0
  },
  {
    "id": 853,
    "src": "(** [zprop2] holds of programs that terminate on at least one\n    input. *)",
    "dst": "(** 至少有一个输入让 [zprop2] 能停机。 *)",
    "votes": 0
  },
  {
    "id": 854,
    "src": "(** [zprop3] holds of programs that behave like [SKIP]. *)",
    "dst": "(** [zprop3] 包含所有行为类似 [SKIP] 的程序。 *)",
    "votes": 0
  },
  {
    "id": 855,
    "src": "(** [zprop4] is similar to [zprop3] -- observe that [capprox]\n    is transitive. *)",
    "dst": "(** [zprop4] 类似于 [zprop3] -- 显然 [capprox] 有传递性。 *)",
    "votes": 0
  },
  {
    "id": 856,
    "src": "(** * Postscript *)",
    "dst": "(** * 后记 *)",
    "votes": 0
  },
  {
    "id": 857,
    "src": "(** Congratulations: We've made it to the end! *)",
    "dst": "(** 恭喜：我们完成了！ *)",
    "votes": 0
  },
  {
    "id": 858,
    "src": "(** * Looking Back *)",
    "dst": "(** * 回顾一下 *)",
    "votes": 0
  },
  {
    "id": 859,
    "src": "(** We've covered a lot of ground.  Here's a quick review...  \n\n   - _Functional programming_:\n          - \"declarative\" programming style (recursion over persistent\n            data structures, rather than looping over mutable arrays\n            or pointer structures)\n          - higher-order functions\n          - polymorphism *)",
    "dst": "(** 我们已经覆盖了很多内容。下面是快速阅览...\n   - _函数式编程_：\n          - \"声明式\" 编程风格 (在不变的数据结构上递归，\n            而非在可变的数组或指针结构上循环）\n          - 高阶函数\n          - 多态 *)",
    "votes": 0
  },
  {
    "id": 860,
    "src": "(**\n     - _Logic_, the mathematical basis for software engineering:\n<<\n               logic                        calculus\n        --------------------   ~   ----------------------------\n        software engineering       mechanical/civil engineering\n>>\n\n          - inductively defined sets and relations\n          - inductive proofs\n          - proof objects *)",
    "dst": "(**\n     - _逻辑_, 软件工程的数学基础：\n<<\n          逻辑               微积分\n        --------   ~   -----------------\n        软件工程       机械工程/土木工程\n>>\n          - 递归定义的集合，关系\n          - 归纳证明\n          - 证明对象 *)",
    "votes": 0
  },
  {
    "id": 861,
    "src": "(**\n     - _Coq_, an industrial-strength proof assistant\n          - functional core language\n          - core tactics\n          - automation\n*)",
    "dst": "(**\n     - _Coq_, 一个工业级的证明助理\n          - 函数式核心语言\n          - 核心策略\n          - 自动化\n*)",
    "votes": 0
  },
  {
    "id": 862,
    "src": "(**\n     - _Foundations of programming languages_\n\n           - notations and definitional techniques for precisely specifying\n                - abstract syntax\n                - operational semantics\n                    - big-step style\n                    - small-step style\n                - type systems\n\n           - program equivalence\n\n           - Hoare logic\n\n           - fundamental metatheory of type systems\n\n              - progress and preservation\n\n           - theory of subtyping\n*)",
    "dst": "(**\n     - _编程语言基础_\n           - 记法和定义上的技巧，用于精确地描述\n                - 抽象语法\n                - 操作语义\n                    - 大步风格\n                    - 小步风格\n                - 类型系统\n           - 程序等价性\n           - 霍尔逻辑\n           - 类型系统的基础元理论\n              - 可进性与维型性\n           - 子类型理论\n*)",
    "votes": 0
  },
  {
    "id": 863,
    "src": "(** * Looking Around *)",
    "dst": "(** * 四处瞧瞧 *)",
    "votes": 0
  },
  {
    "id": 864,
    "src": "(** Large-scale applications of these core topics can be found\n    everywhere, both in ongoing research projects and in real-world\n    software systems.  Here are a few recent examples involving\n    formal, machine-checked verification of real-world software and\n    hardware systems, to give a sense of what is being done\n    today... *)",
    "dst": "(** 这些核心主题的大规模应用可以在任何地方找到，无论是正在进行的研究项目，\n    还是现实世界的软件系统。这里有几个最近的例子，涉及对真实世界的软件和\n    硬件系统形式化的，机器检查的验证，让你对当今正的发展有直观的认识...\n    无论是进行中的研究项目，还是用于现实世界的软件系统，在它们之中都能看到\n    这些核心主题的大规模应用。为了让你对相关内容的应用及其发展有某种程度上的认识，\n    下面介绍一些新近的软件和硬件系统；它们的设计中均使用了形式化的、机器检查的证明，\n    而且已经在现实世界中得到应用了。 *)",
    "votes": 0
  },
  {
    "id": 865,
    "src": "(** *** CompCert *)",
    "dst": "(** *** CompCert *)",
    "votes": 0
  },
  {
    "id": 866,
    "src": "(** _CompCert_ is a fully verified optimizing compiler for almost all\n    of the ISO C90 / ANSI C language, generating code for x86, ARM,\n    and PowerPC processors.  The whole of CompCert is is written in\n    Gallina and extracted to an efficient OCaml program using Coq's\n    extraction facilities.\n\n    \"The CompCert project investigates the formal verification of\n    realistic compilers usable for critical embedded software. Such\n    verified compilers come with a mathematical, machine-checked proof\n    that the generated executable code behaves exactly as prescribed\n    by the semantics of the source program. By ruling out the\n    possibility of compiler-introduced bugs, verified compilers\n    strengthen the guarantees that can be obtained by applying formal\n    methods to source programs.\"\n\n    In 2011, CompCert was included in a landmark study on fuzz-testing\n    a large number of real-world C compilers using the CSmith tool.\n    The CSmith authors wrote:\n\n      - The striking thing about our CompCert results is that the\n        middle-end bugs we found in all other compilers are absent. As\n        of early 2011, the under-development version of CompCert is\n        the only compiler we have tested for which Csmith cannot find\n        wrong-code errors. This is not for lack of trying: we have\n        devoted about six CPU-years to the task. The apparent\n        unbreakability of CompCert supports a strong argument that\n        developing compiler optimizations within a proof framework,\n        where safety checks are explicit and machine-checked, has\n        tangible benefits for compiler users.\n\n    {http://compcert.inria.fr} *)",
    "dst": "(** _CompCert_ 是一个完全验证过的，带优化的 C 编译器，它支持几乎整个 ISO C90/ANSI C\n    标准。它能生成 x86、ARM 和 PowerPC 处理器的代码。CompCert 完全由 Gallina 写成，\n    并通过 Coq 的提取机制转换成高效的 OCaml 程序。\n    “CompCert 项目考察了可用于关键嵌入式软件的现实编译器的形式化验证。\n    这种经过验证的编译器具有数学上的，机器检查过的证明，它所生成的\n    可执行代码的行为与源程序的语义完全相同。通过排除编译器引入 Bug\n    的可能，经过验证的编译器加强了对源程序应用形式化方法所能得到的保证。”\n    2011 年，CompCert 被包含���一个使用 CSmith 工具对大量现实世界的\n    C 编译器进行模糊测试的划时代研究中。CSmith 的作者写道：\n(* TODO(osc): wrong code error 需要到 csmith 上查看含义 *)\n      - 引人注目的的是，我们在其它编译器中找到的中端缺陷在 CompCert\n        的结果中并不存在。截至 2011 年初，CompCert 的开发版是我们测试过的\n        唯一一个 CSmith 无法找到错误代码造成错误的编译器。\n        这并不是因为我们做的测试还不够多：我们已经在这个任务上花了六个CPU年。\n        CompCert 明显的牢不可破性强有力地证明了使用明确的，经过机器验证安全性检查的\n        证明框架来开发编译器优化，对编译器用户具有切实的好处。\n    {http://compcert.inria.fr} *)",
    "votes": 0
  },
  {
    "id": 867,
    "src": "(** _seL4_ is a fully verified microkernel, considered to be the\n    world's first OS kernel with an end-to-end proof of implementation\n    correctness and security enforcement.  It is implemented in C and\n    ARM assembly and specified and verified using Isabelle.  The code\n    is available as open source.\n\n    \"seL4 has been comprehensively formally verified: a rigorous\n    process to prove mathematically that its executable code, as it\n    runs on hardware, correctly implements the behaviour allowed by\n    the specification, and no others. Furthermore, we have proved that\n    the specification has the desired safety and security\n    properties (integrity and confidentiality)... The verification was\n    achieved at a cost that is significantly less than that of\n    traditional high-assurance development approaches, while giving\n    guarantees traditional approaches cannot provide.\"\n\n    {https://sel4.systems}. *)",
    "dst": "(** _seL4_ 是一个完全验证过的微内核，它被认为���世界上第一个通过了\n    实现正确性和强制安全性的端到端证明的 OS 内核。它以 C 和 ARM 汇编实现，\n    并使用 Isabelle 进行了规范化和验证。其代码是开源的。\n    「seL4 已经得到了全面的形式化验证：一个数学上严格的过程证明了\n    其可执行代码在硬件上运行时正确地实现了（而且只会有）规范所描述的行为。\n    此外，我们还证明了该规范拥有期望的安全性和安全属性（完整性和保密性）...\n    该验证的实现成本比传统的高可靠性开发方式明显更低，同时还提供了传统方法\n    无法提供的保证。」\n    {https://sel4.systems}. *)",
    "votes": 0
  },
  {
    "id": 868,
    "src": "(** _CertiKOS_ is a clean-slate, fully verified hypervisor, written in\n    CompCert C and verified in Coq.\n\n    \"The CertiKOS project aims to develop a novel and practical\n    programming infrastructure for constructing large-scale certified\n    system software. By combining recent advances in programming\n    languages, operating systems, and formal methods, we hope to\n    attack the following research questions: (1) what OS kernel\n    structure can offer the best support for extensibility, security,\n    and resilience? (2) which semantic models and program logics can\n    best capture these abstractions? (3) what are the right\n    programming languages and environments for developing such\n    certified kernels? and (4) how to build automation facilities to\n    make certified software development really scale?\"\n\n    {http://flint.cs.yale.edu/certikos/} *)",
    "dst": "(** _CertiKOS_ 是一个干净的，完全验证过的虚拟机管理器，以 CompCert C\n    编写，并通过 Coq 验证。\n    「CertiKOS 项目致力于开发一个新颖实用的，用于构建大规模认证系统软件\n    的编程基础设施。通过结合编程语言，操作系统和形式化方法的最新进展，\n    我们希望攻克以下研究问题：(1) 何种 OS 内核结构能够对可扩展性，\n    安全性和弹性提供最佳支持? (2) 哪种语义模型和程序逻辑能为它们提供\n    最佳抽象？ (3) 什么编程语言和环境最适合开发这种认证的内核？\n    (4) 如何建立自动化设施，使认证软件的开发真正具有规模？」\n    {http://flint.cs.yale.edu/certikos/} *)",
    "votes": 0
  },
  {
    "id": 869,
    "src": "(** _Ironclad Apps_ is a collection of fully verified web\n    applications, including a \"notary\" for securely signing\n    statements, a password hasher, a multi-user trusted counter, and a\n    differentially-private database.\n\n    The system is coded in the verification-oriented programming\n    language Dafny and verified using Boogie, a verification tool\n    based on Hoare logic.\n\n    \"An Ironclad App lets a user securely transmit her data to a\n    remote machine with the guarantee that every instruction executed\n    on that machine adheres to a formal abstract specification of the\n    app’s behavior. This does more than eliminate implementation\n    vulnerabilities such as buffer overflows, parsing errors, or data\n    leaks; it tells the user exactly how the app will behave at all\n    times. We provide these guarantees via complete, low-level\n    software verification. We then use cryptography and secure\n    hardware to enable secure channels from the verified software to\n    remote users.\"\n\n    {https://github.com/Microsoft/Ironclad/tree/master/ironclad-apps} *)",
    "dst": "(** _Ironclad 应用集_是一组完全验证过的 Web 应用，包括一个安全地签署声明的\n    「公证人」，一个密码散列器，一个多用户信任的计数器，和一个差异私有化的\n    数据库。\n    这套系统以面向验证的编程语言 Dafny 编写，并使用基于霍尔逻辑的\n    Boogie 验证工具验证。\n    「Ironclad 应用能够让用户安全地将其数据传输到远程机器，\n    并保证该机器上执行的每个指令都遵循该应用所应有行为的形式化的、抽象的规范。\n    这不仅消除了如缓冲区溢出，解析错误或数据泄漏之类的实现缺陷，\n    它还会告诉用户应用在任何时候所应具有的行为。我们通过完整的底层软件验证提供这些保障，\n    而在这之后，我们会通过加密和安全硬件来实现从已验证的软件到远程用户之间的安全通道。」\n    {https://github.com/Microsoft/Ironclad/tree/master/ironclad-apps} *)",
    "votes": 0
  },
  {
    "id": 870,
    "src": "(** _Verdi_ is a framework for implementing and formally verifying\n    distributed systems.\n\n    \"Verdi supports several different fault models ranging from\n    idealistic to realistic. Verdi's verified system\n    transformers (VSTs) encapsulate common fault tolerance\n    techniques. Developers can verify an application in an idealized\n    fault model, and then apply a VST to obtain an application that is\n    guaranteed to have analogous properties in a more adversarial\n    environment.  Verdi is developed using the Coq proof assistant,\n    and systems are extracted to OCaml for execution. Verdi systems,\n    including a fault-tolerant key-value store, achieve comparable\n    performance to unverified counterparts.\"\n\n    {http://verdi.uwplse.org} *)",
    "dst": "(** _Verdi_ 是一个用于实现并形式化验证分布式系统的框架。\n    「Verdi 支持从概念到现实的几种不同的故障模型。Verdi 的已验证的系统变换器\n    （verified system transformers）包含一些通用的容错技巧。\n    开发者可在理想化的故障模型中验证应用，\n    然后对其应用 VST 来得到一个保证能在更具对抗性的环境中拥有类似性质的应用。\n    Verdi 使用 Coq 证明助理开发，而这些验证的系统提取为 OCaml 用于执行。Verdi 系统\n    包含了带容错的键值存储，以获得与相对应的未经验证的版本相当的性能。」\n    {http://verdi.uwplse.org} *)",
    "votes": 0
  },
  {
    "id": 871,
    "src": "(** _The Science of Deep Specification_ is an NSF \"Expedition\"\n    project (running from 2016 to 2020) that focuses on the\n    specification and verification of full functional correctness of\n    both software and hardware.  It also sponsors workshops and summer\n    schools.\n      - Website: {http://deepspec.org/}\n      - Overview presentations: \n          - {http://deepspec.org/about/}\n          - {https://www.youtube.com/watch?v=IPNdsnRWBkk} *)",
    "dst": "(** _深度规范科学（The Science of Deep Specification）_是 NSF 的一个「远征」项目\n    （从2016年到2020年），它专注于软件和硬件的完整功能的正确性的规范和验证。\n    它也赞助了一些研讨会和暑期班。\n      - 网站：{http://deepspec.org/}\n      - 概览展示：\n          - {http://deepspec.org/about/}\n          - {https://www.youtube.com/watch?v=IPNdsnRWBkk} *)",
    "votes": 0
  },
  {
    "id": 872,
    "src": "(** _REMS_ is a european project on Rigorous Engineering of Mainstream\n    Systems.  It has produced detailed formal specifications of a wide\n    range of critical real-world interfaces, protocols, and APIs,\n    including \n      the C language, \n      the ELF linker format,\n      the ARM, Power, MIPS, CHERI, and RISC-V instruction sets,\n      the weak memory models of ARM and Power processors, and\n      POSIX filesystems.\n\n    \"The project is focussed on lightweight rigorous methods: precise\n    specification (post hoc and during design) and testing against\n    specifications, with full verification only in some cases. The\n    project emphasises building useful (and reusable) semantics and\n    tools. We are building accurate full-scale mathematical models of\n    some of the key computational abstractions (processor\n    architectures, programming languages, concurrent OS interfaces,\n    and network protocols), studying how this can be done, and\n    investigating how such models can be used for new verification\n    research and in new systems and programming language\n    research. Supporting all this, we are also working on new\n    specification tools and their foundations.\"\n\n    {http://www.cl.cam.ac.uk/~pes20/rems/} *)",
    "dst": "(** _REMS_ 是一个来自欧洲的有关主流系统严格化工程（Rigorous Engineering of Mainstream Systems）\n    的项目。它已经为一系列被用于现实世界中的关键的接口、协议和 API 提供了包含了许多细节的形式化规范\n    这些应用包括：\n      C 语言，\n      ELF 链接器格式，\n      ARM、Power、MIPS、CHERI 和 RISC-V 指令集，\n      ARM 和 Power 处理器的弱内存模型，以及\n      POSIX 文件系统。\n    「该项目专注于轻量级严格化方法：（设计过程和之后的）精确规范和针对测试的规范，\n    仅在某些情况下进行完全验证。该项目强调建立有用（且可重用）的语义和工具。\n    我们正为一些关键的计算抽象（处理器架构、编程语言、并发操作系统接口、以及网络协议）\n    建立准确而全面的数学模型，同时我们也在研究如何做到这一点，并探讨如何将这些模型应用到\n    新的验证研究，以及新系统和编程语言的研究中。为了支持这一切，我们也在开发新的规范工具及其基础。」\n    {http://www.cl.cam.ac.uk/~pes20/rems/} *)",
    "votes": 0
  },
  {
    "id": 873,
    "src": "(** There's much more.  Other projects worth checking out include:\n      - Vellvm (formal specification and verification of LLVM\n        optimization passes)\n      - Zach Tatlock's formally certified browser\n      - Tobias Nipkow's formalization of most of Java\n      - The CakeML verified ML compiler\n      - Greg Morrisett's formal specification of the x86 instruction\n        set and the RockSalt Software Fault Isolation tool (a better,\n        faster, more secure version of Google's Native Client)\n      - Ur/Web, a programming language for verified web applications\n        embedded in Coq\n      - the Princeton Verified Software Toolchain\n*)",
    "dst": "(** 还有更多。其它值得一看的项目包括：\n      - Vellvm（LLVM 优化 pass 的形式化标准和验证）\n      - Zach Tatlock 的形式化验证的浏览器\n      - Tobias Nipkow 的经过形式化验证的 Java 子集\n      - CakeML 一个经过验证的 ML 编译器\n      - Greg Morrisett 的形式化 x86 指令集规范以及 RockSalt 软件缺陷隔离工具\n        （一个更好，更快，更安全的 Google Native Client）\n      - Ur/Web，一个嵌入在 Coq 中的，经过验证的 web 应用编程语言\n      - Princeton 验证软件工具链\n*)",
    "votes": 0
  },
  {
    "id": 874,
    "src": "(** *** Others *)",
    "dst": "(** *** 其它 *)",
    "votes": 0
  },
  {
    "id": 875,
    "src": "(** * Looking Forward *)",
    "dst": "(** * 继续前行 *)",
    "votes": 0
  },
  {
    "id": 876,
    "src": "(** Some good places to learn more...\n\n       - This book includes several optional chapters covering topics\n         that you may find useful.  Take a look at the #<a\n         href=\"toc.html\">#table of contents#</a># and the #<a\n         href=\"deps.html\">#chapter dependency diagram#</a># to find\n         them.\n\n       - Cutting-edge conferences on programming languages and formal\n         verification:\n            - Principles of Programming Langauges (POPL)\n            - Programming Language Design and Implementation (PLDI)\n            - SPLASH/OOPSLA\n            - International Conference on Functional\n              Programming (ICFP)\n            - Computer Aided Verification (CAV)\n            - Interactive Theorem Proving (ITP)\n            - Principles in Practice workshop (PiP)\n            - CoqPL workshop\n\n       - More on functional programming\n            - Learn You a Haskell for Great Good, by Miran Lipovaca\n              \\CITE{Lipovaca 2011}.\n            - Real World Haskell, by Bryan O'Sullivan, John Goerzen,\n              and Don Stewart \\CITE{O'Sullivan 2008}\n            - ...and many other excellent books on Haskell, OCaml,\n              Scheme, Racket, Scala, F sharp, etc., etc.\n\n       - More on Hoare logic and program verification\n            - The Formal Semantics of Programming Languages: An\n              Introduction, by Glynn Winskel \\CITE{Winskel 1993}.\n            - Many practical verification tools, e.g. Microsoft's\n              Boogie system, Java Extended Static Checking, etc.\n\n       - More on the foundations of programming languages:\n            - Concrete Semantics with Isabelle/HOL, by Tobias Nipkow\n              and Gerwin Klein \\CITE{Nipkow 2014}\n            - Types and Programming Languages, by Benjamin C. Pierce\n              \\CITE{Pierce 2002}.\n            - Practical Foundations for Programming Languages, by\n              Robert Harper \\CITE{Harper 2016}.\n            - Foundations for Programming Languages, by John\n              C. Mitchell \\CITE{Mitchell 1996}.\n\n       - More on Coq:\n           - Verified Functional Algorithms, by Andrew Appel\n             \\CITE{Chlipala 2013}.\n           - Certified Programming with Dependent Types, by Adam\n             Chlipala \\CITE{Chlipala 2013}.\n           - Interactive Theorem Proving and Program Development:\n             Coq'Art: The Calculus of Inductive Constructions, by Yves\n             Bertot and Pierre Casteran \\CITE{Bertot 2004}.\n           - Iron Lambda (http://iron.ouroborus.net/) is a collection\n             of ​Coq formalisations for functional languages of\n             increasing complexity. It fills part of the gap between\n             the end of the​ Software Foundations course and what\n             appears in current research papers.  The collection has\n             at least Progress and Preservation theorems for a number\n             of variants of STLC and the polymorphic\n             lambda-calculus (System F). *)",
    "dst": "(** 对欲求不满的人．．．\n       - 本书中一些可选章节覆盖的主题可能对你有用。你可以从\n         #<a href=\"toc.html\">#内容列表#</a># 以及\n         #<a href=\"deps.html\">#章节依赖图#</a># 中找到它们。\n       - 编程语言及形式化验证的顶级会议：\n            - Principles of Programming Langauges (POPL)\n            - Programming Language Design and Implementation (PLDI)\n            - SPLASH/OOPSLA\n            - International Conference on Functional\n              Programming (ICFP)\n            - Computer Aided Verification (CAV)\n            - Interactive Theorem Proving (ITP)\n            - Principles in Practice workshop (PiP)\n            - CoqPL workshop\n       - 更多与函数式编程相关的内容：\n            - Learn You a Haskell for Great Good, by Miran Lipovaca\n              \\CITE{Lipovaca 2011}.\n            - Real World Haskell, by Bryan O'Sullivan, John Goerzen,\n              and Don Stewart \\CITE{O'Sullivan 2008}\n            - ...以及 Haskell、OCaml、Scheme、Racket、Scala、F sharp\n              等其它优秀的书籍。\n       - 更多与霍尔逻辑和程序验证相关的内容：\n            - The Formal Semantics of Programming Languages: An\n              Introduction, by Glynn Winskel \\CITE{Winskel 1993}.\n            - 许多实用的验证工具如微软的 Boogie system，\n              Java Extended Static Checking 等。\n       - 更多编程语言基础：\n            - Concrete Semantics with Isabelle/HOL, by Tobias Nipkow\n              and Gerwin Klein \\CITE{Nipkow 2014}\n            - Types and Programming Languages, by Benjamin C. Pierce\n              \\CITE{Pierce 2002}.\n            - Practical Foundations for Programming Languages, by\n              Robert Harper \\CITE{Harper 2016}.\n            - Foundations for Programming Languages, by John\n              C. Mitchell \\CITE{Mitchell 1996}.\n       - 更多 Coq 相关:\n           - Verified Functional Algorithms, by Andrew Appel\n             \\CITE{Chlipala 2013}.\n           - Certified Programming with Dependent Types, by Adam\n             Chlipala \\CITE{Chlipala 2013}.\n           - 交互式定理证明与程序开发：\n             Coq'Art: The Calculus of Inductive Constructions, by Yves\n             Bertot and Pierre Casteran \\CITE{Bertot 2004}.\n           - Iron Lambda (http://iron.ouroborus.net/) 是一个关于函数式编程形式化的集合，\n             它包含将多种函数式语言（它们的复杂性逐步增加）形式化的 Coq 代码。\n             它填补了本课程与最新研究论文所涵盖内容之间的缝隙。\n             该集合包含多种有关 STLC 与多态 λ-演算（即 System F）相关性质\n             （至少包含其可进性与维型性）的证明。 *)",
    "votes": 0
  },
  {
    "id": 877,
    "src": "(* Optional argument says how deep to search (default is 5) *)",
    "dst": "(* Optional argument says how deep to search (default is 5) *) WTF",
    "votes": 0
  }
]
